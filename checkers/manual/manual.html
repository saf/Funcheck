<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>
<TITLE>The Checker Framework: 
Custom pluggable types for Java
</TITLE>

<META http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<META name="GENERATOR" content="hevea 1.10">
<STYLE type="text/css">
.li-itemize{margin:1ex 0ex;}
.li-enumerate{margin:1ex 0ex;}
.dd-description{margin:0ex 0ex 1ex 4ex;}
.dt-description{margin:0ex;}
.toc{list-style:none;}
.thefootnotes{text-align:left;margin:0ex;}
.dt-thefootnotes{margin:0em;}
.dd-thefootnotes{margin:0em 0em 0em 2em;}
.footnoterule{margin:1em auto 1em 0px;width:50%;}
.caption{padding-left:2ex; padding-right:2ex; margin-left:auto; margin-right:auto}
.title{margin:2ex auto;text-align:center}
.center{text-align:center;margin-left:auto;margin-right:auto;}
.flushleft{text-align:left;margin-left:0ex;margin-right:auto;}
.flushright{text-align:right;margin-left:auto;margin-right:0ex;}
DIV TABLE{margin-left:inherit;margin-right:inherit;}
PRE{text-align:left;margin-left:0ex;margin-right:auto;}
BLOCKQUOTE{margin-left:4ex;margin-right:4ex;text-align:left;}
TD P{margin:0px;}
.boxed{border:1px solid black}
.textboxed{border:1px solid black}
.vbar{border:none;width:2px;background-color:black;}
.hbar{border:none;height:2px;width:100%;background-color:black;}
.hfill{border:none;height:1px;width:200%;background-color:black;}
.vdisplay{border-collapse:separate;border-spacing:2px;width:auto; empty-cells:show; border:2px solid red;}
.vdcell{white-space:nowrap;padding:0px;width:auto; border:2px solid green;}
.display{border-collapse:separate;border-spacing:2px;width:auto; border:none;}
.dcell{white-space:nowrap;padding:0px;width:auto; border:none;}
.dcenter{margin:0ex auto;}
.vdcenter{border:solid #FF8000 2px; margin:0ex auto;}
.minipage{text-align:left; margin-left:0em; margin-right:auto;}
.marginpar{border:solid thin black; width:20%; text-align:left;}
.marginparleft{float:left; margin-left:0ex; margin-right:1ex;}
.marginparright{float:right; margin-left:1ex; margin-right:0ex;}
.theorem{text-align:left;margin:1ex auto 1ex 0ex;}
.part{margin:2ex auto;text-align:center}
.lstlisting{font-family:monospace;white-space:pre;margin-right:auto;margin-left:0pt;text-align:left}
.lstframe{margin:auto;margin-bottom:2em}
</STYLE>
</HEAD>
<BODY >
<!--HEVEA command line is: hevea -exec xxdate.exe urlhref.hva manual.tex -->
<!--CUT DEF chapter 1 --><TABLE CLASS="title"><TR><TD><H1 CLASS="titlemain">The Checker Framework:<BR>
Custom pluggable types for Java</H1><H3 CLASS="titlerest"><A HREF="http://types.cs.washington.edu/checker-framework/"><TT>http://types.cs.washington.edu/checker-framework/</TT></A></H3><H3 CLASS="titlerest">Version 1.1.1 (19 Sep 2010)</H3></TD></TR>
</TABLE><P><B>For the impatient:</B>
Section&#XA0;<A HREF="#installation">1.2</A>
describes how to <B>install and use</B> pluggable type-checkers.</P><!--TOC chapter Contents-->
<H1 CLASS="chapter"><!--SEC ANCHOR -->Contents</H1><!--SEC END --><UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#introduction">1&#XA0;&#XA0;Introduction</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#pluggable-types">1.1&#XA0;&#XA0;How it works: Pluggable types</A>
</LI><LI CLASS="li-toc"><A HREF="#installation">1.2&#XA0;&#XA0;Installation</A>
</LI><LI CLASS="li-toc"><A HREF="#example-use">1.3&#XA0;&#XA0;Example use: detecting a null pointer bug</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#using-a-checker">2&#XA0;&#XA0;Using a checker</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#writing-annotations">2.1&#XA0;&#XA0;Writing annotations</A>
</LI><LI CLASS="li-toc"><A HREF="#running">2.2&#XA0;&#XA0;Running a checker</A>
</LI><LI CLASS="li-toc"><A HREF="#checker-guarantees">2.3&#XA0;&#XA0;What the checker guarantees</A>
</LI><LI CLASS="li-toc"><A HREF="#tips-about-writing-annotations">2.4&#XA0;&#XA0;Tips about writing annotations</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#nullness-checker">3&#XA0;&#XA0;Nullness checker</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#nullness-annotations">3.1&#XA0;&#XA0;Nullness annotations</A>
</LI><LI CLASS="li-toc"><A HREF="#writing-nullness-annotations">3.2&#XA0;&#XA0;Writing nullness annotations</A>
</LI><LI CLASS="li-toc"><A HREF="#nullness-checks">3.3&#XA0;&#XA0;What the Nullness checker checks</A>
</LI><LI CLASS="li-toc"><A HREF="#suppressing-warnings-nullness">3.4&#XA0;&#XA0;Suppressing nullness warnings</A>
</LI><LI CLASS="li-toc"><A HREF="#raw-partially-initialized">3.5&#XA0;&#XA0;<TT>@Raw</TT> annotation for partially-initialized objects</A>
</LI><LI CLASS="li-toc"><A HREF="#map-keys">3.6&#XA0;&#XA0;Map key annotations</A>
</LI><LI CLASS="li-toc"><A HREF="#nullness-example">3.7&#XA0;&#XA0;Examples</A>
</LI><LI CLASS="li-toc"><A HREF="#nullness-related-work">3.8&#XA0;&#XA0;Other tools for nullness checking</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#interning-checker">4&#XA0;&#XA0;Interning checker</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#interning-annotations">4.1&#XA0;&#XA0;Interning annotations</A>
</LI><LI CLASS="li-toc"><A HREF="#annotating-with-interned">4.2&#XA0;&#XA0;Annotating your code with <TT>@Interned</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#interning-checks">4.3&#XA0;&#XA0;What the Interning checker checks</A>
</LI><LI CLASS="li-toc"><A HREF="#interning-example">4.4&#XA0;&#XA0;Examples</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#igj-checker">5&#XA0;&#XA0;IGJ immutability checker</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#igj-and-mutability">5.1&#XA0;&#XA0;IGJ and Mutability</A>
</LI><LI CLASS="li-toc"><A HREF="#igj-annotations">5.2&#XA0;&#XA0;IGJ Annotations</A>
</LI><LI CLASS="li-toc"><A HREF="#igj-checks">5.3&#XA0;&#XA0;What the IGJ checker checks</A>
</LI><LI CLASS="li-toc"><A HREF="#igj-implicit-qualifiers">5.4&#XA0;&#XA0;Implicit and default qualifiers</A>
</LI><LI CLASS="li-toc"><A HREF="#annotation-igj-dialect">5.5&#XA0;&#XA0;Annotation IGJ Dialect</A>
</LI><LI CLASS="li-toc"><A HREF="#igj-example">5.6&#XA0;&#XA0;Examples</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#javari-checker">6&#XA0;&#XA0;Javari immutability checker</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#javary-annotations">6.1&#XA0;&#XA0;Javari annotations</A>
</LI><LI CLASS="li-toc"><A HREF="#writing-javari-annotations">6.2&#XA0;&#XA0;Writing Javari annotations</A>
</LI><LI CLASS="li-toc"><A HREF="#javari-checks">6.3&#XA0;&#XA0;What the Javari checker checks</A>
</LI><LI CLASS="li-toc"><A HREF="#javari-examples">6.4&#XA0;&#XA0;Examples</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#lock-checker">7&#XA0;&#XA0;Lock checker</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#lock-annotations">7.1&#XA0;&#XA0;Lock annotations</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#fenum-checker">8&#XA0;&#XA0;Fake Enum checker</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#fenum-annotations">8.1&#XA0;&#XA0;Fake enum annotations</A>
</LI><LI CLASS="li-toc"><A HREF="#fenum-checks">8.2&#XA0;&#XA0;What the Fenum checker checks</A>
</LI><LI CLASS="li-toc"><A HREF="#fenum-running">8.3&#XA0;&#XA0;Running the Fenum checker</A>
</LI><LI CLASS="li-toc"><A HREF="#fenum-suppressing">8.4&#XA0;&#XA0;Suppressing warnings</A>
</LI><LI CLASS="li-toc"><A HREF="#fenum-example">8.5&#XA0;&#XA0;Example</A>
</LI><LI CLASS="li-toc"><A HREF="#fenum-references">8.6&#XA0;&#XA0;References</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#tainting-checker">9&#XA0;&#XA0;Tainting checker</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#tainting-annotations">9.1&#XA0;&#XA0;Tainting annotations</A>
</LI><LI CLASS="li-toc"><A HREF="#writing-untainted">9.2&#XA0;&#XA0;Tips on writing <TT>@Untainted</TT> annotations</A>
</LI><LI CLASS="li-toc"><A HREF="#tainting-many-uses">9.3&#XA0;&#XA0;<TT>@Tainted</TT> and <TT>@Untainted</TT> can be used for many purposes</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#linear-checker">10&#XA0;&#XA0;Linear checker for preventing aliasing</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#linear-annotations">10.1&#XA0;&#XA0;Linear annotations</A>
</LI><LI CLASS="li-toc"><A HREF="#linear-limitations">10.2&#XA0;&#XA0;Limitations</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#regex-checker">11&#XA0;&#XA0;Regex checker for regular expression syntax</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#regex-annotations">11.1&#XA0;&#XA0;Regex annotations</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#propkey-checker">12&#XA0;&#XA0;Property file checker</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#genpropkey-checker">12.1&#XA0;&#XA0;Generic property file checker</A>
</LI><LI CLASS="li-toc"><A HREF="#i18n-checker">12.2&#XA0;&#XA0;Internationalization checker</A>
</LI><LI CLASS="li-toc"><A HREF="#compilermsgs-checker">12.3&#XA0;&#XA0;Compiler Message Key checker</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#basic-checker">13&#XA0;&#XA0;Basic checker</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#basic-using">13.1&#XA0;&#XA0;Using the Basic checker</A>
</LI><LI CLASS="li-toc"><A HREF="#encrypted-example">13.2&#XA0;&#XA0;Basic checker example</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#typestate-checker">14&#XA0;&#XA0;Typestate checker</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#typestate-vs-type-refinement">14.1&#XA0;&#XA0;Comparison to flow-sensitive type refinement</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#external-checkers">15&#XA0;&#XA0;External checkers</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#units-checker">15.1&#XA0;&#XA0;Units and dimensions checker</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#advanced-type-system-features">16&#XA0;&#XA0;Advanced type system features</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#polymorphism">16.1&#XA0;&#XA0;Polymorphism and generics</A>
</LI><LI CLASS="li-toc"><A HREF="#unused-fields-and-dependent-types">16.2&#XA0;&#XA0;Unused fields and dependent types</A>
</LI><LI CLASS="li-toc"><A HREF="#effective-qualifier">16.3&#XA0;&#XA0;The effective qualifier on a type (defaults and inference)</A>
</LI><LI CLASS="li-toc"><A HREF="#inexpressible-types">16.4&#XA0;&#XA0;Inexpressible types</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#warnings-and-legacy">17&#XA0;&#XA0;Handling warnings and legacy code</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#unannotated-code">17.1&#XA0;&#XA0;Checking partially-annotated programs: handling unannotated code</A>
</LI><LI CLASS="li-toc"><A HREF="#suppressing-warnings">17.2&#XA0;&#XA0;Suppressing warnings</A>
</LI><LI CLASS="li-toc"><A HREF="#annotations-in-comments">17.3&#XA0;&#XA0;Writing annotations in comments for backward compatibility</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#annotating-libraries">18&#XA0;&#XA0;Annotating libraries</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#stub-creating-and-using">18.1&#XA0;&#XA0;Using stub classes</A>
</LI><LI CLASS="li-toc"><A HREF="#skeleton">18.2&#XA0;&#XA0;Using distributed annotated JDKs</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#writing-a-checker">19&#XA0;&#XA0;How to create a new checker</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#tool-relationships">19.1&#XA0;&#XA0;Relationship of the Checker Framework to other tools</A>
</LI><LI CLASS="li-toc"><A HREF="#parts-of-a-checker">19.2&#XA0;&#XA0;The parts of a checker</A>
</LI><LI CLASS="li-toc"><A HREF="#writing-typequals">19.3&#XA0;&#XA0;Annotations: Type qualifiers and hierarchy</A>
</LI><LI CLASS="li-toc"><A HREF="#writing-type-introduction">19.4&#XA0;&#XA0;Type factory: Implicit annotations</A>
</LI><LI CLASS="li-toc"><A HREF="#extending-visitor">19.5&#XA0;&#XA0;Visitor: Type rules</A>
</LI><LI CLASS="li-toc"><A HREF="#writing-compiler-interface">19.6&#XA0;&#XA0;The checker class: Compiler interface</A>
</LI><LI CLASS="li-toc"><A HREF="#testing-framework">19.7&#XA0;&#XA0;Testing framework</A>
</LI><LI CLASS="li-toc"><A HREF="#debugging-options">19.8&#XA0;&#XA0;Debugging options</A>
</LI><LI CLASS="li-toc"><A HREF="#javac-tips">19.9&#XA0;&#XA0;javac implementation survival guide</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#external-tools">20&#XA0;&#XA0;Integration with external tools</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#javac-installation">20.1&#XA0;&#XA0;Javac Compiler</A>
</LI><LI CLASS="li-toc"><A HREF="#ant-task">20.2&#XA0;&#XA0;Ant task</A>
</LI><LI CLASS="li-toc"><A HREF="#maven-plugin">20.3&#XA0;&#XA0;Maven plugin</A>
</LI><LI CLASS="li-toc"><A HREF="#intellij">20.4&#XA0;&#XA0;IntelliJ IDEA</A>
</LI><LI CLASS="li-toc"><A HREF="#eclipse">20.5&#XA0;&#XA0;Eclipse</A>
</LI><LI CLASS="li-toc"><A HREF="#tide">20.6&#XA0;&#XA0;tIDE</A>
</LI><LI CLASS="li-toc"><A HREF="#type-inference-tools">20.7&#XA0;&#XA0;Type inference tools</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#faq">21&#XA0;&#XA0;Frequently Asked Questions (FAQs)</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#faq-ease-of-use">21.1&#XA0;&#XA0;Are type annotations easy to read and write?</A>
</LI><LI CLASS="li-toc"><A HREF="#faq-code-clutter">21.2&#XA0;&#XA0;Will my code become cluttered with type annotations?</A>
</LI><LI CLASS="li-toc"><A HREF="#faq-no-absolute-guarantee">21.3&#XA0;&#XA0;Can a pluggable type-checker give an absolute guarantee of correctness?</A>
</LI><LI CLASS="li-toc"><A HREF="#never-make-type-errors">21.4&#XA0;&#XA0;I don&#X2019;t make type errors, so would pluggable type checking help me?</A>
</LI><LI CLASS="li-toc"><A HREF="#faq-no-annotation-on-types-and-declarations">21.5&#XA0;&#XA0;Why shouldn&#X2019;t a qualifier apply to both types and declarations?</A>
</LI><LI CLASS="li-toc"><A HREF="#faq-qualifiers-vs-subclasses">21.6&#XA0;&#XA0;When should I use type qualifiers, and when should I use subclasses?</A>
</LI><LI CLASS="li-toc"><A HREF="#faq-annotate-existing-program">21.7&#XA0;&#XA0;How do I get started annotating an existing program?</A>
</LI><LI CLASS="li-toc"><A HREF="#faq-run-on-all-files">21.8&#XA0;&#XA0;How do I run a checker on all my source files?</A>
</LI><LI CLASS="li-toc"><A HREF="#faq-shorten-command-line">21.9&#XA0;&#XA0;How do I shorten the command line when invoking a checker?</A>
</LI><LI CLASS="li-toc"><A HREF="#faq-create-a-checker">21.10&#XA0;&#XA0;How do I create a new checker?</A>
</LI><LI CLASS="li-toc"><A HREF="#faq-declarative-syntax-for-type-rules">21.11&#XA0;&#XA0;Why is there no declarative syntax for writing type rules?</A>
</LI><LI CLASS="li-toc"><A HREF="#faq-type-checking-vs-bug-detectors">21.12&#XA0;&#XA0;Why not just use a bug detector (like FindBugs)?</A>
</LI><LI CLASS="li-toc"><A HREF="#faq-jml">21.13&#XA0;&#XA0;How does pluggable type-checking compare with JML?</A>
</LI><LI CLASS="li-toc"><A HREF="#faq-array-syntax-meaning">21.14&#XA0;&#XA0;What is the meaning of array annotations such as <TT>@NonNull Object @Nullable []</TT>?</A>
</LI><LI CLASS="li-toc"><A HREF="#faq-list-map-nonnull-typeargs">21.15&#XA0;&#XA0;Why are the type parameters to <TT>List</TT> and <TT>Map</TT> annotated as <TT>@NonNull</TT>?</A>
</LI><LI CLASS="li-toc"><A HREF="#faq-run-time-checking">21.16&#XA0;&#XA0;How can I do run-time monitoring of properties that were not statically checked?</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#troubleshooting">22&#XA0;&#XA0;Troubleshooting and getting help</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#common-problems">22.1&#XA0;&#XA0;Common problems and solutions</A>
</LI><LI CLASS="li-toc"><A HREF="#reporting-bugs">22.2&#XA0;&#XA0;How to report problems</A>
</LI><LI CLASS="li-toc"><A HREF="#build-source">22.3&#XA0;&#XA0;Building from source</A>
</LI><LI CLASS="li-toc"><A HREF="#learning-more">22.4&#XA0;&#XA0;Learning more</A>
</LI><LI CLASS="li-toc"><A HREF="#other-tools">22.5&#XA0;&#XA0;Comparison to other tools</A>
</LI><LI CLASS="li-toc"><A HREF="#credits">22.6&#XA0;&#XA0;Credits and changelog</A>
</LI></UL>
</LI></UL><HR><!--TOC chapter Introduction-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="introduction">Chapter&#XA0;1</A>&#XA0;&#XA0;Introduction</H1><!--SEC END --><P>The Checker Framework enhances Java&#X2019;s type system to make it more powerful
and useful.
This lets software developers detect and
prevent errors in their Java programs.</P><P>The Checker Framework comes with checkers for specific types of errors:</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate"><A HREF="#nullness-checker">Nullness checker</A> for null pointer errors
(see Chapter&#XA0;<A HREF="#nullness-checker">3</A>)
</LI><LI CLASS="li-enumerate"><A HREF="#interning-checker">Interning checker</A> for errors in equality
testing and interning (see Chapter&#XA0;<A HREF="#interning-checker">4</A>)
</LI><LI CLASS="li-enumerate"><A HREF="#igj-checker">IGJ checker</A> for mutation errors (incorrect
side effects), based on the IGJ type system (see
Chapter&#XA0;<A HREF="#igj-checker">5</A>)
</LI><LI CLASS="li-enumerate"><A HREF="#javari-checker">Javari checker</A> for mutation errors
(incorrect side effects), based on the Javari type system (see
Chapter&#XA0;<A HREF="#javari-checker">6</A>)
</LI><LI CLASS="li-enumerate"><A HREF="#lock-checker">Lock checker</A> for concurrency and lock errors,
inspired by the Java Concurrency in Practice (JCIP) annotations (see
Chapter&#XA0;<A HREF="#lock-checker">7</A>)
</LI><LI CLASS="li-enumerate"><A HREF="#fenum-checker">Fake enum checker</A> to allow type-safe fake enum
patterns (see Chapter&#XA0;<A HREF="#fenum-checker">8</A>)
</LI><LI CLASS="li-enumerate"><A HREF="#tainting-checker">Tainting checker</A> for trust and security errors
(see Chapter&#XA0;<A HREF="#tainting-checker">9</A>)
</LI><LI CLASS="li-enumerate"><A HREF="#linear-checker">Linear checker</A> to control aliasing and prevent
re-use (see Chapter&#XA0;<A HREF="#linear-checker">10</A>)
</LI><LI CLASS="li-enumerate"><A HREF="#regex-checker">Regex checker</A> to prevent use of syntactically
invalid regular expressions (see Chapter&#XA0;<A HREF="#regex-checker">11</A>)
</LI><LI CLASS="li-enumerate"><A HREF="#propkey-checker">Property file checker</A> to ensure that valid
keys are used for property files and resource bundles (see
Chapter&#XA0;<A HREF="#propkey-checker">12</A>).
Also includes a checker that code is properly internationalized
and a checker for compiler message keys as used in the Checker Framework.
</LI><LI CLASS="li-enumerate"><A HREF="#basic-checker">Basic checker</A> for customized checking without
writing any code (see Chapter&#XA0;<A HREF="#basic-checker">13</A>)
</LI><LI CLASS="li-enumerate"><A HREF="#typestate-checker">Typestate checker</A> to ensure operations are
performed on objects that are in the right state, such as only opened
files being read (see Chapter&#XA0;<A HREF="#typestate-checker">14</A>)
</LI><LI CLASS="li-enumerate"><A HREF="#units-checker">Units and dimensions checker</A> to prevent
mixing variables that measure different quantities (see Chapter&#XA0;<A HREF="#units-checker">15.1</A>)
</LI></OL><P>These checkers are easy to use and are invoked as arguments to <TT>javac</TT>.</P><P>The Checker Framework also enables you to write new checkers of your
own; see Chapters&#XA0;<A HREF="#basic-checker">13</A> and&#XA0;<A HREF="#writing-a-checker">19</A>.</P><!--TOC section How it works: Pluggable types-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="pluggable-types">1.1</A>&#XA0;&#XA0;How it works: Pluggable types</H2><!--SEC END --><P>The Checker Framework supports adding
pluggable type systems to the Java language in a backward-compatible way.
Java&#X2019;s built-in typechecker finds and prevents many errors &#X2014; but it
doesn&#X2019;t find and prevent <EM>enough</EM> errors. The Checker Framework lets you
run an additional typechecker as a plug-in to the javac compiler. Your
code stays completely backward-compatible: your code compiles with any
Java compiler, it runs on any JVM, and your coworkers don&#X2019;t have to use the
enhanced type system if they don&#X2019;t want to. You can check only part of
your program. Type inference tools exist to help you annotate your
code.</P><P>A type system designer uses the Checker Framework to define type qualifiers
and their semantics, and a
compiler plug-in (a &#X201C;checker&#X201D;) enforces the semantics. Programmers can
write the type qualifiers in their programs and use the plug-in to detect
or prevent errors. The Checker Framework is useful both to programmers who
wish to write error-free code, and to type system designers who wish to
evaluate and deploy their type systems.</P><P>This document uses the terms &#X201C;checker&#X201D;, &#X201C;checker plugin&#X201D;,
&#X201C;type-checking compiler plugin&#X201D;, and &#X201C;annotation processor&#X201D; as
synonyms.</P><!--TOC section Installation-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="installation">1.2</A>&#XA0;&#XA0;Installation</H2><!--SEC END --><P>This section describes how to install the binary release of the Checker
Framework. The binary release contains everything that you need, both to
run checkers and to write your own checkers. As an alternative, you can
build the latest development version from source
(Section&#XA0;<A HREF="#build-source">22.3</A>).</P><P><B>Requirement:</B>
You must have <B>JDK 6</B> or later installed. You can get JDK 6 from
<A HREF="http://www.oracle.com/technetwork/java/javase/downloads/">Oracle</A>
or elsewhere. If you are using Apple Mac OS X, you can use
<A HREF="http://developer.apple.com/java/">Apple&#X2019;s implementation</A> or
<A HREF="http://landonf.bikemonkey.org/static/soylatte/">SoyLatte</A>.</P><P>The installation process is simple! (For a set of commands that you can
copy and paste into your command shell, see
Section&#XA0;<A HREF="#javac-installation">20.1</A>.)
</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
Download the Checker Framework distribution
(<A HREF="http://types.cs.washington.edu/checker-framework/current/checkers.zip"><TT>http://types.cs.washington.edu/checker-framework/current/checkers.zip</TT></A>).
</LI><LI CLASS="li-enumerate">Unzip it to create a <TT>checker-framework</TT> directory.
</LI><LI CLASS="li-enumerate">Optionally, update your execution path.<P>When doing pluggable type-checking, you need to use the &#X201C;Type
Annotations compiler&#X201D;, which is an updated version of the OpenJDK javac
compiler. If you add directory
<TT>.../checker-framework/checkers/binary</TT> to your path, then whenever
you run <TT>javac</TT>, you will use the updated compiler. Or, you can
install the compiler (from <A HREF="http://types.cs.washington.edu/jsr308/"><TT>http://types.cs.washington.edu/jsr308/</TT></A>)
using its own
<A HREF="http://types.cs.washington.edu/checker-framework/current/README-jsr308.html#installing">installation
instructions</A>.</P><P>There are no negative consequences to using the Type Annotations
compiler, but if you choose not to do so, you have alternatives.
When this document tells you to run <TT>javac</TT>, you will instead need
to run one of the following commands. The command should be all on one
line, and followed by the javac arguments such as <TT>-processor</TT>.</P><PRE CLASS="verbatim">  # Unix
  /path/to/checker-framework/checkers/binary/javac

  # Unix
  java -Xbootclasspath/p:$JSR308/checker-framework/checkers/binary/jsr308-all.jar
       -jar $JSR308/checker-framework/checkers/binary/jsr308-all.jar -version

  # Windows
  java -Xbootclasspath/p:C:\Path\To\...\checker-framework\checkers\binary\jsr308-all.jar
       -jar C:\Path\To\...\checker-framework\checkers\binary\jsr308-all.jar -version
</PRE></LI></OL><P>To ensure that it was installed properly, run <TT>javac -version</TT> (using a
variant of <TT>javac</TT> if you did not add it to your path).</P><P>The output should be:</P><PRE CLASS="verbatim">  javac 1.7.0-jsr308-1.1.1
</PRE><P>That&#X2019;s all there is to it! Now you are ready to start using the checkers.</P><P>Section&#XA0;<A HREF="#example-use">1.3</A> walks you through a simple example. More detailed
instructions for using a checker appear in Chapter&#XA0;<A HREF="#using-a-checker">2</A>.</P><!--TOC section Example use: detecting a null pointer bug-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="example-use">1.3</A>&#XA0;&#XA0;Example use: detecting a null pointer bug</H2><!--SEC END --><P>To run a checker on a source file, just run javac as usual, passing the
<TT>-processor</TT> flag. (You can also use an IDE or other build tool; see
Chapter&#XA0;<A HREF="#external-tools">20</A>.)</P><P>For instance, if you usually run the compiler like
this:</P><PRE CLASS="verbatim">  javac Foo.java Bar.java
</PRE><P>then you will instead use the command line:</P><PRE>
  javac -processor <I>ProcessorName</I> Foo.java Bar.java
</PRE><P>but take note that the <TT>javac</TT> command must refer to the Type
Annotations compiler (see Section&#XA0;<A HREF="#installation">1.2</A>).</P><P>If you usually do your coding within an IDE, you will need to configure
the IDE. This manual contains instructions for
Ant (Section&#XA0;<A HREF="#ant-task">20.2</A>),
Maven (Section&#XA0;<A HREF="#maven-plugin">20.3</A>),
IntelliJ IDEA (Section&#XA0;<A HREF="#intellij">20.4</A>),
Eclipse (Section&#XA0;<A HREF="#eclipse">20.5</A>), and
tIDE (Section&#XA0;<A HREF="#tide">20.6</A>).
Otherwise, see your IDE documentation for details.</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
Let&#X2019;s consider this very simple Java class. One local variable is
annotated as <TT>NonNull</TT>, indicating that <TT>ref</TT> must be a reference to a
non-null object. Save the file as <TT>GetStarted.java</TT>.<PRE CLASS="verbatim">import checkers.nullness.quals.*;

public class GetStarted {
    void sample() {
        @NonNull Object ref = new Object();
    }
}
</PRE></LI><LI CLASS="li-enumerate">Run the nullness checker on the class.
Either run this command:
<PRE CLASS="verbatim">  javac -processor checkers.nullness.NullnessChecker GetStarted.java
</PRE><P>or compile from within your IDE, which you have customized to use the JSR
308 compiler and to pass the extra arguments.</P><P>The compilation should complete without any errors.</P></LI><LI CLASS="li-enumerate">Let&#X2019;s introduce an error now. Modify <TT>ref</TT>&#X2019;s assignment to:
<PRE CLASS="verbatim">  @NonNull Object ref = null;
</PRE></LI><LI CLASS="li-enumerate">Run the nullness checker again, just as before. This run should emit
the following error:
<PRE CLASS="verbatim">GetStarted.java:5: incompatible types.
found   : @Nullable &lt;nulltype&gt;
required: @NonNull Object
        @NonNull Object ref = null;
                              ^
1 error
</PRE><P>The type qualifiers (e.g. <TT>@NonNull</TT>) are permitted anywhere
that would write a type, including generics and casts; see
Section&#XA0;<A HREF="#writing-annotations">2.1</A>.</P><PRE>
  <U>@Interned</U> String intern() <TT>{</TT> ... <TT>}</TT>             // return value
  int compareTo(<U>@NonNull</U> String other) <TT>{</TT> ... <TT>}</TT>  // parameter
  <U>@NonNull</U> List&lt;<U>@Interned</U> String&gt; messages;     // non-null list of interned Strings
</PRE></LI></OL><HR><!--TOC chapter Using a checker-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="using-a-checker">Chapter&#XA0;2</A>&#XA0;&#XA0;Using a checker</H1><!--SEC END --><P>A pluggable type-checker enables you to detect certain bugs in your code,
or to prove that they are not present. The verification happens at compile
time.</P><P>Finding bugs, or verifying their absence, with a checker plugin is a two-step process, whose steps are
described in Sections&#XA0;<A HREF="#writing-annotations">2.1</A> and <A HREF="#running">2.2</A>.</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">The programmer writes annotations, such as <TT>@</TT><A HREF="doc/checkers/nullness/quals/NonNull.html"><TT>NonNull</TT></A> and
<TT>@</TT><A HREF="doc/checkers/interning/quals/Interned.html"><TT>Interned</TT></A>, that specify additional information about Java types.
(Or, the programmer uses an inference tool to automatically insert
annotations in his code: see Sections&#XA0;<A HREF="#nullness-inference">3.2.4</A> and&#XA0;<A HREF="#javari-inference">6.2.2</A>.)
It is possible to annotate only part of your code: see
Section&#XA0;<A HREF="#unannotated-code">17.1</A>.</LI><LI CLASS="li-enumerate">The checker reports whether the program contains any erroneous code
&#X2014; that is, code that is inconsistent with the annotations.</LI></OL><P>This section is structured as follows:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Section&#XA0;<A HREF="#writing-annotations">2.1</A>: How to write annotations
</LI><LI CLASS="li-itemize">Section&#XA0;<A HREF="#running">2.2</A>: How to run a checker
</LI><LI CLASS="li-itemize">Section&#XA0;<A HREF="#checker-guarantees">2.3</A>: What the checker guarantees
</LI><LI CLASS="li-itemize">Section&#XA0;<A HREF="#tips-about-writing-annotations">2.4</A>: Tips about writing annotations
</LI></UL><P>Additional topics that apply to all checkers are covered later in the manual:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Chapter&#XA0;<A HREF="#advanced-type-system-features">16</A>: Advanced type system features
</LI><LI CLASS="li-itemize">Chapter&#XA0;<A HREF="#warnings-and-legacy">17</A>: Handling warnings and legacy code
</LI><LI CLASS="li-itemize">Chapter&#XA0;<A HREF="#annotating-libraries">18</A>: Annotating libraries
</LI><LI CLASS="li-itemize">Chapter&#XA0;<A HREF="#writing-a-checker">19</A>: How to create a new checker
</LI><LI CLASS="li-itemize">Chapter&#XA0;<A HREF="#external-tools">20</A>: Integration with external tools
</LI></UL><!--TOC section Writing annotations-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="writing-annotations">2.1</A>&#XA0;&#XA0;Writing annotations</H2><!--SEC END --><P>The syntax of type qualifier annotations in Java 7 is specified by
<A HREF="http://types.cs.washington.edu/jsr308/">JSR 308</A>&#XA0;[<A HREF="#jsr308">Ern08</A>]. Ordinary
Java permits annotations on declarations. JSR 308 permits annotations
anywhere that you would write a type, including generics and casts. You
can also write annotations to indicate type qualifiers for array levels and
receivers. Here are a few examples:</P><PRE>
  <U>@Interned</U> String intern() <TT>{</TT> ... <TT>}</TT>             // return value
  int compareTo(<U>@NonNull</U> String other) <TT>{</TT> ... <TT>}</TT>  // parameter
  String toString() <U>@ReadOnly</U> <TT>{</TT> ... <TT>}</TT>           // receiver ("this" parameter)
  <U>@NonNull</U> List&lt;<U>@Interned</U> String&gt; messages;     // generics:  non-null list of interned Strings
  <U>@Interned</U> String <U>@NonNull</U> [] messages;        // arrays:  non-null array of interned Strings
  myDate = (<U>@ReadOnly</U> Date) readonlyObject;     // cast
</PRE><P>You can also write the annotations within comments, as in
<TT>List&lt;/*@NonNull*/ String&gt;</TT>. The Type Annotations compiler, which is
distributed with the Checker Framework, will still process
the annotations.
However, your code will remain compilable by people who are not using the
Type Annotations or Java 7 compiler. For more details, see
Section&#XA0;<A HREF="#annotations-in-comments">17.3</A>.</P><!--TOC subsection Distributing your annotated project-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->2.1.1&#XA0;&#XA0;Distributing your annotated project<A NAME="distributing"></A></H3><!--SEC END --><P>If your code contains annotations, then your code has a dependency on the
annotation declarations. People who want to compile or run your code may
need declarations of the annotations on their classpath.</P><UL CLASS="itemize"><LI CLASS="li-itemize">
To perform pluggable type-checking, all of the Checker Framework (which
also contains the annotation declarations) is needed.
</LI><LI CLASS="li-itemize">To compile the code:
<UL CLASS="itemize"><LI CLASS="li-itemize">
If you wrote annotations in comments (see
Section&#XA0;<A HREF="#annotations-in-comments">17.3</A>) and used implicit import
statements (see Section&#XA0;<A HREF="#implicit-import-statements">17.3.2</A>), then the code
can be compiled by any Java compiler, without needing declarations of the
annotations.
</LI><LI CLASS="li-itemize">Otherwise, compiling the code requires a declaration of the annotations.
These appear in the full Checker Framework. Additionally, the Checker
Framework distribution <TT>.zip</TT> file contains a small jar file,
<TT>checkers-quals.jar</TT>, that only contains the definitions of the
distributed qualifiers, without any support for type-checking.
</LI></UL>
</LI><LI CLASS="li-itemize">To run the code:
<UL CLASS="itemize"><LI CLASS="li-itemize">
If you compiled the code without using the annotation declarations, then
no annotation declarations are needed.
</LI><LI CLASS="li-itemize">If you compiled the code using the annotation declarations, then users
may need to have the annotation declarations on their classpath.
</LI></UL>
</LI></UL><P>A simple rule of thumb is as follows. When distributing your source code,
you may wish to include either the Checker Framework jar file or the
<TT>checkers-quals.jar</TT> file. When distributing compiled binaries, you
may wish to compile them without using the annotations, or include the
contents of <TT>checkers-quals.jar</TT> in your distribution.</P><!--TOC section Running a checker-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="running">2.2</A>&#XA0;&#XA0;Running a checker</H2><!--SEC END --><P>To run a checker plugin, run the compiler <TT>javac</TT> as usual,
but pass the <TT>-processor </TT><TT><EM>plugin_class</EM></TT> command-line
option.
(You can run a checker from within your favorite IDE or build system. See
Chapter&#XA0;<A HREF="#external-tools">20</A> for details about
Ant (Section&#XA0;<A HREF="#ant-task">20.2</A>),
Maven (Section&#XA0;<A HREF="#maven-plugin">20.3</A>),
IntelliJ IDEA (Section&#XA0;<A HREF="#intellij">20.4</A>),
Eclipse (Section&#XA0;<A HREF="#eclipse">20.5</A>),
and
tIDE (Section&#XA0;<A HREF="#tide">20.6</A>), and about customizing other IDEs and build tools.)
Remember that you must be using the
Type Annotations version of <TT>javac</TT>, which you already installed (see Section&#XA0;<A HREF="#installation">1.2</A>).</P><P>Two concrete examples (using the Nullness checker) are:</P><PRE CLASS="verbatim">  javac -processor checkers.nullness.NullnessChecker MyFile.java
  javac -processor checkers.nullness.NullnessChecker -Xbootclasspath/p:checkers/jdk/jdk.jar MyFile.java
</PRE><P>For a discussion of the <TT>-Xbootclasspath/p</TT> argument, see
Section&#XA0;<A HREF="#skeleton-using">18.2</A>.</P><P>The checker is run only on any Java file that javac compiles.
This includes all Java files specified on the command line (or
created by another annotation processor). It may also include other of
your Java files (but not if a more recent <TT>.class</TT> file exists).
Even when the checker does not analyze a class (say, the class was
already compiled, or source code is not available), it does check
the <EM>uses</EM> of those classes in the source code being compiled.</P><P>The javac compiler halts compilation as soon as an error is found in a
source file. You can pass <TT>-Awarns</TT> in the command-line to
treat checker errors as warnings. This option allows you to see all
the type-checking errors at once, rather than just the errors in the first
file that contains errors. You may wish to also supply
<TT>-Xmaxwarns 10000</TT>, because by default <TT>javac</TT> prints at most 100
warnings.</P><P>You can always compile the code without the <TT>-processor</TT>
command-line option, but in that case no checking of the type
annotations is performed. The annotations are still written to the
resulting <TT>.class</TT> files, however.</P><!--TOC subsection Summary of command-line options-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->2.2.1&#XA0;&#XA0;Summary of command-line options<A NAME="checker-options"></A></H3><!--SEC END --><P>You can pass command-line arguments to a checker via javac&#X2019;s standard <TT>-A</TT>
option (&#X201C;<TT>A</TT>&#X201D; stands for &#X201C;annotation&#X201D;). All of the distributed
checkers support the following command-line options:</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<TT>-Awarns</TT> Treat checker errors as warnings; see Section&#XA0;<A HREF="#running">2.2</A>
</LI><LI CLASS="li-itemize"><TT>-AskipClasses</TT> Suppress all errors and warnings at all uses of a
given class; see Section&#XA0;<A HREF="#suppressing-warnings">17.2</A>
</LI><LI CLASS="li-itemize"><TT>-Alint</TT> Enable or disable optional checks; see Section&#XA0;<A HREF="#lint-options">17.2</A>
</LI><LI CLASS="li-itemize"><TT>-Astubs</TT> List of stub files or directories; see Section&#XA0;<A HREF="#stub-using">18.1.2</A>
</LI><LI CLASS="li-itemize"><TT>-Afilenames</TT>, <TT>-Anomsgtext</TT>, <TT>-Ashowchecks</TT> Aids for testing or debugging a checker; see Section&#XA0;<A HREF="#debugging-options">19.8</A>
</LI></UL><P>Some checkers support additional options, such as <TT>-Aquals</TT> for the Basic
Checker to check; see Chapter&#XA0;<A HREF="#basic-checker">13</A>.</P><P>Here are some standard javac command-line options that you may find useful.
Many of them contain the word &#X201C;processor&#X201D;, because in javac jargon, a
checker is a type of &#X201C;annotation processor&#X201D;.</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<TT>-processor</TT> Names the checker to be
run; see Section&#XA0;<A HREF="#running">2.2</A>
</LI><LI CLASS="li-itemize"><TT>-processorpath</TT> Indicates where to search for the
checker; should also contain any qualifiers used by the Basic
Checker; see Section&#XA0;<A HREF="#basic-example">13.2</A>
</LI><LI CLASS="li-itemize"><TT>-proc:</TT>{<TT>none</TT>,<TT>only</TT>} Controls whether checking
happens; <TT>-proc:none</TT>
means to skip checking; <TT>-proc:only</TT> means to do only
checking, without any subsequent compilation; see
Section&#XA0;<A HREF="#checker-auto-discovery">2.2.2</A>
</LI><LI CLASS="li-itemize"><TT>-Xbootclasspath/p:</TT> Indicates where to find the annotated JDK classes;
see Section&#XA0;<A HREF="#skeleton-using">18.2</A>
</LI><LI CLASS="li-itemize"><TT>-implicit:class</TT> Suppresses warnings about implicitly compiled files
(not named on the command line); see Section&#XA0;<A HREF="#ant-task">20.2</A>
</LI><LI CLASS="li-itemize"><TT>-XDTA:spacesincomments</TT> parse annotation comments even when they
contain spaces; applicable only to the Type Annotations compiler; see Section&#XA0;<A HREF="#annotations-in-comments">17.3</A>
</LI><LI CLASS="li-itemize"><TT>-J</TT> Supply an argument to the JVM that is running javac; example:
<TT>-J-Djsr308_imports=checkers.nullness.quals.*</TT>; see Section&#XA0;<A HREF="#implicit-import-statements">17.3.2</A>
</LI></UL><!--TOC subsection Checker auto-discovery-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->2.2.2&#XA0;&#XA0;Checker auto-discovery<A NAME="checker-auto-discovery"></A></H3><!--SEC END --><P>&#X201C;Auto-discovery&#X201D; makes the <TT>javac</TT> compiler always run a checker
plugin, even if you do not explicitly pass the <TT>-processor</TT>
command-line option. This can make your command line shorter, and ensures
that your code is checked even if you forget the command-line option.</P><P>To enable auto-discovery, place a configuration file named
<TT>META-INF/services/javax.annotation.processing.Processor</TT>
in your classpath. The file contains the names of the checker plugins to
be used, listed one per line. For instance, to run the Nullness and the
Interning checkers automatically, the configuration file should contain:</P><PRE CLASS="verbatim">  checkers.nullness.NullnessChecker
  checkers.interning.InterningChecker
</PRE><P>You can disable this auto-discovery mechanism by passing the
<TT>-proc:none</TT> command-line option to <TT>javac</TT>, which disables all
annotation processing including all pluggable type-checking.</P><!--TOC section What the checker guarantees-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="checker-guarantees">2.3</A>&#XA0;&#XA0;What the checker guarantees</H2><!--SEC END --><P>A checker can guarantee that a particular property holds throughout the
code. For example, the Nullness checker (Chapter&#XA0;<A HREF="#nullness-checker">3</A>)
guarantees that every expression whose type is a <TT>@</TT><A HREF="doc/checkers/nullness/quals/NonNull.html"><TT>NonNull</TT></A> type never
evaluates to null. The Interning checker (Chapter&#XA0;<A HREF="#interning-checker">4</A>)
guarantees that every expression whose type is an <TT>@</TT><A HREF="doc/checkers/interning/quals/Interned.html"><TT>Interned</TT></A> type
evaluates to an interned value. The checker makes its guarantee by
examining every part of your program and verifying that no part of the
program violates the guarantee.</P><P>There are some limitations to the guarantee.</P><UL CLASS="itemize"><LI CLASS="li-itemize">A compiler plugin can check only those parts of your program that you run
it on. If you compile some parts of your program without running the
checker, then there is no guarantee that the entire program satisfies the
property being checked. Some examples of un-checked code are:<UL CLASS="itemize"><LI CLASS="li-itemize">
Code compiled without the <TT>-processor</TT> switch, including any
external library supplied as a <TT>.class</TT> file.
</LI><LI CLASS="li-itemize">Code compiled with the <TT>-AskipClasses</TT> property.
</LI><LI CLASS="li-itemize">Suppression of warnings, such as via the <TT>@SuppressWarnings</TT> annotation.
</LI><LI CLASS="li-itemize">Native methods (because the implementation is not Java code, it cannot
be checked).
</LI></UL><P>In each of these cases, any <EM>use</EM> of the code is checked &#X2014; for
example, a call to a native method must be compatible with any
annotations on the native method&#X2019;s signature.
However, the annotations on the un-checked code are trusted; there is no
verification that the implementation of the native method satisfies the
annotations.</P></LI><LI CLASS="li-itemize">Reflection can violate the Java type system, and
the checkers are not sophisticated enough to reason about the possible
effects of reflection. Similarly, deserialization and cloning can
create objects that could not result from normal constructor calls, and
that therefore may violate the property being checked.</LI><LI CLASS="li-itemize">Your code should pass the Java compiler without errors or warnings. In
particular, your code should use generic types, with no uses of raw types.
Misuse of generics, including casting away generic types, can cause other
errors to be missed.</LI><LI CLASS="li-itemize">
The Checker Framework does not yet support annotations on intersection
types (see
<A HREF="http://java.sun.com/docs/books/jls/third_edition/html/typesValues.html#4.9">JLS &#XA7;4.9</A>). As a result, checkers cannot provide guarantees about
intersection types.</LI><LI CLASS="li-itemize">Specific checkers may have other limitations; see their documentation for
details.</LI></UL><P>A checker can be useful in finding bugs or in verifying part of a
program, even if the checker is unable to verify the correctness of an
entire program.</P><P>In order to avoid a flood of unhelpful warnings, many of the checkers avoid
issuing the same warning multiple times. For example, in this code:</P><PRE CLASS="verbatim">  @Nullable Object x = ...;
  x.toString();                 // warning
  x.toString();                 // no warning
</PRE><P>In this case, the second call to <TT>toString</TT> cannot possibly throw a null
pointer warning &#X2014; <TT>x</TT> is non-null if control flows to the second
statement.
In other cases, a checker avoids issuing later warnings with the same cause
even when later code in a method might also fail.
This does not
affect the soundness guarantee, but a user may need to examine more
warnings after fixing the first ones identified. (More often, at least in
our experience to date, a single fix corrects all the warnings.)</P><P>If you find that a checker fails to issue a warning that it
should, then please report a bug (see Section&#XA0;<A HREF="#reporting-bugs">22.2</A>).</P><!--TOC section Tips about writing annotations-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="tips-about-writing-annotations">2.4</A>&#XA0;&#XA0;Tips about writing annotations</H2><!--SEC END --><!--TOC subsection How to get started annotating legacy code-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->2.4.1&#XA0;&#XA0;How to get started annotating legacy code<A NAME="get-started-with-legacy-code"></A></H3><!--SEC END --><P>Annotating an entire existing program may seem like a daunting task. But,
if you approach it systematically and do a little bit at a time, you will
find that it is manageable.</P><P>You should start with a property that matters to you, to achieve the best
benefits. It is easiest to add annotations if you know the code or the
code contains documentation; you will find that you spend most of your time
understanding the code, and very little time actually writing annotations
or running the checker.</P><P>It is best to annotate one package at a time,
and to annotate the entire package so that you don&#X2019;t forget any classes,
which can lead to unexpected results.
Start as close to the leaves of the call tree as possible, because it is
easiest to annotate a class if the code it calls has already been
annotated.</P><P>For each class, read its Javadoc. For instance, if you are adding
annotations for the Nullness Checker (Section&#XA0;<A HREF="#nullness-checker">3</A>), then
you can search the documentation for &#X201C;null&#X201D; and then add <TT>@Nullable</TT>
anywhere appropriate. Do not annotate the method bodies yet &#X2014;
first, get the signatures and fields annotated. The only reason to even
<EM>read</EM> the method bodies yet is to determine signature annotations for
undocumented methods &#X2014;
for example, if the method returns null, you know its return type should be
annotated <TT>@Nullable</TT>, and a parameter that is compared against <TT>null</TT>
may need to be annotated <TT>@Nullable</TT>. If you are only annotating
signatures (say, for a library you do not maintain and do not wish to
check), you are now done.</P><P>If you wish to check the implementation, then after the signatures are
annotated, run the checker. Then, add method body annotations (usually,
few are necessary), fix bugs in code, and add annotations to signatures
where necessary. If signature annotations are necessary, then you may want
to fix the documentation that did not indicate the property; but this isn&#X2019;t
strictly necessary, since the annotations that you wrote provide that
documentation.</P><P>You may wonder about the effect of adding a given annotation &#X2014; how many
other annotations it will require, or whether it conflicts with other code.
Suppose you have added an annotation to a method parameter. You could
manually examine all callees. A better way can be to save the checker
output before adding the annotation, and to compare it to the checker
output after adding the annotation. This helps you to focus on the
specific consequences of your change.</P><P>Also see Chapter&#XA0;<A HREF="#warnings-and-legacy">17</A>, which tells you what to do when
you are unable to eliminate checker warnings.</P><!--TOC subsection Do not annotate local variables unless necessary-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->2.4.2&#XA0;&#XA0;Do not annotate local variables unless necessary<A NAME="tips-local-inference"></A></H3><!--SEC END --><P>The checker infers annotations for local variables (see
Section&#XA0;<A HREF="#type-refinement">16.3.2</A>). Usually, you only need to annotate fields
and method signatures. After doing those, you can add annotations inside
method bodies if the checker is unable to infer the correct annotation, if
you need to suppress a warning (see Section&#XA0;<A HREF="#suppressing-warnings">17.2</A>),
etc.</P><!--TOC subsection Annotations indicate normal behavior-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->2.4.3&#XA0;&#XA0;Annotations indicate normal behavior<A NAME="annotate-normal-behavior"></A></H3><!--SEC END --><P>You should use annotations to indicate <EM>normal</EM> behavior. The
annotations indicate all the values that you <EM>want</EM> to flow to
reference &#X2014; not every value that might possibly flow there if your
program has a bug.</P><P>Many methods are guaranteed to throw an exception if they are passed <TT>null</TT>
as an argument. Examples include</P><PRE CLASS="verbatim">  java.lang.Double.valueOf(String)
  java.lang.String.contains(CharSequence)
  org.junit.Assert.assertNotNull(Object)
  com.google.common.base.Preconditions.checkNotNull(Object)
</PRE><P><TT>@</TT><A HREF="doc/checkers/nullness/quals/Nullable.html"><TT>Nullable</TT></A> (see Section&#XA0;<A HREF="#nullness-annotations">3.1</A>)
might seem like a reasonable annotation for the parameter,
for two reasons. First, <TT>null</TT> is a legal argument with a
well-defined semantics: throw an exception. Second, <TT>@Nullable</TT>
describes a possible program execution: it might be possible for
<TT>null</TT> to flow there, if your program has a bug.</P><P>However, it is never useful for a programmer to pass <TT>null</TT>. It is
the programmer&#X2019;s intention that <TT>null</TT> never flows there. If
<TT>null</TT> does flow there, the program will not continue normally.</P><P>Therefore, you should mark such parameters as
<TT>@</TT><A HREF="doc/checkers/nullness/quals/NonNull.html"><TT>NonNull</TT></A>, indicating
the intended use of the method. When you use the <TT>@NonNull</TT>
annotation, the checker is able to issue compile-time warnings about
possible run-time exceptions, which is its purpose. Marking the parameter
as <TT>@Nullable</TT> would suppress such warnings, which is undesirable.</P><!--TOC subsection Subclasses must respect superclass annotations-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->2.4.4&#XA0;&#XA0;Subclasses must respect superclass annotations<A NAME="annotations-are-a-contract"></A></H3><!--SEC END --><P>An annotation indicates a guarantee that a client can depend upon. A subclass
is not permitted to <EM>weaken</EM> the contract; for example,
if a method accepts <TT>null</TT> as an argument, then every overriding
definition must also accept <TT>null</TT>.
A subclass is permitted to <EM>strengthen</EM> the contract; for example,
if a method does <EM>not</EM> accept <TT>null</TT> as an argument, then an
overriding definition is permitted to accept <TT>null</TT>.</P><P>As a bad example, consider an erroneous <TT>@Nullable</TT> annotation at
line 141 of <A HREF="http://code.google.com/p/google-collections/source/browse/trunk/src/com/google/common/collect/Multiset.java"><TT>com/google/common/collect/Multiset.java</TT></A>, version r78:</P><PRE CLASS="verbatim">101  public interface Multiset&lt;E&gt; extends Collection&lt;E&gt; {
...
122    /**
123     * Adds a number of occurrences of an element to this multiset.
...
129     * @param element the element to add occurrences of; may be {@code null} only
130     *     if explicitly allowed by the implementation
...
137     * @throws NullPointerException if {@code element} is null and this
138     *     implementation does not permit null elements. Note that if {@code
139     *     occurrences} is zero, the implementation may opt to return normally.
140     */
141    int add(@Nullable E element, int occurrences);
</PRE><P>There exist implementations of Multiset that permit <TT>null</TT> elements,
and implementations of Multiset that do not permit <TT>null</TT> elements. A
client with a variable <TT>Multiset ms</TT> does not know which variety of
Multiset <TT>ms</TT> refers to. However, the <TT>@Nullable</TT> annotation
promises that <TT>ms.add(null, 1)</TT> is permissible. (Recall from
Section&#XA0;<A HREF="#annotate-normal-behavior">2.4.3</A> that annotations should indicate
normal behavior.)</P><P>If parameter <TT>element</TT> on line 141 were to be annotated, the correct
annotation would be <TT>@NonNull</TT>. Suppose a client has a reference to
same Multiset <TT>ms</TT>. The only way the client can be sure not to throw an exception is to pass
only non-<TT>null</TT> elements to <TT>ms.add()</TT>. A particular class
that implements Multiset could declare <TT>add</TT> to take a
<TT>@Nullable</TT> parameter. That still satisfies the original contract.
It strengthens the contract by promising even more: a client with such a
reference can pass any non-<TT>null</TT> value to <TT>add()</TT>, and may also
pass <TT>null</TT>.</P><P><B>However</B>, the best annotation for line 141 is no annotation at all.
The reason is that each implementation of the Multiset interface should
specify its own nullness properties when it specifies the type parameter
for Multiset. For example, two clients could be written as</P><PRE CLASS="verbatim">  class MyNullPermittingMultiset implements Multiset&lt;@Nullable Object&gt; { ... }
  class MyNullProhibitingMultiset implements Multiset&lt;@NonNull Object&gt; { ... }
</PRE><P>or, more generally, as</P><PRE CLASS="verbatim">  class MyNullPermittingMultiset&lt;E extends @Nullable Object&gt; implements Multiset&lt;E&gt; { ... }
  class MyNullProhibitingMultiset&lt;E extends @NonNull Object&gt; implements Multiset&lt;E&gt; { ... }
</PRE><P>Then, the specification is more informative, and the Checker Framework is
able to do more precise checking, than if line 141 has an annotation.</P><P>It is a pleasant feature of the Checker Framework that in many cases, no
annotations at all are needed on type parameters such as <TT>E</TT> in <TT>MultiSet</TT>.</P><!--TOC subsection Annotations on constructor invocations-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->2.4.5&#XA0;&#XA0;Annotations on constructor invocations<A NAME="annotations-on-constructor-invocations"></A></H3><!--SEC END --><P>In the checkers distributed with the Checker Framework, an annotation on a
constructor invocation is equivalent to a cast on a constructor result.
That is, the following two expressions have identical semantics: one is
just shorthand for the other.</P><PRE CLASS="verbatim">  new @ReadOnly Date()
  (@ReadOnly Date) new Date()
</PRE><P>However, you should rarely have to use this. The Checker Framework will
determine the qualifier on the result, based on the &#X201C;return value&#X201D;
annotation on the constructor definition. The &#X201C;return value&#X201D; annotation
appears before the constructor name, for example:</P><PRE CLASS="verbatim">  class MyClass {
    @ReadOnly MyClass() { ... }
  }
</PRE><P>In general, you should only use an annotation on a constructor invocation
when you know that the cast is
guaranteed to succeed. An example from the IGJ checker
(Chapter&#XA0;<A HREF="#igj-checker">5</A>) is <TT>new @Immutable MyClass()</TT> or <TT>new
@Mutable MyClass()</TT>, where you know that every other reference to the class
is annotated <TT>@ReadOnly</TT>.</P><!--TOC subsection When to use (and not use) type qualifiers-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->2.4.6&#XA0;&#XA0;When to use (and not use) type qualifiers<A NAME="when-to-use-type-qualifiers"></A></H3><!--SEC END --><P>For some programming tasks, you can use either a Java subclass or a type
qualifier. For instance, suppose that your code currently uses
<TT>String</TT> to represent an address. You could create a new <TT>Address</TT>
class and refactor your code to use it, or you could create a
<TT>@Address</TT> annotation and apply it to some uses of <TT>String</TT> in
your code. If both of these are truly possible, then it is probably more
foolproof to use the Java class. We do not encourage you to use type
qualifiers as a poor substitute for classes. However, sometimes type
qualifiers are a better choice.</P><P>Using a new class may make your code incompatible with existing libraries or
clients. Brian Goetz expands on this issues in an article on the
pseudo-typedef antipattern&#XA0;[<A HREF="#Goetz2006:typedef">Goe06</A>]. Even if compatibility
is not a concern, a code change may introduce bugs, whereas adding
annotations does not change the run-time behavior. It is possible to add
annotations to existing code, including code you do not maintain or cannot
change. It is possible to annotate primitive types without converting them
to wrappers, which would make the code both uglier and slower.</P><P>Type qualifiers can be applied to any type, including final classes that
cannot be subclassed.</P><P>Type qualifiers permit you to remove operations, with a compile-time
guarantee. An example is mutating methods that are forbidden by immutable
types (see Chapters&#XA0;<A HREF="#igj-checker">5</A> and&#XA0;<A HREF="#javari-checker">6</A>). More
generally, type qualifiers permit creating a new supertype, not just a
subtype, of an existing Java type.</P><P>A final reason is efficiency. Type qualifiers can be more
efficient, since there is no run-time representation such as a wrapper
or a separate class, nor introduction of dynamic dispatch for methods that
could otherwise be statically dispatched.</P><HR><!--TOC chapter Nullness checker-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="nullness-checker">Chapter&#XA0;3</A>&#XA0;&#XA0;Nullness checker</H1><!--SEC END --><P>If the Nullness checker issues no warnings for a given program, then
running that program will never throw a null pointer exception. This
guarantee enables a programmer to prevent errors from occurring when a
program is run. See Section&#XA0;<A HREF="#nullness-checks">3.3</A> for more details about
the guarantee and what is checked.</P><P>To run the Nullness Checker, supply the <TT>-processor
checkers.nullness.NullnessChecker</TT> command-line option to javac. For
examples, see Section&#XA0;<A HREF="#nullness-example">3.7</A>.</P><!--TOC section Nullness annotations-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="nullness-annotations">3.1</A>&#XA0;&#XA0;Nullness annotations</H2><!--SEC END --><P>The Nullness checker uses three separate type hierarchies: one for nullness,
one for rawness (Section&#XA0;<A HREF="#raw-partially-initialized">3.5</A>),
and one for map keys (Section&#XA0;<A HREF="#map-keys">3.6</A>)
The Nullness checker has three varieties of annotations: nullness
qualifiers, nullness method annotations, rawness qualifiers, and map key
qualifiers.</P><!--TOC subsection Nullness qualifiers-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->3.1.1&#XA0;&#XA0;Nullness qualifiers<A NAME="nullness-qualifiers"></A></H3><!--SEC END --><P>The nullness hierarchy contains these qualifiers:</P><DL CLASS="description"><DT CLASS="dt-description"><B><TT>@</TT></B><A HREF="doc/checkers/nullness/quals/Nullable.html"><B><TT>Nullable</TT></B></A></DT><DD CLASS="dd-description">
indicates a type that includes the null value. For example, the type <TT>Boolean</TT>
is nullable: a variable of type <TT>Boolean</TT> always has one of the
values <TT>TRUE</TT>, <TT>FALSE</TT>, or <TT>null</TT>.</DD><DT CLASS="dt-description"><B><TT>@</TT></B><A HREF="doc/checkers/nullness/quals/NonNull.html"><B><TT>NonNull</TT></B></A></DT><DD CLASS="dd-description">
indicates a type that does not include the null value. The type
<TT>boolean</TT> is non-null; a variable of type <TT>boolean</TT> always has
one of the values <TT>true</TT> or <TT>false</TT>. The type <TT>@NonNull
Boolean</TT> is also non-null: a variable of type <TT>@NonNull Boolean</TT>
always has one of the values <TT>TRUE</TT> or <TT>FALSE</TT> &#X2014; never
<TT>null</TT>. Dereferencing an expression of non-null type can never cause
a null pointer exception.<P>The <TT>@NonNull</TT> annotation is rarely written in a program, because it is
the default (see Section&#XA0;<A HREF="#null-defaults">3.2.2</A>).</P></DD><DT CLASS="dt-description"><B><TT>@</TT></B><A HREF="doc/checkers/nullness/quals/PolyNull.html"><B><TT>PolyNull</TT></B></A></DT><DD CLASS="dd-description">
indicates qualifier polymorphism. For a description of
<TT>@</TT><A HREF="doc/checkers/nullness/quals/PolyNull.html"><TT>PolyNull</TT></A>, see
Section&#XA0;<A HREF="#qualifier-polymorphism">16.1.2</A>.</DD><DT CLASS="dt-description"><B><TT>@</TT></B><A HREF="doc/checkers/nullness/quals/LazyNonNull.html"><B><TT>LazyNonNull</TT></B></A></DT><DD CLASS="dd-description">
indicates a reference that may be <TT>null</TT>, but if it ever becomes
non-<TT>null</TT>, then it never becomes <TT>null</TT> again. This is
appropriate for lazily-initialized fields, among other uses. When the
variable is read, its type is treated as
<TT>@</TT><A HREF="doc/checkers/nullness/quals/Nullable.html"><TT>Nullable</TT></A>, but when the variable is
assigned, its type is treated as
<TT>@</TT><A HREF="doc/checkers/nullness/quals/NonNull.html"><TT>NonNull</TT></A>.<P>Because the Nullness checker works intraprocedurally (it analyzes one
method at a time), when a <TT>LazyNonNull</TT> field is first read within a
method, the field cannot be assumed to be non-null. The benefit of
LazyNonNull over Nullable is its different interaction with
flow-sensitive type qualifier refinement (Section&#XA0;<A HREF="#type-refinement">16.3.2</A>).
After a check of a LazyNonNull
field, all subsequent accesses <EM>within that method</EM> can be assumed
to be NonNull, even after arbitrary external method calls that have
access to the given field.</P></DD></DL><P>Figure&#XA0;<A HREF="#fig:nonnull-hierarchy">3.1</A> shows part of the type hierarchy for the
Nullness type system.
(The annotations exist only at compile time; at run time, Java has no
multiple inheritance.)</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>

<DIV CLASS="center">
<IMG SRC="nullness-and-raw.png" ALT="nullness-and-raw.png"></DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 3.1: Partial type hierarchy for the Nullness type system.
Java&#X2019;s <TT>Object</TT> is expressed as <TT>@Nullable Object</TT>. Programmers can omit
most type qualifiers, because the default annotation
(Section&#XA0;<A HREF="#null-defaults">3.2.2</A>) is usually correct. Also shown is the
type hierarchy for rawness (Section&#XA0;<A HREF="#raw-partially-initialized">3.5</A>), which
indicates whether
initialization has completed. The two type hierarchies are independent but
inter-related, and the Nullness Checker verifies them both.</TD></TR>
</TABLE></DIV>
<A NAME="fig:nonnull-hierarchy"></A>
<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><!--TOC subsection Nullness method annotations-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->3.1.2&#XA0;&#XA0;Nullness method annotations<A NAME="nullness-non-qualifiers"></A></H3><!--SEC END --><P>The Nullness checker supports several annotations that specify method
behavior.</P><DL CLASS="description"><DT CLASS="dt-description"><B><TT>@</TT></B><A HREF="doc/checkers/nullness/quals/NonNullOnEntry.html"><B><TT>NonNullOnEntry</TT></B></A></DT><DD CLASS="dd-description">
indicates a method precondition: The annotated method expects the
specified variables (typically field references) to be non-null when the
method is invoked.</DD><DT CLASS="dt-description"><B><TT>@</TT></B><A HREF="doc/checkers/nullness/quals/AssertNonNullAfter.html"><B><TT>AssertNonNullAfter</TT></B></A></DT><DD CLASS="dd-description">
</DD><DT CLASS="dt-description"><B><TT>@</TT></B><A HREF="doc/checkers/nullness/quals/AssertNonNullIfTrue.html"><B><TT>AssertNonNullIfTrue</TT></B></A></DT><DD CLASS="dd-description">
</DD><DT CLASS="dt-description"><B><TT>@</TT></B><A HREF="doc/checkers/nullness/quals/AssertNonNullIfFalse.html"><B><TT>AssertNonNullIfFalse</TT></B></A></DT><DD CLASS="dd-description">
indicates a method postcondition. With <TT>@AssertNonNullAfter</TT>, the given
expressions are non-null after the method returns; this is useful for a
method that initializes a field, for example. With
<TT>@AssertNonNullIfTrue</TT> and <TT>@AssertNonNullIfFalse</TT>, if the annotated
method returns the given boolean value (true or false), then the given
expressions are non-null. See Section&#XA0;<A HREF="#conditional-nullness">3.2.3</A> and the
Javadoc for examples of their use.</DD><DT CLASS="dt-description"><B><TT>@</TT></B><A HREF="doc/checkers/nullness/quals/Pure.html"><B><TT>Pure</TT></B></A></DT><DD CLASS="dd-description">
indicates that the method has no (visible) side effects. Furthermore,
if the method is called multiple times with the same
arguments, then it returns the same result. This property cannot be
assumed in general. For example, suppose that the return value of method
<TT>m</TT> is nullable. Then this code will pass the type-checker:<PRE CLASS="verbatim">        if (m(arg) != null) {
          m(arg).toString();
        }
</PRE><P>only if method <TT>m</TT> is annotated as <TT>@Pure</TT>.</P></DD><DT CLASS="dt-description"><B><TT>@</TT></B><A HREF="doc/checkers/nullness/quals/AssertParametersNonNull.html"><B><TT>AssertParametersNonNull</TT></B></A></DT><DD CLASS="dd-description">
is used for suppressing warnings, in very rare cases. See the Javadoc for
details.</DD></DL><!--TOC subsection Rawness qualifiers-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->3.1.3&#XA0;&#XA0;Rawness qualifiers<A NAME="rawness-qualifiers"></A></H3><!--SEC END --><P>The Nullness Checker supports rawness annotations that indicate whether
an object is fully initialized &#X2014; that is, whether its fields have all
been assigned.</P><DL CLASS="description"><DT CLASS="dt-description">
<B><TT>@</TT></B><A HREF="doc/checkers/nullness/quals/Raw.html"><B><TT>Raw</TT></B></A></DT><DD CLASS="dd-description">
</DD><DT CLASS="dt-description"><B><TT>@</TT></B><A HREF="doc/checkers/nullness/quals/NonRaw.html"><B><TT>NonRaw</TT></B></A></DT><DD CLASS="dd-description">
</DD><DT CLASS="dt-description"><B><TT>@</TT></B><A HREF="doc/checkers/nullness/quals/PolyRaw.html"><B><TT>PolyRaw</TT></B></A></DT><DD CLASS="dd-description">
</DD></DL><P>Use of these annotations can help you to type-check more
code. Figure&#XA0;<A HREF="#fig:nonnull-hierarchy">3.1</A> shows its type hierarchy. For
details, see Section&#XA0;<A HREF="#raw-partially-initialized">3.5</A>.</P><!--TOC subsection Map key qualifiers-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->3.1.4&#XA0;&#XA0;Map key qualifiers<A NAME="map-key-qualifiers"></A></H3><!--SEC END --><P>The Nullness Checker supports a map key annotation, <TT>@</TT><A HREF="doc/checkers/nullness/quals/KeyFor.html"><TT>KeyFor</TT></A> that indicates whether
a value is a key for a given map &#X2014; that is, whether
<TT>map.containsKey(value)</TT> would evaluate to <TT>true</TT>.</P><DL CLASS="description"><DT CLASS="dt-description">
<B><TT>@</TT></B><A HREF="doc/checkers/nullness/quals/KeyFor.html"><B><TT>KeyFor</TT></B></A></DT><DD CLASS="dd-description">
</DD></DL><P>Use of this annotation can help you to type-check more code. For details,
see Section&#XA0;<A HREF="#map-keys">3.6</A>.</P><!--TOC section Writing nullness annotations-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="writing-nullness-annotations">3.2</A>&#XA0;&#XA0;Writing nullness annotations</H2><!--SEC END --><!--TOC subsection Implicit qualifiers-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->3.2.1&#XA0;&#XA0;Implicit qualifiers<A NAME="nullness-implicit-qualifiers"></A></H3><!--SEC END --><P>As described in Section&#XA0;<A HREF="#effective-qualifier">16.3</A>, the Nullness checker
adds implicit qualifiers, reducing the number of annotations that must
appear in your code.
For example, enum types are implicitly non-null, so you never need to write
<TT>@NonNull MyEnumType</TT>.</P><P>For a complete description of all implicit nullness qualifiers, see the
Javadoc for <A HREF="doc/checkers/nullness/NullnessAnnotatedTypeFactory.html"><TT>NullnessAnnotatedTypeFactory</TT></A>.</P><!--TOC subsection Default annotation-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->3.2.2&#XA0;&#XA0;Default annotation<A NAME="null-defaults"></A></H3><!--SEC END --><P>Unannotated references are treated as if they had a default annotation,
using the NNEL (non-null except locals) rule described below.
A user may choose a different rule for defaults using the
<TT>@</TT><A HREF="doc/checkers/quals/DefaultQualifier.html"><TT>DefaultQualifier</TT></A> annotation; see
Section&#XA0;<A HREF="#defaults">16.3.1</A>.</P><P>Here are three possible default rules you may wish to use. Other rules are
possible but are not as useful.
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<TT>@</TT><A HREF="doc/checkers/nullness/quals/Nullable.html"><TT>Nullable</TT></A>: Unannotated types are regarded as possibly-null, or
nullable. This default is backward-compatible with Java, which permits
any reference to be null. You can activate this default by writing
a <TT>@DefaultQualifier("Nullable")</TT> annotation on a
class or method
declaration.
</LI><LI CLASS="li-itemize"><TT>@</TT><A HREF="doc/checkers/nullness/quals/NonNull.html"><TT>NonNull</TT></A>: Unannotated types are treated as non-null.
You can activate this
default via the
<TT>@DefaultQualifier("NonNull")</TT> annotation.
</LI><LI CLASS="li-itemize">Non-null except locals (NNEL): Unannotated types are treated as
<TT>@</TT><A HREF="doc/checkers/nullness/quals/NonNull.html"><TT>NonNull</TT></A>, <EM>except</EM> that the
unannotated raw type of a local variable is treated as
<TT>@</TT><A HREF="doc/checkers/nullness/quals/Nullable.html"><TT>Nullable</TT></A>. (Any generic arguments to a
local variable still default to
<TT>@</TT><A HREF="doc/checkers/nullness/quals/NonNull.html"><TT>NonNull</TT></A>.) This is the standard
behavior. You can explicitly activate this default via the
<TT>@DefaultQualifier(value="NonNull",
locations={DefaultLocation.ALL_EXCEPT_LOCALS})</TT>
annotation.<P>The NNEL default leads to the smallest number of explicit annotations in
your code&#XA0;[<A HREF="#PapiACPE2008">PAC<SUP>+</SUP>08</A>]. It is what we recommend. If you do not
explicitly specify a different default, then NNEL is the default.
</P></LI></UL><!--TOC subsection Conditional nullness-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->3.2.3&#XA0;&#XA0;Conditional nullness<A NAME="conditional-nullness"></A></H3><!--SEC END --><P>The Nullness Checker supports a form of conditional nullness types, via the
<TT>@</TT><A HREF="doc/checkers/nullness/quals/AssertNonNullIfTrue.html"><TT>AssertNonNullIfTrue</TT></A> and <TT>@</TT><A HREF="doc/checkers/nullness/quals/AssertNonNullIfFalse.html"><TT>AssertNonNullIfFalse</TT></A> method annotations.
The annotation on a method declares that some expressions are non-null, if
the method returns true (false, respectively).</P><P>Consider <A HREF="http://download.oracle.com/javase/6/docs/api/java/io/File.html"><TT>java.io.File</TT></A>.
Method
<A HREF="http://download.oracle.com/javase/6/docs/api/java/io/File.html#listFiles()"><TT>File.listFiles()</TT></A> may
return null, but is specified to return a non-null value if
<A HREF="http://download.oracle.com/javase/6/docs/api/java/io/File.html#isDirectory()"><TT>File.isDirectory()</TT></A> is
true. The same holds for method
<A HREF="http://download.oracle.com/javase/6/docs/api/java/io/File.html#listFiles()"><TT>File.list()</TT></A>.
You could declare this relationship in the following way (this particular
example is already
done for you in the annotated JDK that comes with the Checker Framework):</P><PRE CLASS="verbatim">  class File {

    @AssertNonNullIfTrue({"list()", "listFiles()"})
    public boolean isDirectory() { ... }

    public File @Nullable [] listFiles();
  }
</PRE><P>A client that checks that a <TT>File</TT> reference is indeed that of a directory,
can then de-reference <TT>File.isDirectory</TT> safely without any nullness check.</P><PRE CLASS="verbatim">  static void analyze(File file) {
    if (file.isDirectory()) {
      for (File child : file.listFiles()) {  // no possible null dereference
        analyze(child);
      }
    } else {
        ... analyze file ...
    }
  }
</PRE><!--TOC subsection Inference of <TT>@NonNull</TT> and <TT>@Nullable</TT> annotations-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->3.2.4&#XA0;&#XA0;Inference of <TT>@NonNull</TT> and <TT>@Nullable</TT> annotations<A NAME="nullness-inference"></A></H3><!--SEC END --><P>It can be tedious to write annotations in your code. Tools exist that
can automatically infer annotations and insert them in your source code.
(This is different than type qualifier refinement for local variables
(Section&#XA0;<A HREF="#type-refinement">16.3.2</A>), which infers a more specific type for
local variables and uses them during type-checking but does not insert them
in your source code. Type qualifier refinement is always enabled, no
matter how annotations on signatures got inserted in your source code.)</P><P>Your choice of tool depends on what default annotation (see
Section&#XA0;<A HREF="#null-defaults">3.2.2</A>) your code uses. You only need one of these tools.</P><UL CLASS="itemize"><LI CLASS="li-itemize">Inference of <TT>@</TT><A HREF="doc/checkers/nullness/quals/Nullable.html"><TT>Nullable</TT></A>:
If your code uses the standard NNEL (non-null-except-locals) default or
the <A HREF="doc/checkers/nullness/quals/NonNull.html"><TT>NonNull</TT></A> default, then use the
<A HREF="http://groups.csail.mit.edu/pag/daikon/download/doc/daikon.html#AnnotateNullable">AnnotateNullable</A>
tool of the <A HREF="http://pag.csail.mit.edu/daikon/">Daikon invariant
detector</A>.</LI><LI CLASS="li-itemize">Inference of <TT>@</TT><A HREF="doc/checkers/nullness/quals/NonNull.html"><TT>NonNull</TT></A>:
If your code uses the Nullable default, use one of these tools:
<UL CLASS="itemize"><LI CLASS="li-itemize">
<A HREF="http://julia.scienze.univr.it:8080/julia/">Julia analyzer</A>,
</LI><LI CLASS="li-itemize"><A HREF="http://nit.gforge.inria.fr">Nit: Nullability Inference Tool</A>,
</LI><LI CLASS="li-itemize"><A HREF="http://jastadd.org/jastadd-tutorial-examples/non-null-types-for-java">Non-null
checker and inferencer</A> of the <A HREF="http://jastadd.org/">JastAdd
Extensible Compiler</A>.
</LI></UL></LI></UL><!--TOC section What the Nullness checker checks-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="nullness-checks">3.3</A>&#XA0;&#XA0;What the Nullness checker checks</H2><!--SEC END --><P>The checker issues a warning in three cases:</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">When an expression of non-<TT>@</TT><A HREF="doc/checkers/nullness/quals/NonNull.html"><TT>NonNull</TT></A> type
is dereferenced, because it might cause a null pointer exception.
Dereferences occur not only when a field is accessed, but when an array
is indexed, an exception is thrown, a lock is taken in a synchronized
block, and more. For a complete description of all checks performed by
the Nullness checker, see the Javadoc for
<A HREF="doc/checkers/nullness/NullnessVisitor.html"><TT>NullnessVisitor</TT></A>.</LI><LI CLASS="li-enumerate">When an expression of <TT>@</TT><A HREF="doc/checkers/nullness/quals/NonNull.html"><TT>NonNull</TT></A> type
might become null, because it
is a misuse of the type: the null value could flow to a dereference that
the checker does not warn about.</LI><LI CLASS="li-enumerate"><A NAME="lint-nulltest"></A>
When a null check is performed against a value that is guaranteed to be
non-null, as in <TT>("m" == null)</TT>, because this might indicate a
programmer error or misunderstanding, and is unnecessary. This check is
performed only if the <TT>nulltest</TT> lint option is enabled via the
<TT>-Alint=nulltest</TT> command-line option. The lint option is disabled
by default because sometimes such checks are part of ordinary defensive
programming. See Section&#XA0;<A HREF="#suppressing-warnings">17.2</A> for more details
about the <TT>-Alint</TT> command-line option.</LI></OL><P>This example illustrates the programming errors that the checker detects:</P><PRE CLASS="verbatim">           Object   obj;  // might be null
  @NonNull Object nnobj;  // never null
  ...
  obj.toString()         // checker warning:  dereference might cause null pointer exception
  nnobj = obj;           // checker warning:  nnobj may become null
  if (nnobj == null)     // checker warning:  redundant test
</PRE><P>Parameter passing and return values are checked analogously to assignments.</P><P>The Nullness Checker also checks the correctness, and correct use, of
rawness annotations for checking initialization. See
Section&#XA0;<A HREF="#raw-partially-initialized">3.5</A>.</P><!--TOC section Suppressing nullness warnings-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="suppressing-warnings-nullness">3.4</A>&#XA0;&#XA0;Suppressing nullness warnings</H2><!--SEC END --><P>The Checker Framework supplies several ways to suppress warnings, most
notably the <TT>@SuppressWarnings("nullness")</TT> annotation (see
Section&#XA0;<A HREF="#suppressing-warnings">17.2</A>). An example use is</P><PRE CLASS="verbatim">    // might return null
    @Nullable Object getObject() { ... }

    void myMethod() {
      // The programmer knows that this partucular call never returns null.
      @SuppressWarnings("nullness")
      @NonNull Object o2 = getObject();
</PRE><P>The Nullness Checker supports an additional warning suppression key,
<TT>nullness:collection-typeargs</TT>.
Use of <TT>@SuppressWarnings("nullness:generic.argument")</TT> causes the Nullness
Checker to suppress warnings related to misuse of generic type
arguments. One use for this key is when a class is declared to take only
<TT>@NonNull</TT> type arguments, but you want to instantiate the class with a
<TT>@Nullable</TT> type argument, as in <TT>List&lt;@Nullable Object&gt;</TT>. For a more
complete explanation of this example, see
Section&#XA0;<A HREF="#faq-list-map-nonnull-typeargs">21.15</A>.</P><P>The Nullness Checker also permits you to use assertions or method calls to
suppress warnings; see below.</P><!--TOC subsection Suppressing warnings with assertions and method calls-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->3.4.1&#XA0;&#XA0;Suppressing warnings with assertions and method calls<A NAME="suppressing-warnings-with-assertions"></A></H3><!--SEC END --><P>Occasionally, it is inconvenient or
verbose to use the <TT>@SuppressWarnings</TT> annotation. For example, Java does
not permit annotations such as <TT>@SuppressWarnings</TT> to appear on statements.</P><P>For situations when the <TT>@SuppressWarnings</TT> annotation is inconvenient,
the Nullness Checker provides three additional ways to suppress warnings:
via an <TT>assert</TT> statement, the <TT>castNonNull</TT> method, and the
<TT>@AssertParametersNonNull</TT> annotation. These are
appropriate when the Nullness Checker issues a warning, but the programmer
knows for sure that the warning is a false positive, because the value
cannot ever be null at run time.</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
Use an assertion. If the string &#X201C;<TT>nullness</TT>&#X201D;
appears in the message body, then the Nullness Checker treats the
assertion as suppressing a warning and assumes that the assertion always
succeeds. For example, the checker assumes that no null pointer
exception can occur in code such as
<PRE CLASS="verbatim">  assert x != null : "@SuppressWarnings(nullness)";
  ... x.f ...
</PRE><P>If the string &#X201C;<TT>nullness</TT>&#X201D; does not appear in the
assertion message, then the Nullness Checker treats the assertion as being
used for defensive programming, and it warns if the method might throw a
nullness-related exception.</P><P>A downside of putting the string in the assertion message is that if the
assertion ever fails, then a user might see the string and be confused.
But the string should only be used if the programmer has reasoned that
the assertion can never fail.</P></LI><LI CLASS="li-enumerate">Use the <A HREF="doc/checkers/nullness/NullnessUtils.html#castNonNull(T)"><TT>NullnessUtils.castNonNull</TT></A> method.<P>The Nullness
Checker considers both the return value, and also the argument, to
be non-null after the method call. Therefore, the
<TT>castNonNull</TT> method can be used either as a cast expression or
as a statement. The Nullness Checker issues no warnings in any of
the following code:</P><PRE CLASS="verbatim">  // one way to use as a cast:
  @NonNull String s = castNonNull(possiblyNull1);

  // another way to use as a cast:
  castNonNull(possiblyNull2).toString();

  // one way to use as a statement:
  castNonNull(possiblyNull3);
  possiblyNull3.toString();`
</PRE><P>The method also throws <TT>AssertionError</TT> if Java assertions are enabled and
the argument is <TT>null</TT>. However, it is not intended for general defensive
programming; see Section&#XA0;<A HREF="#defensive-programming">3.4.2</A>.</P><P>A potential disadvantage of using the <TT>castNonNull</TT> method is that your
code becomes dependent on the Checker Framework at run time as well as at
compile time. You can avoid this by copying the implementation of
<TT>castNonNull</TT> into your own code, and possibly renaming it if you do not
like the name. Be sure to retain the documentation that indicates that
your copy is intended for use only to suppress warnings and not for
defensive programming. See Section&#XA0;<A HREF="#defensive-programming">3.4.2</A> for an
explanation of the distinction.</P></LI><LI CLASS="li-enumerate">Use the <TT>@</TT><A HREF="doc/checkers/nullness/quals/AssertParametersNonNull.html"><TT>AssertParametersNonNull</TT></A>
annotation. It is used on <TT>castNonNull</TT>, and may be used on other
methods with the same semantics; it should probably never be used in any
other situation.</LI></OL><!--TOC subsection Suppressing warnings on nullness-checking routines and defensive programming-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->3.4.2&#XA0;&#XA0;Suppressing warnings on nullness-checking routines and defensive programming<A NAME="defensive-programming"></A></H3><!--SEC END --><P>One way to suppress warnings in the Nullness Checker is to use
method <TT>castNonNull</TT>.
(Section&#XA0;<A HREF="#suppressing-warnings-with-assertions">3.4.1</A> gives other techniques.)</P><P>This section explains why the Nullness Checker introduces a new method
rather than re-using the <TT>assert</TT> statement (as in
<TT>assert x != null</TT>) or an existing method such as:</P><PRE CLASS="verbatim">  org.junit.Assert.assertNotNull(Object)
  com.google.common.base.Preconditions.checkNotNull(Object)
</PRE><P>In each case, the assertion or method indicates an application invariant &#X2014; a
fact that should always be true. There are two distinct reasons a
programmer may have written the invariant, depending on whether the
programmer is 100% sure that the application invariant holds.</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
A programmer might write it as <B>defensive programming</B>. This causes
the program to throw an exception, which is useful for debugging because
it gives an earlier run-time indication of the error.
A programmer would use an assertion in this way if the programmer is not
100% sure that the application invariant holds.</LI><LI CLASS="li-enumerate">A programmer might write it to <B>suppress</B> false positive
<B>warning messages</B> from a checker. A programmer would use an
assertion this way if the programmer is 100% sure that the application
invariant holds, and the reference can never be null at run time.</LI></OL><P>With assertions and existing methods like JUnit&#X2019;s <TT>assertNotNull</TT>, there
is no way of knowing the programmer&#X2019;s intent in using the method.
Different programmers or codebases may use them in different ways.
Guessing wrong would make the Nullness Checker less useful, because it
would either miss real errors or issue warnings where there is no real
error. Also, different checking tools issue different false warnings that
need to be suppressed, so warning suppression needs to be customized for
each tool rather than inferred from general-purpose code.</P><P>As an example of using assertions for defensive programming, some style
guides suggest using assertions or method calls to indicate nullness. A
programmer might write</P><PRE CLASS="verbatim">    String s = ...
    assert s != null;    // or:  assertNotNull(s);   or: checkNotNull(s);
    ... Double.valueOf(s) ...
</PRE><P>A programming error might cause <TT>s</TT> to be null, in which case the code
would throw an exception at run time.
If the assertion caused the Nullness Checker to assume that <TT>s</TT> is not
<TT>null</TT>, then the Nullness Checker would issue no warning for this code.
That would be undesirable, because the whole purpose of the Nullness
Checker is to give a compile-time warning about possible run-time
exceptions. Furthermore, if the programmer uses assertions for defensive
programming systematically throughout the codebase, then many useful
Nullness Checker warnings would be suppressed.</P><P>Because it is important to distinguish between the two uses of assertions
(defensive programming vs.&#XA0;suppressing warnings), the Checker Framework
introduces the <A HREF="doc/checkers/nullness/NullnessUtils.html#castNonNull(T)"><TT>NullnessUtils.castNonNull</TT></A> method.
Unlike existing assertions and
methods, <TT>castNonNull</TT> is intended only to suppress false warnings that are
issued by the Nullness Checker, not for defensive programming.</P><P>If you know that a particular codebase uses
a nullness-checking method not for defensive programming but to indicate
facts that are guaranteed to be true (that is, these assertions will never
fail at run time), then you can cause the Nullness Checker to suppress
warnings related to them, just as it does for <TT>castNonNull</TT>.
Annotate its definition just as
<A HREF="doc/checkers/nullness/NullnessUtils.html#castNonNull(T)"><TT>NullnessUtils.castNonNull</TT></A> is annotated (see the
source code for the Checker Framework).
Also, be sure to document the intention in the method&#X2019;s Javadoc, so that
programmers do not
accidentally misuse it for defensive programming.</P><P>If you are annotating a codebase that already contains precondition checks,
such as:</P><PRE CLASS="verbatim">  public String get(String key, String def) {
    checkNotNull(key, "key"); //NOI18N
    ...
  }
</PRE><P>then you should mark the appropriate parameter as <TT>@NonNull</TT> (which is the
default). This will prevent the checker from issuing a warning about the
<TT>checkNotNull</TT> call.</P><!--TOC section <TT>@Raw</TT> annotation for partially-initialized objects-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="raw-partially-initialized">3.5</A>&#XA0;&#XA0;<TT>@Raw</TT> annotation for partially-initialized objects</H2><!--SEC END --><P>The rawness hierarchy indicates whether an object is fully initialized &#X2014;
that is, whether its fields have all been assigned. This is mostly
relevant within the constructor, or for references to <TT>this</TT> that
escape the constructor. Most readers can skip this section on first
reading; you can return to it once you have mastered the rest of the
nullness checker.</P><P>The rawness hierarchy is independent of the
nullness hierarchy, and is shown in Figure&#XA0;<A HREF="#fig:nonnull-hierarchy">3.1</A>.
The rawness hierarchy contains these qualifiers:</P><DL CLASS="description"><DT CLASS="dt-description"><B><TT>@</TT></B><A HREF="doc/checkers/nullness/quals/Raw.html"><B><TT>Raw</TT></B></A></DT><DD CLASS="dd-description">
indicates a type that contains a partially-initialized object. In a
partially-initialized object, fields that are annotated as
<TT>@</TT><A HREF="doc/checkers/nullness/quals/NonNull.html"><TT>NonNull</TT></A> may be null because the field
has not yet been assigned. Within the constructor,
<TT>this</TT> has <TT>@</TT><A HREF="doc/checkers/nullness/quals/Raw.html"><TT>Raw</TT></A> type until all
the fields have been assigned.</DD><DT CLASS="dt-description"><B><TT>@</TT></B><A HREF="doc/checkers/nullness/quals/NonRaw.html"><B><TT>NonRaw</TT></B></A></DT><DD CLASS="dd-description">
indicates a type that contains a fully-initialized object. <TT>NonRaw</TT>
is the default, so there is little need for a programmer to write this
explicitly.</DD><DT CLASS="dt-description"><B><TT>@</TT></B><A HREF="doc/checkers/nullness/quals/PolyRaw.html"><B><TT>PolyRaw</TT></B></A></DT><DD CLASS="dd-description">
indicates qualifier polymorphism over rawness (see
Section&#XA0;<A HREF="#qualifier-polymorphism">16.1.2</A>).</DD></DL><P>Suppose a class contains a field &#X201C;<TT>@</TT><A HREF="doc/checkers/nullness/quals/NonNull.html"><TT>NonNull</TT></A><TT>
Date d;</TT>&#X201D;. Java executes the class&#X2019;s constructor by first setting <TT>d</TT> to
<TT>null</TT>. The constructor sets field <TT>d</TT> to its final value, either
directly or by calling helper methods. Before the constructor sets field
<TT>d</TT>, its initial value <TT>null</TT> violates its type <TT>@NonNull Date</TT>.
In general, code can depend on field <TT>d</TT> not being null, but not in a
partially-initialized object. A partially-initialized object (<TT>this</TT>
in a constructor) may be passed to a helper method or stored in a variable;
if so, the method receiver, or the field, would have to be annotated as
<TT>@Raw</TT>.</P><P>The <TT>@</TT><A HREF="doc/checkers/nullness/quals/Raw.html"><TT>Raw</TT></A> type annotation represents a
partially-initialized object. If a reference has
<TT>@Raw</TT> type, then all of its <TT>@NonNull</TT> fields are treated as
<TT>@</TT><A HREF="doc/checkers/nullness/quals/LazyNonNull.html"><TT>LazyNonNull</TT></A>: when read, they are
treated as being <TT>@</TT><A HREF="doc/checkers/nullness/quals/Nullable.html"><TT>Nullable</TT></A>, but when
written, they are treated as being
<TT>@</TT><A HREF="doc/checkers/nullness/quals/NonNull.html"><TT>NonNull</TT></A>.</P><P>The rawness hierarchy is orthogonal to the nullness hierarchy. It
is legal for a reference to be <TT>@NonNull @Raw</TT>, <TT>@Nullable @Raw</TT>,
<TT>@NonNull @NonRaw</TT>, or <TT>@Nullable @NonRaw</TT>. The nullness hierarchy tells
you about the reference itself: might the reference be null? The rawness
hierarchy tells you about the <TT>@NonNull</TT> fields in the referred-to object:
might those fields be temporarily null in contravention of their
declaration?</P><P>You can suppress warnings related to partially-initialized objects with
<TT>@SuppressWarnings("rawness")</TT>. (Do not confuse this with the unrelated
<TT>@SuppressWarnings("rawtypes")</TT> annotation for non-instantiated generic types!)</P><!--TOC paragraph How an object becomes non-raw-->
<H5 CLASS="paragraph"><!--SEC ANCHOR -->How an object becomes non-raw</H5><!--SEC END --><P>Within the constructor,
<TT>this</TT> starts out with <TT>@</TT><A HREF="doc/checkers/nullness/quals/Raw.html"><TT>Raw</TT></A> type.
As soon as all of the <TT>@</TT><A HREF="doc/checkers/nullness/quals/NonNull.html"><TT>NonNull</TT></A> fields
have been initialized, then <TT>this</TT> is treated as non-raw.</P><P>The Nullness checker issues an error if the constructor fails to initialize
any non-null field. This ensures that the object is in a legal (non-raw)
state by the time that the constructor exits.


This is different than Java&#X2019;s test for definite assignment (see
<A HREF="http://java.sun.com/docs/books/jls/third_edition/html/defAssign.html">JLS ch.16</A>),
which does not apply to fields (except blank final ones, defined in
<A HREF="http://java.sun.com/docs/books/jls/third_edition/html/defAssign.html">JLS &#XA7;4.12.4</A>) because fields
have a default value of null.</P><P>Currently, the type-checker requires that all fields either have a a
default in the field declaration, or be initialized in the constructor. If
your code initializes (some) fields in a helper method, you will need to
suppress some warnings.</P><!--TOC paragraph Invoking the superclass constructor; rawness of the superclass reference-->
<H5 CLASS="paragraph"><!--SEC ANCHOR -->Invoking the superclass constructor; rawness of the superclass reference</H5><!--SEC END --><P>Suppose that class B extends class A. Within the B
constructor, until the A superclass constructor is called, <TT>this</TT> has
type <TT>@Raw B</TT> and also <TT>@Raw A</TT>. After the
superclass constructor has been exited, then <TT>this</TT> has type
<TT>@Raw B</TT> and also <TT>@NonRaw A</TT>.
By the time that the constructor exits, <TT>this</TT> has type <TT>@NonRaw B</TT> and
also <TT>@NonRaw A</TT>.</P><P>When you write <TT>@Raw</TT>, the annotation applies only to the given class, not
to any superclass. For instance, the checker interprets <TT>@Raw B</TT> as
&#X201C;<TT>@Raw B</TT> and also <TT><B>@NonRaw</B></TT><TT> A</TT>&#X201D;, rather than
&#X201C;<TT>@Raw B</TT> and also <TT>@Raw A</TT>&#X201D;, which would be less useful. The
only exception is when a method overriding relationship forces the
superclass to also be raw. For example:</P><PRE CLASS="verbatim">  class A extends Object {
    // receiver is "@NonRaw A"
    void nonRawAReceiver() { }
    // annotation forces receiver to be "@Raw A"; also is "@NonRaw Object"
    void rawAReciever() @Raw { }
  }

  class B extends A {
    // annotation forces receiver to be "@Raw B", method overriding forces "@Raw A"
    void rawAReceiver() @Raw {
      super.nonRawAReceiver();  // illegal!  rawness of A does not match
    }
    // annotation forces receiver to be "@Raw B"; also is "@NonRaw A"
    void rawBReceiver() @Raw {
      super.nonRawAReceiver();  // OK
    }
  }
</PRE><!--TOC paragraph A note about the terminology &#X201C;raw&#X201D;-->
<H5 CLASS="paragraph"><!--SEC ANCHOR -->A note about the terminology &#X201C;raw&#X201D;</H5><!--SEC END --><P>The name &#X201C;raw&#X201D; comes from a research paper that proposed this
approach&#XA0;[<A HREF="#FahndrichL2003">FL03</A>].
A better name might have been &#X201C;not yet initialized&#X201D; or &#X201C;partially
initialized&#X201D;, but the term &#X201C;raw&#X201D; is now well-known.
The <TT>@</TT><A HREF="doc/checkers/nullness/quals/Raw.html"><TT>Raw</TT></A>
annotation has nothing to do with the raw types of Java Generics.</P><!--TOC section Map key annotations-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="map-keys">3.6</A>&#XA0;&#XA0;Map key annotations</H2><!--SEC END --><P>Java&#X2019;s
<A HREF="http://download.oracle.com/javase/6/docs/api/java/util/Map.html#get(java.lang.Object)"><TT>Map.get</TT></A>
method always has the possibility to return null, if the key is not in the
map. Thus, to guarantee that the value returned from <TT>Map.get</TT> is
non-null, it is necessary that the map contains only non-null values,
<EM>and</EM> the key is in the map.
The <TT>@</TT><A HREF="doc/checkers/nullness/quals/KeyFor.html"><TT>KeyFor</TT></A> annotation states the latter
property.</P><P>If a type is annotated as <TT>@KeyFor("m")</TT>, then any value v with that type
is a key in Map m. Another way of saying this is that the expression
<TT>m.containsKey(v)</TT> evaluates to true.</P><P>You usually do not have to write <TT>@KeyFor</TT> explicitly, because the
checker infers it based on usage patterns, such as calls to
<TT>containsKey</TT> or iteration over a map&#X2019;s
<A HREF="http://download.oracle.com/javase/6/docs/api/java/util/Map.html#keySet()"><TT>key set</TT></A>.</P><P>One usage pattern where you <EM>do</EM> have to write <TT>@KeyFor</TT> is for a
user-managed collection that is a subset of the key set:</P><PRE CLASS="verbatim">Map&lt;String, Object&gt; m;
Set&lt;@KeyFor("m") String&gt; matchingKeys; // keys that match some criterion
for (@KeyFor("m") String k : matchingKeys) {
  ... m.get(k) ...  // known to be non-null
}
</PRE><P>As with any annotation, use of the <TT>@KeyFor</TT> annotation may force you to
slightly refactor your code. For example, this would be illegal:</P><PRE CLASS="verbatim">  Map&lt;K,V&gt; m;
  Collection&lt;@KeyFor("m") K&gt; coll;
  coll.add(x);
  ...            // at this point, the @KeyFor annotation is violated
  m.put(x, ...);
</PRE><P>but this would be OK:</P><PRE CLASS="verbatim">  Collection&lt;@KeyFor("m") K&gt; coll;
  m.put(x, ...);
  coll.add(x);
</PRE><!--TOC section Examples-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="nullness-example">3.7</A>&#XA0;&#XA0;Examples</H2><!--SEC END --><!--TOC subsection Tiny examples-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->3.7.1&#XA0;&#XA0;Tiny examples<A NAME="nullness-tiny-examples"></A></H3><!--SEC END --><P>To try the Nullness checker on a source file that uses the <TT>@</TT><A HREF="doc/checkers/nullness/quals/NonNull.html"><TT>NonNull</TT></A> qualifier,
use the following command (where <TT>javac</TT> is the JSR 308 compiler that
is distributed with the Checker Framework):</P><PRE CLASS="verbatim">  javac -processor checkers.nullness.NullnessChecker examples/NullnessExample.java
</PRE><P>Compilation will complete without warnings.</P><P>To see the checker warn about incorrect usage of annotations (and therefore the
possibility of a null pointer exception at run time), use the following command:</P><PRE CLASS="verbatim">  javac -processor checkers.nullness.NullnessChecker examples/NullnessExampleWithWarnings.java
</PRE><P>The compiler will issue three warnings regarding violation of the semantics of
<TT>@</TT><A HREF="doc/checkers/nullness/quals/NonNull.html"><TT>NonNull</TT></A>.
</P><!--TOC subsection Annotated library-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->3.7.2&#XA0;&#XA0;Annotated library<A NAME="nullness-annotated-library"></A></H3><!--SEC END --><P>Some libraries that are annotated with nullness qualifiers are:</P><UL CLASS="itemize"><LI CLASS="li-itemize">
The Nullness checker itself.</LI><LI CLASS="li-itemize">The
<A HREF="http://code.google.com/p/plume-lib/">Plume-lib library</A>.
Run the command <TT>make check-nullness</TT>.</LI><LI CLASS="li-itemize">The
<A HREF="http://groups.csail.mit.edu/pag/daikon/">Daikon invariant detector</A>.
Run the command <TT>make check-nullness</TT>.</LI></UL><!--TOC section Other tools for nullness checking-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="nullness-related-work">3.8</A>&#XA0;&#XA0;Other tools for nullness checking</H2><!--SEC END --><P>The Checker Framework&#X2019;s nullness annotation is similar to annotations used
in IntelliJ IDEA, FindBugs, JML, the JSR 305 proposal, and others. Also
see Section&#XA0;<A HREF="#other-tools">22.5</A> for a comparison to other tools.</P><P>You might prefer to use the Checker Framework because it has a more
powerful analysis that can warn you about more null pointer errors in your
code.</P><P>If you have already annotated your code with a different nullness
annotation, you can reuse that effort by converting them to the Checker
Framework&#X2019;s nullness annotations. Perform the refactoring described in
Figure&#XA0;<A HREF="#fig:findbugs-refactoring">3.2</A>.</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="center">
<TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=left NOWRAP><TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1><TR><TD ALIGN=left NOWRAP> &#XA0;edu.umd.cs.findbugs.annotations.NonNull&#XA0;</TD></TR>
<TR><TD ALIGN=left NOWRAP> &#XA0;javax.annotation.Nonnull&#XA0;</TD></TR>
<TR><TD ALIGN=left NOWRAP> &#XA0;org.jetbrains.annotations.NotNull&#XA0;</TD></TR>
</TABLE></TD><TD ALIGN=left NOWRAP>&#X21D2;
&#XA0;checkers.nullness.quals.NonNull&#XA0;</TD></TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=left NOWRAP><TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1><TR><TD ALIGN=left NOWRAP> &#XA0;edu.umd.cs.findbugs.annotations.Nullable&#XA0;</TD></TR>
<TR><TD ALIGN=left NOWRAP> &#XA0;edu.umd.cs.findbugs.annotations.CheckForNull&#XA0;</TD></TR>
<TR><TD ALIGN=left NOWRAP> &#XA0;edu.umd.cs.findbugs.annotations.UnknownNullness&#XA0;</TD></TR>
<TR><TD ALIGN=left NOWRAP> &#XA0;javax.annotation.Nullable&#XA0;</TD></TR>
<TR><TD ALIGN=left NOWRAP> &#XA0;javax.annotation.CheckForNull&#XA0;</TD></TR>
<TR><TD ALIGN=left NOWRAP> &#XA0;org.jetbrains.annotations.Nullable&#XA0;</TD></TR>
</TABLE></TD><TD ALIGN=left NOWRAP>&#X21D2;
&#XA0;checkers.nullness.quals.Nullable&#XA0;</TD></TR>
</TABLE>
</DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 3.2: Refactoring for converting nullness annotations from FindBugs, the
JSR&#XA0;305 proposal, and IntelliJ to the Checker Framework.</TD></TR>
</TABLE></DIV>
<A NAME="fig:findbugs-refactoring"></A>
<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P>Alternately, the Checker Framework can process those other annotations (as
well as its own, if they also appear in your program). The Checker
Framework has its own definition of the annotations on the left side of
Figure&#XA0;<A HREF="#fig:findbugs-refactoring">3.2</A>, so that they can be used as type
qualifiers. The Checker Framework interprets them according to the right
side of Figure&#XA0;<A HREF="#fig:findbugs-refactoring">3.2</A>.</P><P>The Checker Framework may issue more or fewer errors than another tool.
This is expected, since each tool uses a different analysis. Remember that
the Checker Framework aims at soundness: it aims to never miss a possible
null dereference, while at the same time limiting false reports.</P><P>Because some of the names are the same (<TT>NonNull</TT>, <TT>Nullable</TT>), it is
unpleasant to use nullness annotations from multiple different packages in
the same codebase. You can import at most one of the annotations with
conflicting names; the other(s) must be written out fully rather than
imported. Also, note FindBugs&#X2019;s non-standard meaning for
<TT>@Nullable</TT> (Section&#XA0;<A HREF="#findbugs-nullable">3.8.2</A>).</P><!--TOC subsection Which tool is right for you?-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->3.8.1&#XA0;&#XA0;Which tool is right for you?<A NAME="choosing-nullness-tool"></A></H3><!--SEC END --><P>Different tools are appropriate in different circumstances. Here is a
brief comparison with FindBugs, but similar points apply to other tools.</P><P>Checker Framework has a more powerful nullness analysis; FindBugs misses
some real
errors. However, FindBugs does not require you to annotate your code as
thoroughly as the Checker Framework does. Depending on the importance of
your code, you may wish to do no nullness checking; the cursory checking of
FindBugs; or the thorough checking of the Checker Framework. You might
even want to ensure that both tools run, for example if your coworkers or
some other organization are still using FindBugs. If you know that you
will eventually want to use the Checker Framework, there is no point using
FindBugs first; it is easier to go straight to using the Checker Framework.</P><P>FindBugs can find other errors in addition to nullness errors; here
we focus on its nullness checks. Even if you use FindBugs for its other
features, you may want to use the Checker Framework for analyses that can
be expressed as pluggable type-checking, such as detecting nullness errors.</P><P>Regardless of whether you wish to use the FindBugs nullness analysis, you
may continue running all of the other FindBugs analyses at the same time as
the Checker Framework; there are no interactions among them.</P><P>If FindBugs (or any other tool) discovers a nullness error that the Checker
Framework does not, please report it to us (see
Section&#XA0;<A HREF="#reporting-bugs">22.2</A>) so that we can enhance the Checker Framework.</P><!--TOC subsection Incompatibility note about FindBugs <TT>@Nullable</TT>-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->3.8.2&#XA0;&#XA0;Incompatibility note about FindBugs <TT>@Nullable</TT><A NAME="findbugs-nullable"></A></H3><!--SEC END --><P>FindBugs has a non-standard definition of <TT>@Nullable</TT>. FindBugs&#X2019;s treatment is not
documented in its own
<A HREF="http://findbugs.sourceforge.net/api/edu/umd/cs/findbugs/annotations/Nullable.html">Javadoc</A>;
it is different from the definition of <TT>@Nullable</TT> in every other tool for
nullness analysis; it means the same thing as <TT>@NonNull</TT> when applied to a
formal parameter; and it invariably surprises programmers. Thus, FindBugs&#X2019;s
<TT>@Nullable</TT> is detrimental rather than useful as documentation.
In practice, your best bet is to not rely on FindBugs for nullness analysis,
even if you find FindBugs useful for other purposes.</P><P>You can skip the rest of this section unless you wish to learn more details.</P><P>FindBugs suppresses all warnings at uses of a <TT>@Nullable</TT> variable.
(You have to use <TT>@CheckForNull</TT> to
indicate a nullable variable that FindBugs should check.) For example:</P><PRE CLASS="verbatim">     // declare getObject() to possibly return null
     @Nullable Object getObject() { ... }

     void myMethod() {
       @Nullable Object o = getObject();
       // FindBugs issues no warning about calling toString on a possibly-null reference!
       o.toString();
     }
</PRE><P>The Checker Framework does not emulate this non-standard behavior of
FindBugs, even if the code uses FindBugs annotations.</P><P>FindBugs takes the approach of annotating a declaration, and thus
suppressing checking at <EM>all</EM> client uses, even the places that you
want to check.
It is better to suppress warnings at only the specific client uses
where the value is known to be non-null; the Checker Framework supports
this, if you write <TT>@SuppressWarnings</TT> at the client uses.
The Checker Framework also supports suppressing checking at all client uses,
by writing a <TT>@SuppressWarnings</TT> annotation at the declaration site.</P><P>In general, the Checker Framework will issue more warnings than FindBugs,
and some of them may be about real bugs in your program.
See Section&#XA0;<A HREF="#suppressing-warnings-nullness">3.4</A> for information about
suppressing nullness warnings.</P><P>(FindBugs made a poor choice of names. The choice of names should make a
clear distinction between annotations that specify whether a reference is
null, and annotations that suppress false warnings. The choice of names
should also have been consistent for other tools, and intuitively clear to
programmers. The FindBugs choices make the FindBugs annotations less
helpful to people, and much less useful for other tools. The FindBugs
analysis is also very imprecise. For type-related analyses, it is best to
stay away from the FindBugs nullness annotations, and use a more capable
tool like the Checker Framework.)</P><HR><!--TOC chapter Interning checker-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="interning-checker">Chapter&#XA0;4</A>&#XA0;&#XA0;Interning checker</H1><!--SEC END --><P>If the Interning checker issues no warnings for a given program, then all
reference equality tests (i.e., all uses of &#X201C;<TT>==</TT>&#X201D;) are proper;
<TT>==</TT> is not misused where <TT>equals()</TT> should have been used instead.</P><P>Interning is a design pattern in which the same object is used whenever two
different objects would be considered equal. Interning is also known as
canonicalization or hash-consing, and it is related to the flyweight design
pattern.
Interning can save memory and can speed up testing for
equality by permitting use of <TT>==</TT>. However, <TT>==</TT> should be used
only on interned values; using <TT>==</TT> on
non-interned values can result in subtle bugs. For example:</P><PRE CLASS="verbatim">  Integer x = new Integer(22);
  Integer y = new Integer(22);
  System.out.println(x == y);  // prints false!
</PRE><P>The Interning checker helps programmers to prevent such bugs.
The Interning checker also helps to prevent performance problems that result
from failure to use interning.
(See Section&#XA0;<A HREF="#checker-guarantees">2.3</A> for caveats to the checker&#X2019;s guarantees.)</P><P>Interning is such an important design pattern that Java builds it in for
strings. Every string literal in the program is guaranteed to be interned
(<A HREF="http://java.sun.com/docs/books/jls/third_edition/html/lexical.html#3.10.5">JLS
&#XA7;3.10.5</A>), and the
<A HREF="http://download.oracle.com/javase/6/docs/api/java/lang/String.html#intern()"><TT>String.intern()</TT></A> method
performs interning for strings that are computed at run time.
Users can also write their own interning methods for other types.</P><P>It is a proper optimization to use <TT>==</TT>, rather than <TT>equals()</TT>,
whenever the comparison is guaranteed to produce the same result &#X2014; that
is, whenever the comparison is never provided with two different objects
for which <TT>equals()</TT> would return true. Here are three reasons that
this property could hold:</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
Interning. A factory method ensures that, globally, no two different
interned objects are <TT>equals()</TT> to one another. (In some cases
other, non-interned objects of the class might be <TT>equals()</TT> to one
another; in other cases, every object of the class is interned.)
Interned objects should always be immutable.
</LI><LI CLASS="li-enumerate">Global control flow. The program&#X2019;s control flow is such that the
constructor for class <I>C</I> is called a limited number of times, and with
specific values that ensure the results are not <TT>equals()</TT> to one
another. Objects of class <I>C</I> can always be compared with <TT>==</TT>.
Such objects may be mutable or immutable.
</LI><LI CLASS="li-enumerate">Local control flow. Even though not all objects of the given type may be
compared with <TT>==</TT>, the specific objects that can reach a given
comparison may be. For example, suppose that an array contains no
duplicates. Then testing to find the index of a given element that is
known to be in the array can use <TT>==</TT>.
</LI></OL><P>To eliminate Interning Checker warnings, you will need to annotate your
code regarding all legal uses of <TT>==</TT>. Thus, the Interning Checker
should perhaps have been called the Reference Equality Checker. In the
future, the checker will include annotations that target the non-interning
cases above, but for now you need to use <TT>@Interned</TT> and/or
<TT>@SuppressWarnings</TT>.</P><P>To run the Interning Checker, supply the <TT>-processor
checkers.interning.InterningChecker</TT> command-line option to javac. For
examples, see Section&#XA0;<A HREF="#interning-example">4.4</A>.</P><!--TOC section Interning annotations-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="interning-annotations">4.1</A>&#XA0;&#XA0;Interning annotations</H2><!--SEC END --><P>Two qualifiers are part of the Interning type system.</P><DL CLASS="description"><DT CLASS="dt-description"><B><TT>@</TT></B><A HREF="doc/checkers/interning/quals/Interned.html"><B><TT>Interned</TT></B></A></DT><DD CLASS="dd-description">
indicates a type that includes only interned values (no non-interned
values).</DD><DT CLASS="dt-description"><B><TT>@</TT></B><A HREF="doc/checkers/interning/quals/PolyInterned.html"><B><TT>PolyInterned</TT></B></A></DT><DD CLASS="dd-description">
indicates qualifier polymorphism. For a description of
<TT>@</TT><A HREF="doc/checkers/interning/quals/PolyInterned.html"><TT>PolyInterned</TT></A>, see
Section&#XA0;<A HREF="#qualifier-polymorphism">16.1.2</A>.</DD></DL><!--TOC section Annotating your code with <TT>@Interned</TT>-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="annotating-with-interned">4.2</A>&#XA0;&#XA0;Annotating your code with <TT>@Interned</TT></H2><!--SEC END --><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>

<DIV CLASS="center">
<IMG SRC="interning.png" ALT="interning.png"></DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 4.1: Type hierarchy for the Interning type system.</TD></TR>
</TABLE></DIV>
<A NAME="fig:interning-hierarchy"></A>
<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P>In order to perform checking, you must annotate your code with the <TT>@</TT><A HREF="doc/checkers/interning/quals/Interned.html"><TT>Interned</TT></A>
type annotation, which indicates a type for the canonical representation of an
object:</P><PRE CLASS="verbatim">            String s1 = ...;  // type is (uninterned) "String"
  @Interned String s2 = ...;  // Java type is "String", but checker treats it as "Interned String"
</PRE><P>The type system enforced by the checker plugin ensures that only interned
values can be assigned to <TT>s2</TT>.</P><P>To specify that <EM>all</EM> objects of a given type are interned, annotate the
class declaration:</P><PRE CLASS="verbatim">  public @Interned class MyInternedClass { ... }
</PRE><P>This is equivalent to annotating every use of <TT>MyInternedClass</TT>, in a
declaration or elsewhere. For example, <TT>enum</TT> classes are implicitly
so annotated.</P><!--TOC subsection Implicit qualifiers-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->4.2.1&#XA0;&#XA0;Implicit qualifiers<A NAME="interning-implicit-qualifiers"></A></H3><!--SEC END --><P>As described in Section&#XA0;<A HREF="#effective-qualifier">16.3</A>, the Interning checker
adds implicit qualifiers, reducing the number of annotations that must
appear in your code.
For example, String literals and the null literal are always considered interned, and
object creation expressions (using <TT>new</TT>) are never considered
<TT>@</TT><A HREF="doc/checkers/interning/quals/Interned.html"><TT>Interned</TT></A> unless they are annotated as such, as in</P><PRE CLASS="verbatim">@Interned Double internedDoubleZero = new @Interned Double(0); // canonical representation for Double zero
</PRE><P>For a complete description of all implicit interning qualifiers, see the
Javadoc for <A HREF="doc/checkers/interning/InterningAnnotatedTypeFactory.html"><TT>InterningAnnotatedTypeFactory</TT></A>.</P><!--TOC section What the Interning checker checks-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="interning-checks">4.3</A>&#XA0;&#XA0;What the Interning checker checks</H2><!--SEC END --><P>Objects of an <TT>@</TT><A HREF="doc/checkers/interning/quals/Interned.html"><TT>Interned</TT></A> type may be safely compared using the &#X201C;<TT>==</TT>&#X201D;
operator.</P><P>The checker issues a warning in two cases:</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">When a reference (in)equality operator (&#X201C;<TT>==</TT>&#X201D; or &#X201C;<TT>!=</TT>&#X201D;)
has an operand of non-<TT>@</TT><A HREF="doc/checkers/interning/quals/Interned.html"><TT>Interned</TT></A> type.</LI><LI CLASS="li-enumerate">When a non-<TT>@</TT><A HREF="doc/checkers/interning/quals/Interned.html"><TT>Interned</TT></A> type is used where an <TT>@</TT><A HREF="doc/checkers/interning/quals/Interned.html"><TT>Interned</TT></A> type
is expected.</LI></OL><P>This example shows both sorts of problems:</P><PRE CLASS="verbatim">            Object  obj;
  @Interned Object iobj;
  ...
  if (obj == iobj) { ... }  // checker warning: reference equality test is unsafe
  iobj = obj;               // checker warning: iobj's referent may no longer be interned
</PRE><P><A NAME="lint-dotequals"></A></P><P>The checker also issues a warning when <TT>.equals</TT> is used where
<TT>==</TT> could be safely used. You can disable this behavior via the
javac <TT>-Alint</TT> command-line option, like so: <TT>-Alint=-dotequals</TT>.</P><P>For a complete description of all checks performed by
the checker, see the Javadoc for
<A HREF="doc/checkers/interning/InterningVisitor.html"><TT>InterningVisitor</TT></A>.</P><P><A NAME="checking-class"></A>
You can also restrict which types the checker should examine and type-check,
using the <TT>-Acheckclass</TT> option. So if you want to find all the
interning errors related to uses of <TT>String</TT>, you can pass
<TT>-Acheckclass=java.lang.String</TT>.</P><!--TOC section Examples-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="interning-example">4.4</A>&#XA0;&#XA0;Examples</H2><!--SEC END --><P>To try the Interning checker on a source file that uses the <TT>@</TT><A HREF="doc/checkers/interning/quals/Interned.html"><TT>Interned</TT></A> qualifier,
use the following command (where <TT>javac</TT> is the JSR 308 compiler that
is distributed with the Checker Framework):</P><PRE CLASS="verbatim">  javac -processor checkers.interning.InterningChecker examples/InterningExample.java
</PRE><P>Compilation will complete without warnings.</P><P>To see the checker warn about incorrect usage of annotations, use the following
command:</P><PRE CLASS="verbatim">  javac -processor checkers.interning.InterningChecker examples/InterningExampleWithWarnings.java
</PRE><P>The compiler will issue a warning regarding violation of the semantics of
<TT>@</TT><A HREF="doc/checkers/interning/quals/Interned.html"><TT>Interned</TT></A>.
</P><P>The Daikon invariant detector
(<A HREF="http://groups.csail.mit.edu/pag/daikon/"><TT>http://groups.csail.mit.edu/pag/daikon/</TT></A>) is also annotated with
<TT>@</TT><A HREF="doc/checkers/interning/quals/Interned.html"><TT>Interned</TT></A>. From directory <TT>java</TT>,
run <TT>make check-interning</TT>.</P><HR><!--TOC chapter IGJ immutability checker-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="igj-checker">Chapter&#XA0;5</A>&#XA0;&#XA0;IGJ immutability checker</H1><!--SEC END --><P>IGJ is a Java language extension that helps programmers to avoid mutation errors
(unintended side effects).
If the IGJ checker issues no warnings for a given program, then that program
will never change objects that should not be changed. This guarantee
enables a programmer to detect and prevent mutation-related errors.
(See Section&#XA0;<A HREF="#checker-guarantees">2.3</A> for caveats to the guarantee.)</P><P>To run the IGJ Checker, supply the <TT>-processor checkers.igj.IGJChecker</TT>
command-line option to javac. For examples, see Section&#XA0;<A HREF="#igj-example">5.6</A>.</P><!--TOC section IGJ and Mutability-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="igj-and-mutability">5.1</A>&#XA0;&#XA0;IGJ and Mutability</H2><!--SEC END --><P>IGJ&#XA0;[<A HREF="#ZibinPAAKE2007">ZPA<SUP>+</SUP>07</A>] permits a
programmer to express that a particular object should never be modified via any
reference (object immutability), or that a reference should never be used to
modify its referent (reference immutability). Once a programmer has expressed
these facts, an automatic checker analyzes the code to either locate mutability
bugs or to guarantee that the code contains no such bugs.</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>

<DIV CLASS="center">
<IMG SRC="igj.png" ALT="igj.png"></DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 5.1: Type hierarchy for three of IGJ&#X2019;s type qualifiers.</TD></TR>
</TABLE></DIV>
<A NAME="fig:igj-hierarchy"></A>
<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P>To learn more details of the IGJ language and type system, please see the
ESEC/FSE 2007 paper &#X201C;<A HREF="http://www.cs.washington.edu/homes/mernst/pubs/immutability-generics-fse2007-abstract.html">Object and reference immutability using Java
generics</A>&#X201D;&#XA0;[<A HREF="#ZibinPAAKE2007">ZPA<SUP>+</SUP>07</A>].
The IGJ checker supports Annotation IGJ (Section&#XA0;<A HREF="#annotation-igj-dialect">5.5</A>),
which is a slightly different dialect
of IGJ than that described in the ESEC/FSE paper.</P><!--TOC section IGJ Annotations-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="igj-annotations">5.2</A>&#XA0;&#XA0;IGJ Annotations</H2><!--SEC END --><P>Each object is either immutable (it can never be modified) or mutable (it
can be modified). The following qualifiers are part of the IGJ type system.</P><DL CLASS="description"><DT CLASS="dt-description"><B><TT>@</TT></B><A HREF="doc/checkers/igj/quals/Immutable.html"><B><TT>Immutable</TT></B></A></DT><DD CLASS="dd-description">
An immutable reference always refers to an immutable object. Neither the
reference, nor any aliasing reference, may modify the object.</DD><DT CLASS="dt-description"><B><TT>@</TT></B><A HREF="doc/checkers/igj/quals/Mutable.html"><B><TT>Mutable</TT></B></A></DT><DD CLASS="dd-description">
A mutable reference refers to a mutable object. The reference, or some
aliasing mutable reference, may modify the object.</DD><DT CLASS="dt-description"><B><TT>@</TT></B><A HREF="doc/checkers/igj/quals/ReadOnly.html"><B><TT>ReadOnly</TT></B></A></DT><DD CLASS="dd-description">
A readonly reference cannot be used to modify its referent. The referent
may be an immutable or a mutable object. In other words, it is possible
for the referent to change via an aliasing mutable reference, even though
the referent cannot be changed via the readonly reference.</DD><DT CLASS="dt-description"><B><TT>@</TT></B><A HREF="doc/checkers/igj/quals/Assignable.html"><B><TT>Assignable</TT></B></A></DT><DD CLASS="dd-description">
The annotated field may be re-assigned regardless of the
immutability of the enclosing class or object instance.</DD><DT CLASS="dt-description"><B><TT>@</TT></B><A HREF="doc/checkers/igj/quals/AssignsFields.html"><B><TT>AssignsFields</TT></B></A></DT><DD CLASS="dd-description">
is similar to <TT>@Mutable</TT>, but permits only limited mutation &#X2014;
assignment of fields &#X2014; and is intended for use by constructor helper
methods.</DD><DT CLASS="dt-description"><B><TT>@</TT></B><A HREF="doc/checkers/igj/quals/I.html"><B><TT>I</TT></B></A></DT><DD CLASS="dd-description">
simulates mutability overloading or the template behavior of generics.
It can be applied to classes, methods, and parameters. See
Section&#XA0;<A HREF="#igj-templating">5.5.3</A>.</DD></DL><P>For additional details, see&#XA0;[<A HREF="#ZibinPAAKE2007">ZPA<SUP>+</SUP>07</A>].</P><!--TOC section What the IGJ checker checks-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="igj-checks">5.3</A>&#XA0;&#XA0;What the IGJ checker checks</H2><!--SEC END --><P>The IGJ checker issues an error whenever mutation happens through a
readonly reference, when fields of a readonly reference which are not
explicitly marked with <TT>@</TT><A HREF="doc/checkers/igj/quals/Assignable.html"><TT>Assignable</TT></A> are
reassigned, or when a readonly reference is assigned to a mutable
variable. The checker also emits a warning when casts increase the
mutability access of a reference.</P><!--TOC section Implicit and default qualifiers-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="igj-implicit-qualifiers">5.4</A>&#XA0;&#XA0;Implicit and default qualifiers</H2><!--SEC END --><P>As described in Section&#XA0;<A HREF="#effective-qualifier">16.3</A>, the IGJ checker
adds implicit qualifiers, reducing the number of annotations that must
appear in your code.
</P><P>For a complete description of all implicit IGJ qualifiers, see the
Javadoc for <A HREF="doc/checkers/igj/IGJAnnotatedTypeFactory.html"><TT>IGJAnnotatedTypeFactory</TT></A>.</P><P>The default annotation (for types that are unannotated and not given an
implicit qualifier) is as follows:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<TT>@Mutable</TT> for almost all references. This is backward-compatible
with Java, since Java permits any reference to be mutated.
</LI><LI CLASS="li-itemize"><TT>@Readonly</TT> for local variables. This qualifier may be refined by
flow-sensitive local type refinement (see Section&#XA0;<A HREF="#type-refinement">16.3.2</A>).
</LI><LI CLASS="li-itemize"><TT>@Readonly</TT> for type parameter and wildcard bounds. For example,<PRE CLASS="verbatim">  interface List&lt;T extends Object&gt; { ... }
</PRE><P>is defaulted to</P><PRE CLASS="verbatim">  interface List&lt;T extends @Readonly Object&gt; { ... }
</PRE><P>This default is not backward-compatible &#X2014; that is, you may have to
explicitly add <TT>@Mutable</TT> annotations to some type parameter bounds in
order to make unannotated Java code type-check under IGJ. However, this
reduces the number of annotations you must write overall (since most
variables of generic type are in fact not modified), and permits more
client code to type-check (otherwise a client could not write
<TT>List&lt;@Readonly Date&gt;</TT>).</P></LI></UL><!--TOC section Annotation IGJ Dialect-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="annotation-igj-dialect">5.5</A>&#XA0;&#XA0;Annotation IGJ Dialect</H2><!--SEC END --><P>The IGJ checker supports the Annotation IGJ dialect of IGJ. The syntax of
Annotation IGJ is based on type annotations.</P><P>The syntax of the original IGJ
dialect&#XA0;[<A HREF="#ZibinPAAKE2007">ZPA<SUP>+</SUP>07</A>] was based on Java 5&#X2019;s generics and annotation mechanisms. The original
IGJ dialect was not backward-compatible with Java (either syntactically or
semantically). The dialect of IGJ checked by the IGJ checker corrects these
problems.</P><P>The differences between the Annotation IGJ dialect and the original IGJ dialect
are as follows.</P><!--TOC subsection Semantic Changes-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->5.5.1&#XA0;&#XA0;Semantic Changes</H3><!--SEC END --><UL CLASS="itemize"><LI CLASS="li-itemize">Annotation IGJ does not permit covariant changes in generic type
arguments, for backward compatibility with Java. In ordinary Java, types
with different generic type arguments, such as <TT>Vector&lt;Integer&gt;</TT> and
<TT>Vector&lt;Number&gt;</TT>, have no subtype relationship, even if the
arguments (<TT>Integer</TT> and <TT>Number</TT>) do. The original IGJ dialect
changed the Java subtyping rules to permit safely varying a type argument
covariantly in certain circumstances. For example,<PRE CLASS="verbatim">  Vector&lt;Mutable, Integer&gt;  &lt;:  Vector&lt;ReadOnly, Integer&gt;
                            &lt;:  Vector&lt;ReadOnly, Number&gt;
                            &lt;:  Vector&lt;ReadOnly, Object&gt;
</PRE><P>is valid in IGJ, but in Annotation IGJ, only</P><PRE CLASS="verbatim">  @Mutable Vector&lt;Integer&gt;  &lt;:  @ReadOnly Vector&lt;Integer&gt;
</PRE><P>holds and the other two subtype relations do not hold</P><PRE CLASS="verbatim">  @ReadOnly Vector&lt;Integer&gt; &lt;/:  @ReadOnly Vector&lt;Number&gt;
                            &lt;/:  @ReadOnly Vector&lt;Object&gt;
</PRE></LI><LI CLASS="li-itemize">Annotation IGJ supports array immutability. The original IGJ dialect did
not permit the (im)mutability of array elements to be specified, because
the generics syntax used by the original IGJ dialect cannot be applied to
array elements.</LI></UL><!--TOC subsection Syntax Changes-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->5.5.2&#XA0;&#XA0;Syntax Changes</H3><!--SEC END --><UL CLASS="itemize"><LI CLASS="li-itemize">Immutability is specified through
<A HREF="http://types.cs.washington.edu/jsr308/">type annotations</A>&#XA0;[<A HREF="#jsr308">Ern08</A>] (Section&#XA0;<A HREF="#igj-annotations">5.2</A>),
not through a combination of generics and annotations. Use of type
annotations makes Annotation IGJ backward compatible with Java syntax.</LI><LI CLASS="li-itemize">Templating over Immutability: The annotation <TT>@</TT><A HREF="doc/checkers/igj/quals/I.html"><TT>I</TT></A><TT>(</TT><TT><EM>id</EM></TT><TT>)</TT> is used to template
over immutability. See Section&#XA0;<A HREF="#igj-templating">5.5.3</A>.</LI></UL><!--TOC subsection Templating Over Immutability: <TT>@I</TT>-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->5.5.3&#XA0;&#XA0;Templating Over Immutability: <TT>@I</TT><A NAME="igj-templating"></A></H3><!--SEC END --><P><TT>@</TT><A HREF="doc/checkers/igj/quals/I.html"><TT>I</TT></A> is a template annotation over IGJ Immutability annotations. It acts
similarly to type variables in Java&#X2019;s generic types, and the name
<TT>@</TT><A HREF="doc/checkers/igj/quals/I.html"><TT>I</TT></A> mimics the standard <TT>&lt;I&gt;</TT> type variable name used in code
written in the original IGJ dialect. The annotation value string is used
to distinguish between multiple instances of <TT>@</TT><A HREF="doc/checkers/igj/quals/I.html"><TT>I</TT></A> &#X2014; in the
generics-based original dialect, these would be expressed as two type
variables <TT>&lt;I&gt;</TT> and <TT>&lt;J&gt;</TT>.</P><!--TOC paragraph Usage on classes-->
<H5 CLASS="paragraph"><!--SEC ANCHOR -->Usage on classes<A NAME="igj-usage-on-classes"></A></H5><!--SEC END --><P>A class declaration annotated with <TT>@</TT><A HREF="doc/checkers/igj/quals/I.html"><TT>I</TT></A> can then be
used with any IGJ Immutability annotation. The actual immutability that
<TT>@</TT><A HREF="doc/checkers/igj/quals/I.html"><TT>I</TT></A> is resolved to dictates the immutability type for all the non-static
appearances of <TT>@</TT><A HREF="doc/checkers/igj/quals/I.html"><TT>I</TT></A> with the same value as the class declaration.</P><P>Example:
</P><PRE CLASS="verbatim">    @I
    public class FileDescriptor {
       private @Immutable Date creationData;
       private @I Date lastModData;

       public @I Date getLastModDate() @ReadOnly { }
    }

    ...
    void useFileDescriptor() {
       @Mutable FileDescriptor file =
                         new @Mutable FileDescriptor(...);
       ...
       @Mutable Data date = file.getLastModDate();

    }
</PRE><P>In the last example, <TT>@</TT><A HREF="doc/checkers/igj/quals/I.html"><TT>I</TT></A> was resolved to <TT>@</TT><A HREF="doc/checkers/igj/quals/Mutable.html"><TT>Mutable</TT></A> for the instance file.</P><!--TOC paragraph Usage on methods-->
<H5 CLASS="paragraph"><!--SEC ANCHOR -->Usage on methods<A NAME="igj-usage-on-methods"></A></H5><!--SEC END --><P>For example, it could be used for method parameters, return values, and the
actual IGJ immutability value would be resolved based on the method invocation.</P><P>For example, the below method <TT>getMidpoint</TT> returns a <TT>Point</TT> with the same
immutability type as the passed parameters if <TT>p1</TT> and <TT>p2</TT> match
in immutability, otherwise <TT>@</TT><A HREF="doc/checkers/igj/quals/I.html"><TT>I</TT></A> is resolved to <TT>@</TT><A HREF="doc/checkers/igj/quals/ReadOnly.html"><TT>ReadOnly</TT></A>:</P><PRE CLASS="verbatim">  static @I Point getMidpoint(@I Point p1, @I Point p2) { ... }
</PRE><P>The <TT>@</TT><A HREF="doc/checkers/igj/quals/I.html"><TT>I</TT></A> annotation value distinguishes between <TT>@</TT><A HREF="doc/checkers/igj/quals/I.html"><TT>I</TT></A>
declarations. So, the below method <TT>findUnion</TT> returns a collection of the same
immutability type as the <EM>first</EM> collection parameter:</P><PRE CLASS="verbatim">  static &lt;E&gt; @I("First") Collection&lt;E&gt; findUnion(@I("First") Collection&lt;E&gt; col1,
                                                 @I("Second") Collection&lt;E&gt; col2) { ... }
</PRE><!--TOC section Examples-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="igj-example">5.6</A>&#XA0;&#XA0;Examples</H2><!--SEC END --><P>To try the IGJ checker on a source file that uses the IGJ qualifier, use
the following command (where <TT>javac</TT> is the JSR 308 compiler that
is distributed with the Checker Framework).</P><PRE CLASS="verbatim">  javac -processor checkers.igj.IGJChecker examples/IGJExample.java
</PRE><P>The IGJ checker itself is also annotated with IGJ annotations.</P><HR><!--TOC chapter Javari immutability checker-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="javari-checker">Chapter&#XA0;6</A>&#XA0;&#XA0;Javari immutability checker</H1><!--SEC END --><P>Javari&#XA0;[<A HREF="#TschantzE2005">TE05</A>, <A HREF="#QuinonezTE2008">QTE08</A>] is a Java language extension that helps programmers to avoid mutation
errors that result from unintended side effects.
If the Javari checker issues no warnings for a given program, then that
program will never change objects that should not be changed. This
guarantee enables a programmer to detect and prevent mutation-related
errors. (See Section&#XA0;<A HREF="#checker-guarantees">2.3</A> for caveats to the guarantee.)
The Javari webpage (<A HREF="http://groups.csail.mit.edu/pag/javari/"><TT>http://groups.csail.mit.edu/pag/javari/</TT></A>) contains
papers that explain the Javari language and type system.
By contrast to those papers, the Javari checker uses an annotation-based
dialect of the Javari language.</P><P>The Javarifier tool infers Javari types for an existing program; see
Section&#XA0;<A HREF="#javari-inference">6.2.2</A>.</P><P>Also consider the IGJ checker (Chapter&#XA0;<A HREF="#igj-checker">5</A>). The IGJ type
system is more expressive than that of Javari, and the IGJ checker is a bit
more robust. However, IGJ lacks a type inference tool such as Javarifier.</P><P>To run the Javari Checker, supply the <TT>-processor
checkers.javari.JavariChecker</TT> command-line option to javac. For
examples, see Section&#XA0;<A HREF="#javari-examples">6.4</A>.</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>

<DIV CLASS="center">
<IMG SRC="javari.png" ALT="javari.png"></DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 6.1: Type hierarchy for Javari&#X2019;s ReadOnly type qualifier.</TD></TR>
</TABLE></DIV>
<A NAME="fig:javari-hierarchy"></A>
<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><!--TOC section Javari annotations-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="javary-annotations">6.1</A>&#XA0;&#XA0;Javari annotations</H2><!--SEC END --><P>The following six annotations make up the Javari type system.</P><DL CLASS="description"><DT CLASS="dt-description"><B><TT>@</TT></B><A HREF="doc/checkers/javari/quals/ReadOnly.html"><B><TT>ReadOnly</TT></B></A></DT><DD CLASS="dd-description">
indicates a type that provides only read-only access. A reference of
this type may not be used to modify its referent, but aliasing references
to that object might change it.</DD><DT CLASS="dt-description"><B><TT>@</TT></B><A HREF="doc/checkers/javari/quals/Mutable.html"><B><TT>Mutable</TT></B></A></DT><DD CLASS="dd-description">
indicates a mutable type.</DD><DT CLASS="dt-description"><B><TT>@</TT></B><A HREF="doc/checkers/javari/quals/Assignable.html"><B><TT>Assignable</TT></B></A></DT><DD CLASS="dd-description">
is a field annotation, not a type qualifier. It indicates that the given
field may always be assigned, no matter what the type of the reference
used to access the field.</DD><DT CLASS="dt-description"><B><TT>@</TT></B><A HREF="doc/checkers/javari/quals/QReadOnly.html"><B><TT>QReadOnly</TT></B></A></DT><DD CLASS="dd-description">
corresponds to Javari&#X2019;s &#X201C;<TT>? readonly</TT>&#X201D; for wildcard types. An
example of its use is <TT>List&lt;@QReadOnly Date&gt;</TT>. It allows only the
operations which are allowed for both readonly and mutable types.</DD><DT CLASS="dt-description"><B><TT>@</TT></B><A HREF="doc/checkers/javari/quals/PolyRead.html"><B><TT>PolyRead</TT></B></A></DT><DD CLASS="dd-description">
(previously named <TT>@RoMaybe</TT>) specifies polymorphism over
mutability; it simulates mutability overloading. It can be applied to
methods and parameters. See Section&#XA0;<A HREF="#qualifier-polymorphism">16.1.2</A> and the
<TT>@</TT><A HREF="doc/checkers/javari/quals/PolyRead.html"><TT>PolyRead</TT></A> Javadoc for more details.</DD><DT CLASS="dt-description"><B><TT>@</TT></B><A HREF="doc/checkers/javari/quals/ThisMutable.html"><B><TT>ThisMutable</TT></B></A></DT><DD CLASS="dd-description">
means that the mutability of the field is the same as that of the
reference that contains it. <TT>@ThisMutable</TT> is the default on
fields, and does not make sense to write elsewhere. Therefore,
<TT>@ThisMutable</TT> should never appear in a program.</DD></DL><!--TOC section Writing Javari annotations-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="writing-javari-annotations">6.2</A>&#XA0;&#XA0;Writing Javari annotations</H2><!--SEC END --><!--TOC subsection Implicit qualifiers-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->6.2.1&#XA0;&#XA0;Implicit qualifiers<A NAME="javari-implicit-qualifiers"></A></H3><!--SEC END --><P>As described in Section&#XA0;<A HREF="#effective-qualifier">16.3</A>, the Javari checker
adds implicit qualifiers, reducing the number of annotations that must
appear in your code.
</P><P>For a complete description of all implicit Javari qualifiers, see the
Javadoc for <A HREF="doc/checkers/javari/JavariAnnotatedTypeFactory.html"><TT>JavariAnnotatedTypeFactory</TT></A>.</P><!--TOC subsection Inference of Javari annotations-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->6.2.2&#XA0;&#XA0;Inference of Javari annotations<A NAME="javari-inference"></A></H3><!--SEC END --><P>It can be tedious to write annotations in your code. The Javarifier tool
(<A HREF="http://groups.csail.mit.edu/pag/javari/javarifier/"><TT>http://groups.csail.mit.edu/pag/javari/javarifier/</TT></A>) infers 
Javari types for an existing program. It 
automatically inserts Javari annotations in your Java program or
in <TT>.class</TT> files.</P><P>This has two benefits: it relieves the programmer of the tedium of writing
annotations (though the programmer can always refine the inferred
annotations), and it annotates libraries, permitting checking of programs
that use those libraries.</P><!--TOC section What the Javari checker checks-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="javari-checks">6.3</A>&#XA0;&#XA0;What the Javari checker checks</H2><!--SEC END --><P>The checker issues an error whenever mutation happens through a readonly
reference, when fields of a readonly reference which are not explicitly
marked with <TT>@</TT><A HREF="doc/checkers/javari/quals/Assignable.html"><TT>Assignable</TT></A> are reassigned, or
when a readonly expression is assigned to a mutable variable. The checker
also emits a warning when casts increase the mutability access of a
reference.</P><!--TOC section Examples-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="javari-examples">6.4</A>&#XA0;&#XA0;Examples</H2><!--SEC END --><P>To try the Javari checker on a source file that uses the Javari
qualifier, use the following command (where <TT>javac</TT> is the JSR 308
compiler that
is distributed with the Checker Framework). Alternately, you may
specify just one of the test files.</P><PRE CLASS="verbatim">  javac -processor checkers.javari.JavariChecker tests/javari/*.java
</PRE><P>The compiler should issue the errors and warnings (if any) specified in the
<TT>.out</TT> files with same name.</P><P>To run the test suite for the Javari checker, use <TT>ant javari-tests</TT>.</P><P>The Javari checker itself is also annotated with Javari annotations.</P><HR><!--TOC chapter Lock checker-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="lock-checker">Chapter&#XA0;7</A>&#XA0;&#XA0;Lock checker</H1><!--SEC END --><P>The Lock checker prevents certain kinds of concurrency errors. If the Lock
checker issues no warnings for a given program, then the program holds the
appropriate lock every time that it accesses a variable.</P><P>Note: This does <EM>not</EM> mean that your program has no concurrency
errors. (You might have forgotten to annotate that a particular variable
should only be accessed when a lock is held. You might release and
re-acquire the lock, when correctness requires you to hold it throughout a
computation. And, there are other concurrency errors that cannot, or
should not, be solved with locks.) However, ensuring that your
program obeys its locking discipline is an easy and effective way to
eliminate a common and important class of errors.</P><P>To run the Lock Checker, supply the <TT>-processor
checkers.lock.LockChecker</TT> command-line option to javac.</P><!--TOC section Lock annotations-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="lock-annotations">7.1</A>&#XA0;&#XA0;Lock annotations</H2><!--SEC END --><P>The Lock checker uses two annotations. One is a type qualifier, and the
other is a method annotation.</P><DL CLASS="description"><DT CLASS="dt-description"><B><TT>@</TT></B><A HREF="doc/checkers/lock/quals/GuardedBy.html"><B><TT>GuardedBy</TT></B></A></DT><DD CLASS="dd-description">
indicates a type whose value may be accessed only when the given lock is
held. See the <A HREF="doc/checkers/lock/quals/GuardedBy.html">GuardedBy
Javadoc</A> for an explanation of the argument. The lock
acquisition and the value access may be arbitrarily far in the future;
or, if the value is never accessed, the lock never need be held.</DD><DT CLASS="dt-description"><B><TT>@</TT></B><A HREF="doc/checkers/lock/quals/Holding.html"><B><TT>Holding</TT></B></A></DT><DD CLASS="dd-description">
is a method annotation (not a qualifier). It indicates that when
the method is called, the given lock must be held by the caller.
In other words, the given lock is already held at the time the method is
called.</DD></DL><!--TOC subsection Examples-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->7.1.1&#XA0;&#XA0;Examples</H3><!--SEC END --><P>Most often, field values are annotated with <TT>@GuardedBy</TT>, but other
uses are possible.</P><P>A return value may be annotated with <TT>@GuardedBy</TT>:</P><PRE CLASS="verbatim">  @GuardedBy("MyClass.myLock") Object myMethod() { ... }

  // reassignments without holding the lock are OK.
  @GuardedBy("MyClass.myLock") Object x = myMethod();
  @GuardedBy("MyClass.myLock") Object y = x;
  Object z = x;  // ILLEGAL (assuming no lock inference),
                 // because z can be freely accessed.
  x.toString() // ILLEGAL because the lock is not held
  synchronized(MyClass.myLock) {
    y.toString();  // OK: the lock is held
  }
</PRE><P>A parameter may be annotated with <TT>@GuardedBy</TT>:</P><PRE CLASS="verbatim">  void helper1(@GuardedBy("MyClass.myLock") Object a) {
    a.toString(); // ILLEGAL: the lock is not held
    synchronized(MyClass.myLock) {
      a.toString();  // OK: the lock is held
    }
  }
  @Holding("MyClass.myLock")
  void helper2(@GuardedBy("MyClass.myLock") Object b) {
    b.toString(); // OK: the lock is held
  }
  void helper3(Object c) {
    c.toString(); // OK: no lock constraints
  }
  void helper4(@GuardedBy("MyClass.myLock") Object d) {
    d.toString(); // ILLEGAL: the lock is not held
  }
  void myMethod2(@GuardedBy("MyClass.myLock") Object e) {
    helper1(e);  // OK to pass to another routine without holding the lock
    e.toString(); // ILLEGAL: the lock is not held
    synchronized (MyClass.myLock) {
      helper2(e);
      helper3(e);
      helper4(e); // OK, but helper4's body still does not type-check
    }
  }
</PRE><!--TOC subsection Discussion of <TT>@Holding</TT>-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->7.1.2&#XA0;&#XA0;Discussion of <TT>@Holding</TT></H3><!--SEC END --><P>A programmer might choose to use the <TT>@Holding</TT> method annotation in
two different ways: to specify a higher-level protocol, or to summarize
intended usage. Both of these approaches are useful, and the Lock checker
supports both.</P><!--TOC paragraph Higher-level synchronization protocol-->
<H5 CLASS="paragraph"><!--SEC ANCHOR -->Higher-level synchronization protocol</H5><!--SEC END --><P><TT>@Holding</TT> can specify a higher-level synchronization protocol that
is not expressible as locks over Java objects. By requiring locks to be
held, you can create higher-level protocol primitives without giving up
the benefits of the annotations and checking of them.</P><!--TOC paragraph Method summary that simplifies reasoning-->
<H5 CLASS="paragraph"><!--SEC ANCHOR -->Method summary that simplifies reasoning</H5><!--SEC END --><P><TT>@Holding</TT> can be a method summary that simplifies reasoning. In
this case, the <TT>@Holding</TT> doesn&#X2019;t necessarily introduce a new
correctness constraint; the program might be correct even if the lock
were acquired later in the body of the method or in a method it calls, so
long as the lock is acquired before accessing the data it protects.</P><P>Rather, here <TT>@Holding</TT> expresses a fact about execution: when
execution reaches this point, the following locks are already held. This
fact enables people and tools to reason intra- rather than
inter-procedurally.</P><P>In Java, it is always legal to re-acquire a lock that is already held,
and the re-acquisition always works. Thus, whenever you write </P><PRE CLASS="verbatim">  @Holding("myLock")
  void myMethod() {
    ...
  }
</PRE><P>it would be equivalent, from the point of view of which locks are held
during the body, to write</P><PRE CLASS="verbatim">  void myMethod() {
    synchronized (myLock) {   // no-op:  re-aquire a lock that is already held
      ...
    }
  }
</PRE><P>The advantages of the <TT>@Holding</TT> annotation include:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
The annotation documents the fact that the lock is intended to already be
held.
</LI><LI CLASS="li-itemize">The Lock Checker enforces that the lock is held when the method is
called, rather than masking a programmer error by silently re-acquiring
the lock.
</LI><LI CLASS="li-itemize">The <TT>synchronized</TT> statement can deadlock if, due to a programmer error,
the lock is not already held. The Lock Checker prevents this type of
error.
</LI><LI CLASS="li-itemize">The annotation has no run-time overhead. Even if the lock re-acquisition
succeeds, it still consumes time.
</LI></UL><!--TOC subsection Relationship to annotations in <EM>Java Concurrency in Practice</EM>-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->7.1.3&#XA0;&#XA0;Relationship to annotations in <EM>Java Concurrency in Practice</EM><A NAME="jcip-annotations"></A></H3><!--SEC END --><P>The book <A HREF="http://jcip.net/"><EM>Java Concurrency in Practice</EM></A>&#XA0;[<A HREF="#Goetz2006">GPB<SUP>+</SUP>06</A>] defines a
<A HREF="http://jcip.net/annotations/doc/net/jcip/annotations/GuardedBy.html"><TT>@GuardedBy</TT></A> annotation that is the inspiration for ours. The book&#X2019;s
<TT>@GuardedBy</TT> serves two related purposes:</P><UL CLASS="itemize"><LI CLASS="li-itemize">
When applied to a field, it means that the given lock must be held when
accessing the field. The lock acquisition and the field access may be
arbitrarily far in the future.
</LI><LI CLASS="li-itemize">When applied to a method, it means that the given lock must be held by
the caller at the time that the method is called &#X2014; in other words, at
the time that execution passes the <TT>@GuardedBy</TT> annotation.
</LI></UL><P>One rationale for reusing the annotation name for both purposes in JCIP is
that there are fewer annotations to learn. Another rationale is
that both variables and methods are &#X201C;members&#X201D; that can be &#X201C;accessed&#X201D;;
variables can be accessed by reading or writing them (putfield, getfield),
and methods can be accessed by calling them (invokevirtual,
invokeinterface). In both cases, <TT>@GuardedBy</TT> creates preconditions
for accessing so-annotated members. This informal intuition is
inappropriate for a tool that requires precise semantics.</P><P>The Lock checker renames the method annotation to
<TT>@</TT><A HREF="doc/checkers/lock/quals/Holding.html"><TT>Holding</TT></A>, and it generalizes the 
<TT>@</TT><A HREF="doc/checkers/lock/quals/GuardedBy.html"><TT>GuardedBy</TT></A> annotation into a type qualifier
that can apply not just to a field but to an arbitrary type (including the
type of a parameter, return value, local variable, generic type parameter,
etc.). This makes the annotations more expressive and also more amenable
to automated checking. It also accommodates the distinct (though related)
meanings of the two annotations.</P><HR><!--TOC chapter Fake Enum checker-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="fenum-checker">Chapter&#XA0;8</A>&#XA0;&#XA0;Fake Enum checker</H1><!--SEC END --><P>Java&#X2019;s 
<A HREF="http://java.sun.com/docs/books/jls/third_edition/html/classes.html#8.9"><TT>enum</TT></A>
keyword lets you define an enumeration type: a finite set of distinct values
that are related to one another but are disjoint from all other
types, including other enumerations.
Before enums were added to Java, there were two ways to encode an
enumeration, both of which are error-prone:</P><DL CLASS="description"><DT CLASS="dt-description">
<B>the fake enum pattern</B></DT><DD CLASS="dd-description"> a set of <TT>int</TT> or <TT>String</TT>
constants (as often found in older C code).</DD><DT CLASS="dt-description"><B>the </B><A HREF="http://java.sun.com/developer/Books/shiftintojava/page1.html"><B>typesafe
enum pattern</B></A></DT><DD CLASS="dd-description"> a class with private constructor.
</DD></DL><P>Sometimes you need to use the fake enum pattern,
rather than a real enum or the typesafe enum pattern.
One reason is backward-compatibility. A public API that predates Java&#X2019;s
enum keyword may use <TT>int</TT> constants; it cannot be changed, because
doing so would break existing clients. For example, Java&#X2019;s JDK still uses
<TT>int</TT> constants in the AWT and Swing frameworks.
Another reason is performance, especially in environments with limited
resources. For example, the Android mobile phone platform
<A HREF="http://developer.android.com/guide/practices/design/performance.html#avoid_enums">recommends</A>
use of fake enums when only an integer value is needed, in order to reduce
code size and run time.</P><P>In cases when code has to use the fake enum pattern, the fake enum (Fenum)
checker gives the same safety guarantees as a true enumeration type. 
The developer can introduce new types that are distinct from all values of the
base type and from all other fake enums. Fenums can be introduced for
primitive types as well as for reference types.</P><!--TOC section Fake enum annotations-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="fenum-annotations">8.1</A>&#XA0;&#XA0;Fake enum annotations</H2><!--SEC END --><P>The checker supports two ways to introduce a new fake enum (fenum):</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
Introduce your own specialized fenum annotation with code like this in
file <TT><EM>MyFenum</EM></TT><TT>.java</TT>:<PRE>
package <I>myproject</I>.quals;

import java.lang.annotation.*;
import checkers.quals.SubtypeOf;
import checkers.quals.TypeQualifier;

@Documented
@Retention(RetentionPolicy.RUNTIME)
@TypeQualifier
@SubtypeOf( <TT>{</TT> FenumTop.class <TT>}</TT> )
public @interface <I>MyFenum</I> <TT>{</TT><TT>}</TT>
</PRE><P>You only need to adapt the package, annotation, and file names in the example.</P></LI><LI CLASS="li-enumerate">Use the provided <TT>@</TT><A HREF="doc/checkers/fenum/quals/Fenum.html"><TT>Fenum</TT></A> annotation, that takes a
<TT>String</TT> argument to distinguish different fenums.
For example, <TT>@Fenum("A")</TT> and <TT>@Fenum("B")</TT> are two distinct fenums.
</LI></OL><P>The first approach allows you to define a short, meaningful name suitable for
your project, whereas the second approach allows quick prototyping.</P><!--TOC section What the Fenum checker checks-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="fenum-checks">8.2</A>&#XA0;&#XA0;What the Fenum checker checks</H2><!--SEC END --><P>The Fenum checker ensures that unrelated types are not mixed. 
All types with a particular fenum annotation, or <TT>@Fenum(...)</TT> with a particular <TT>String</TT> argument, are
disjoint from all unannotated types and all types with a different fenum
annotation or <TT>String</TT> argument.</P><P>The checker forbids method calls on fenum types and ensures that
only compatible fenum types are used in comparisons and arithmetic operations
(if applicable to the annotated type).</P><P>It is the programmer&#X2019;s responsibility to ensure that fields with a fenum type
are properly initialized before use. Otherwise, one might observe a <TT>null</TT>
reference or zero value in the field of a fenum type. (The Nullness checker
(Chapter&#XA0;<A HREF="#nullness-checker">3</A>) can prevent failure to initialize a
reference variable.)</P><!--TOC section Running the Fenum checker-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="fenum-running">8.3</A>&#XA0;&#XA0;Running the Fenum checker</H2><!--SEC END --><P>The Fenum checker can be invoked by running the following commands.</P><UL CLASS="itemize"><LI CLASS="li-itemize">
If you define your own annotation, provide the name of the annotation using the
<TT>-Aquals</TT> option:<PRE>
  javac -processor checkers.fenum.FenumChecker
        <I>-Aquals=myproject.quals.MyFenum</I> MyFile.java ...
</PRE></LI><LI CLASS="li-itemize">If your code uses the <TT>@</TT><A HREF="doc/checkers/fenum/quals/Fenum.html"><TT>Fenum</TT></A> annotation, you do
not need the <TT>-Aquals</TT> option:<PRE CLASS="verbatim">  javac -processor checkers.fenum.FenumChecker MyFile.java ...
</PRE></LI></UL><!--TOC section Suppressing warnings-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="fenum-suppressing">8.4</A>&#XA0;&#XA0;Suppressing warnings</H2><!--SEC END --><P>One example of when you need to suppress warnings is when you initialize the
fenum constants to literal values.
To remove this warning message, add the corresponding <TT>@SuppressWarnings</TT> to either
the field or class declaration, for example:</P><PRE CLASS="verbatim">@SuppressWarnings("fenum:assignment.type.incompatible")
class MyConsts {
  public static final @Fenum("A") int ACONST1 = 1;
  public static final @Fenum("A") int ACONST2 = 2;  
}
</PRE><!--TOC section Example-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="fenum-example">8.5</A>&#XA0;&#XA0;Example</H2><!--SEC END --><P>The following example introduces two fenums in class <TT>TestStatic</TT>
and then performs a few typical operations.</P><PRE CLASS="verbatim">@SuppressWarnings("fenum:assignment.type.incompatible")   // for initialization
public class TestStatic {
  public static final @Fenum("A") int ACONST1 = 1;
  public static final @Fenum("A") int ACONST2 = 2;

  public static final @Fenum("B") int BCONST1 = 4;
  public static final @Fenum("B") int BCONST2 = 5;
}

class FenumUser {
  @Fenum("A") int state1 = TestStatic.ACONST1;     // ok
  @Fenum("B") int state2 = TestStatic.ACONST1;     // Incompatible fenums forbidden!

  void fenumArg(@Fenum("A") int p) {}
 
  void foo() {
    state1 = 4;                     // Direct use of value forbidden!
    state1 = TestStatic.BCONST1;    // Incompatible fenums forbidden!
    state1 = TestStatic.ACONST2;    // ok

    fenumArg(5);                    // Direct use of value forbidden!
    fenumArg(TestStatic.BCONST1);   // Incompatible fenums forbidden!
    fenumArg(TestStatic.ACONST1);   // ok
  }
 }
</PRE><!--TOC section References-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="fenum-references">8.6</A>&#XA0;&#XA0;References</H2><!--SEC END --><UL CLASS="itemize"><LI CLASS="li-itemize">
Java Language Specification on enums:<BR>
 <A HREF="http://java.sun.com/docs/books/jls/third_edition/html/classes.html#8.9"><TT>http://java.sun.com/docs/books/jls/third_edition/html/classes.html#8.9</TT></A></LI><LI CLASS="li-itemize">Tutorial trail on enums:<BR>
 <A HREF="http://java.sun.com/docs/books/tutorial/java/javaOO/enum.html"><TT>http://java.sun.com/docs/books/tutorial/java/javaOO/enum.html</TT></A></LI><LI CLASS="li-itemize">Typesafe enum pattern:<BR>
 <A HREF="http://java.sun.com/developer/Books/shiftintojava/page1.html"><TT>http://java.sun.com/developer/Books/shiftintojava/page1.html</TT></A></LI><LI CLASS="li-itemize">Avoiding enums for performance:<BR>
 <A HREF="http://developer.android.com/guide/practices/design/performance.html#avoid_enums"><TT>http://developer.android.com/guide/practices/design/performance.html#avoid_enums</TT></A></LI><LI CLASS="li-itemize">Java Tip 122: Beware of Java typesafe enumerations:<BR>
 <A HREF="http://www.javaworld.com/javaworld/javatips/jw-javatip122.html"><TT>http://www.javaworld.com/javaworld/javatips/jw-javatip122.html</TT></A></LI></UL><HR><!--TOC chapter Tainting checker-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="tainting-checker">Chapter&#XA0;9</A>&#XA0;&#XA0;Tainting checker</H1><!--SEC END --><P>The tainting checker prevents certain kinds of trust errors.
A <EM>tainted</EM>, or untrusted, value is one that comes from an arbitrary,
possibly malicious source, such as user input or unvalidated data.
In certain parts of your application, using a tainted value can compromise
the application&#X2019;s integrity, causing it to crash, corrupt data, leak
private data, etc.</P><P>For example, a user-supplied pointer, handle, or map key should be
validated before being dereferenced.
As another example, a user-supplied string should not be concatenated into a
SQL query, lest the program be subject to a 
<A HREF="http://en.wikipedia.org/wiki/Sql_injection">SQL injection</A> attack.
A location in your program where malicious data could do damage is
called a <EM>sensitive sink</EM>.</P><P>A program must &#X201C;sanitize&#X201D; or &#X201C;untaint&#X201D; an untrusted value before using
it at a sensitive sink. There are two general ways to untaint a value:
by checking
that it is innocuous/legal (e.g., it contains no characters that can be
interpreted as SQL commands when pasted into a string context), or by
transforming the value to be legal (e.g., quoting all the characters that
can be interpreted as SQL commands). A correct program must use one of
these two techniques so that tainted values never flow to a sensitive sink.
The Tainting Checker ensures that your program does so.</P><P>If the Tainting Checker issues no warning for a given program, then no
tainted value ever flows to a sensitive sink. However, your program is not
necessarily free from all trust errors. As a simple example, you might
have forgotten to annotate a sensitive sink as requiring an untainted type,
or you might have forgotten to annotate untrusted data as having a tainted
type.</P><P>To run the Tainting Checker, supply the <TT>-processor
checkers.tainting.TaintingChecker</TT> command-line option to javac.
</P><!--TOC section Tainting annotations-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="tainting-annotations">9.1</A>&#XA0;&#XA0;Tainting annotations</H2><!--SEC END --><P>The Tainting type system uses the following annotations:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<TT>@</TT><A HREF="doc/checkers/tainting/quals/Untainted.html"><TT>Untainted</TT></A> indicates
a type that includes only untainted, trusted values.
</LI><LI CLASS="li-itemize"><TT>@</TT><A HREF="doc/checkers/tainting/quals/Tainted.html"><TT>Tainted</TT></A> indicates
a type that may include only tainted, untrusted values.
<TT>@Tainted</TT> is a supertype of <TT>@Untainted</TT>.
</LI><LI CLASS="li-itemize"><TT>@</TT><A HREF="doc/checkers/tainting/quals/PolyTainted.html"><TT>PolyTainted</TT></A> is a qualifier that is
polymorphic over tainting (see Section&#XA0;<A HREF="#qualifier-polymorphism">16.1.2</A>).
</LI></UL><!--TOC section Tips on writing <TT>@Untainted</TT> annotations-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="writing-untainted">9.2</A>&#XA0;&#XA0;Tips on writing <TT>@Untainted</TT> annotations</H2><!--SEC END --><P>Most programs are designed with a boundary that surrounds sensitive
computations, separating them from untrusted values. Outside this
boundary, the program may manipulate malicious values, but no malicious
values ever pass the boundary to be operated upon by sensitive
computations.</P><P>In some programs, the area outside the boundary is very small: values are
sanitized as soon as they are received from an external source. In other
programs, the area inside the boundary is very small: values are sanitized
only immediately before being used at a sensitive sink. Either approach
can work, so long as every possibly-tainted value is sanitized before it
reaches a sensitive sink.</P><P>Once you determine the boundary, annotating your program is easy: put
<TT>@Tainted</TT> outside the boundary, <TT>@Untainted</TT> inside, and
<TT>@SuppressWarnings("tainting")</TT> at the validation or
sanitization routines that are used at the boundary.
</P><P>The Tainting Checker&#X2019;s standard default qualifier is <TT>@Tainted</TT> (see
Section&#XA0;<A HREF="#defaults">16.3.1</A> for overriding this default). This is the safest
default, and the one that should be used for all code outside the boundary
(for example, code that reads user input). You can set the default
qualifier to <TT>@Untainted</TT> in code that may contain sensitive sinks.</P><P>The Tainting Checker does not know the intended semantics of your program,
so it cannot warn you if you mis-annotate a sensitive sink as taking
<TT>@Tainted</TT> data, or if you mis-annotate external data as
<TT>@Untainted</TT>. So long as you correctly annotate the sensitive sinks
and the places that untrusted data is read, the Tainting Checker will
ensure that all your other annotations are correct and that no undesired
information flows exist.</P><P>As an example, suppose that you wish to prevent SQL injection attacks. You
would start by annotating the
<A HREF="http://download.oracle.com/javase/6/docs/api/java/sql/Statement.html"><TT>Statement</TT></A> class to indicate that the
<TT>execute</TT> operations may only operate on untainted queries
(Chapter&#XA0;<A HREF="#annotating-libraries">18</A> describes how to annotate external
libraries):</P><PRE CLASS="verbatim">  public boolean execute(@Untainted String sql) throws SQLException;
  public boolean executeUpdate(@Untainted String sql) throws SQLException; 
</PRE><!--TOC section <TT>@Tainted</TT> and <TT>@Untainted</TT> can be used for many purposes-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="tainting-many-uses">9.3</A>&#XA0;&#XA0;<TT>@Tainted</TT> and <TT>@Untainted</TT> can be used for many purposes</H2><!--SEC END --><P>The <TT>@Tainted</TT> and <TT>@Untainted</TT> annotations have only minimal
built-in semantics. In fact, the Tainting Checker provides only a small
amount of functionality beyond the Basic Checker
(Section&#XA0;<A HREF="#basic-checker">13</A>). This lack of hard-coded behavior means that
the annotations can serve many different purposes. Here are just a few
examples:</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Prevent SQL injection attacks: <TT>@Tainted</TT> is external input,
<TT>@Untainted</TT> has been checked for SQL syntax.
</LI><LI CLASS="li-itemize">Prevent cross-site scripting attacks: <TT>@Tainted</TT> is external input,
<TT>@Untainted</TT> has been checked for JavaScript syntax.
</LI><LI CLASS="li-itemize">Prevent information leakage: <TT>@Tainted</TT> is secret data, 
<TT>@Untainted</TT> may be displayed to a user.
</LI></UL><P>In each case, you need to annotate the appropriate untainting/sanitization
routines. This is similar to the <TT>@Encrypted</TT> annotation
(Section&#XA0;<A HREF="#encrypted-example">13.2</A>), where the cryptographic functions are
beyond the reasoning abilities of the type system. In each case, the type
system verifies most of your code, and the <TT>@SuppressWarnings</TT>
annotations indicate the few places where human attention is needed.</P><P>If you want more specialized semantics, or you want to annotate multiple
types of tainting in a single program, then you can copy the definition of
the Tainting Checker to create a new annotation and checker with a more
specific name and semantics. See Chapter&#XA0;<A HREF="#writing-a-checker">19</A> for more
details.</P><HR><!--TOC chapter Linear checker for preventing aliasing-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="linear-checker">Chapter&#XA0;10</A>&#XA0;&#XA0;Linear checker for preventing aliasing</H1><!--SEC END --><P>The Linear Checker implements type-checking for a linear type system. A
linear type system prevents aliasing: there is only one (usable) reference
to a given object at any time. Once a reference appears on the right-hand
side of an assignment, it may not be used any more. The same rule applies
for pseudo-assignments such as procedure argument-passing (including as the
receiver) or return.</P><P>One way of thinking about this is that a reference can only be used once,
after which it is &#X201C;used up&#X201D;. This property is checked statically at
compile time. The single-use property only applies to use in an
assignment, which makes a new reference to the object; ordinary field
dereferencing does not use up a reference.</P><P>By forbidding aliasing, a linear type system can prevent problems such as
unexpected modification (by an alias), or ineffectual modification (after a
reference has already been passed to, and used by, other code).</P><P>To run the Linear Checker, supply the <TT>-processor
checkers.Linear.LinearChecker</TT> command-line option to javac.</P><P>Figure&#XA0;<A HREF="#fig:linear-example">10.1</A> gives an example of the Linear Checker&#X2019;s rules.</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<PRE CLASS="verbatim">class Pair {
  Object a;
  Object b;
  public String toString() {
    return "&lt;" + String.valueOf(a) + "," + String.valueOf(b) + "&gt;";
  }
}

void print(@Linear Object arg) {
  System.out.println(arg);
}

@Linear Pair printAndReturn(@Linear Pair arg) {
  System.out.println(arg.a);
  System.out.println(arg.b);      // OK: field dereferencing does not use up the reference arg
  return arg;
}

@Linear Object m(Object o, @Linear Pair lp) {
  @Linear Object lo2 = o;         // ERROR: aliases may exist
  @Linear Pair lp3 = lp;          
  @Linear Pair lp4 = lp;          // ERROR: reference lp was already used
  lp3.a;                            
  lp3.b;                          // OK: field dereferencing does not use up the reference
  print(lp3);
  print(lp3);                     // ERROR: reference lp3 was already used
  lp3.a;                          // ERROR: reference lp3 was already used
  @Linear Pair lp4 = new Pair(...);
  lp4.toString();
  lp4.toString();                 // ERROR: reference lp4 was already used
  lp4 = new Pair();               // OK to reassign to a used-up reference
  // If you need a value back after passing it to a procedure, that
  // procedure must return it to you.
  lp4 = printAndReturn(lp4);
  if (...) {
    print(lp4);
  }
  if (...) {
    return lp4;                   // ERROR: reference lp4 may have been used
  } else {
    return new Object();
  }
}
</PRE><DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 10.1: Example of Linear Checker rules.</TD></TR>
</TABLE></DIV>
<A NAME="fig:linear-example"></A>
<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><!--TOC section Linear annotations-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="linear-annotations">10.1</A>&#XA0;&#XA0;Linear annotations</H2><!--SEC END --><P>The linear type system uses one user-visible annotation:
<TT>@</TT><A HREF="doc/checkers/linear/quals/Linear.html"><TT>Linear</TT></A>. The annotation indicates
a type for which each value may only have a single reference &#X2014;
equivalently, may only be used once on the right-hand side of an
assignment.</P><P>The full qualifier hierarchy for the linear type system includes three
types:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<TT>@UsedUp</TT> is the type of references whose object has been assigned to
another reference. The reference may not be used in any way, including
having its fields dereferenced, being tested for equality with <TT>==</TT>, or
being assigned to another reference. Users never need to write this
qualifier.
</LI><LI CLASS="li-itemize"><TT>@Linear</TT> is the type of references that have no aliases, and that may
be dereferenced at most once in the future. The type of <TT>new </TT><TT><EM>T</EM></TT><TT>()</TT> is
<TT>@Linear </TT><TT><EM>T</EM></TT> (the analysis does not account for the slim
possibility that an alias to <TT>this</TT> escapes the constructor).
</LI><LI CLASS="li-itemize"><TT>@NonLinear</TT> is the type of references that may be dereferenced, and
aliases made, as many times as desired. This is the default, so users only
need to write <TT>@NonLinear</TT> if they change the default.
</LI></UL><P><TT>@UsedUp</TT> is a supertype of <TT>@NonLinear</TT>, which is a
supertype of <TT>@Linear</TT>.</P><P>This hierarchy makes an assignment like</P><PRE CLASS="verbatim">  @Linear Object l = new Object();
  @NonLinear Object nl = l;
  @NonLinear Object nl2 = nl;
</PRE><P>legal. In other words, the fact that an object is referenced by a
<TT>@Linear</TT> type means that there is only one usable reference to it <EM>now</EM>,
not that there will <EM>never</EM> be multiple usable references to it.
(The latter guarantee would be possible to enforce, but it is not what the
Linear Checker does.)</P><!--TOC section Limitations-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="linear-limitations">10.2</A>&#XA0;&#XA0;Limitations</H2><!--SEC END --><P>The <TT>@Linear</TT> annotation is supported and checked only on method
parameters (including the receiver), return types, and local variables.
Supporting <TT>@Linear</TT> on fields would require a sophisticated alias
analysis or type system, and is future work.
</P><P>No annotated libraries are provided for linear types. Most libraries would
not be able to use linear types in their purest form. For example, you
cannot put a linearly-typed object in a hashtable, because hashtable
insertion calls <TT>hashCode</TT>; <TT>hashCode</TT> uses up the reference and does not
return the object, even though it does not retain any pointers to the
object. For similar reasons, a collection of linearly-typed objects could
not be sorted or searched.</P><P>Our lightweight implementation is intended for use in the parts of your
program where errors relating to aliasing and object reuse are most likely.
You can use manual reasoning (and possibly an unchecked cast or warning
suppression) when objects enter or exit those portions of your program, or
when that portion of your program uses an unannotated library.</P><HR><!--TOC chapter Regex checker for regular expression syntax-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="regex-checker">Chapter&#XA0;11</A>&#XA0;&#XA0;Regex checker for regular expression syntax</H1><!--SEC END --><P>The Regex Checker prevents, at compile-time, use of syntactically invalid
regular expressions.</P><P>A regular expression, or regex, is a pattern for matching certain strings
of text. In Java, a programmer writes a regular expression as a string.
At run time, the string is &#X201C;compiled&#X201D; into an efficient internal form
(<A HREF="http://download.oracle.com/javase/6/docs/api/java/util/regex/Pattern.html"><TT>Pattern</TT></A>) that is used for
text-matching.</P><P>The syntax of regular expressions is complex, so it is easy to make a
mistake. It is also easy to accidentally use a regex feature from another
language that is not supported by Java (see section &#X201C;Comparison to Perl
5&#X201D; in the <A HREF="http://download.oracle.com/javase/6/docs/api/java/util/regex/Pattern.html"><TT>Pattern</TT></A> Javadoc).
Ordinarily, the programmer does not learn of these errors until run time.
The Regex checker warns about these problems at compile time.</P><P>To run the Regex Checker, supply the <TT>-processor
checkers.regex.RegexChecker</TT> command-line option to javac.</P><!--TOC section Regex annotations-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="regex-annotations">11.1</A>&#XA0;&#XA0;Regex annotations</H2><!--SEC END --><P>The Regex Checker uses one annotation only:
<TT>@</TT><A HREF="doc/checkers/regex/quals/Regex.html"><TT>Regex</TT></A>, to indicate valid regular
expression <TT>String</TT>s.</P><P>The checker implicitly adds the <TT>Regex</TT> qualifier to any
<TT>String</TT> literal that is a valid regex.</P><HR><!--TOC chapter Property file checker-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="propkey-checker">Chapter&#XA0;12</A>&#XA0;&#XA0;Property file checker</H1><!--SEC END --><P>The property file checker ensures that a property file or resource bundle (both
of which act like maps from keys to values) is only accessed with valid keys.
Accesses without a valid key either return <TT>null</TT> or a default value, which
can lead to a <TT>NullPointerException</TT> or hard-to-trace behavior.
The property file checker (Section <A HREF="#genpropkey-checker">12.1</A>) ensures
that the used keys are found in the corresponding property file or resource
bundle.</P><P>We also provide two specialized checkers.
An internationalization checker (Section <A HREF="#i18n-checker">12.2</A>)
verifies that code is properly internationalized.
A compiler message key checker (Section <A HREF="#compilermsgs-checker">12.3</A>)
verifies that compiler message keys used in the Checker Framework are
declared in a property file;
This is an example of a simple specialization of the property
file checker, and the Checker Framework source code shows how it is used.</P><P>It is easy to customize the property key checker for other related purposes.
Take a look at the source code of the compiler message key checker and adapt it for
your purposes.</P><!--TOC section Generic property file checker-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="genpropkey-checker">12.1</A>&#XA0;&#XA0;Generic property file checker</H2><!--SEC END --><P>The generic property file checker ensures that a resource key is located
in a specified property file or resource bundle.</P><P>The annotation <TT>@</TT><A HREF="doc/checkers/propkey/quals/PropertyKey.html"><TT>PropertyKey</TT></A>
indicates that the qualified <TT>String</TT> is a valid key
found in the property file or resource bundle.
You do not need to annotate <TT>String</TT> literals.
The checker looks up every <TT>String</TT> literal in the specified
property file or resource bundle, and adds annotations as appropriate.</P><P>If you pass a <TT>String</TT> variable to be eventually used as a key, you
also need to annotate all these variables with <TT>@PropertyKey</TT>.</P><P>The checker can be invoked by running the following
command:</P><PRE CLASS="verbatim">  javac -processor checkers.propkey.PropertyKeyChecker
        -Abundlenames=MyResource MyFile.java ...
</PRE><P>You must specify the resources, which map keys to strings.
The checker supports two types of resource:
resource bundles and property files. You can specify one or both of the
following two command-line options:</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate"><TT>-Abundlenames=</TT><TT><EM>resource_name</EM></TT><P><EM>resource_name</EM> is the name of the resource to be used with
<A HREF="http://download.oracle.com/javase/6/docs/api/java/util/ResourceBundle.html#getBundle(java.lang.String, java.util.Locale, java.lang.ClassLoader)"><TT>ResourceBundle.getBundle()</TT></A>.
The checker uses the default <TT>Locale</TT> and <TT>ClassLoader</TT> in the
compilation system.
(For a tutorial about <TT>ResourceBundle</TT>s, see
<A HREF="http://java.sun.com/developer/technicalArticles/Intl/ResourceBundles/"><TT>http://java.sun.com/developer/technicalArticles/Intl/ResourceBundles/</TT></A>.)
Multiple resource bundle names are separated by colons &#X2019;<TT>:</TT>&#X2019;.</P></LI><LI CLASS="li-enumerate"><TT>-Apropfiles=</TT><TT><EM>prop_file</EM></TT><P><EM>prop_file</EM> is the name of a properties file that maps
keys to values. The file format is described in
the Javadoc for 
<A HREF="http://download.oracle.com/javase/6/docs/api/java/util/Properties.html#load(java.io.Reader)"><TT>Properties.load()</TT></A>.
Multiple files are separated by colons &#X2019;<TT>:</TT>&#X2019;.</P></LI></OL><!--TOC section Internationalization checker-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="i18n-checker">12.2</A>&#XA0;&#XA0;Internationalization checker</H2><!--SEC END --><P>The Internationalization Checker verifies that your code is properly
internationalized. Internationalization is the process of adapting
software to different languages and locales. Internationalization is
sometimes called localization (though the terms are not
identical), and is sometimes called i18n (because the word starts with &#X201C;i&#X201D;,
ends with &#X201C;n&#X201D;, and has 18 characters in between; localization is similarly
sometimes abbreviated as l10n).</P><P>The checker focuses on one aspect of internationalization: user-visible strings
should be presented in the user&#X2019;s own language, such as English, French, or
German. This is achieved by looking up keys in a localization resource,
which maps keys to user-visible strings. For instance, one version of a
resource might map <TT>"CANCEL_STRING"</TT> to
<TT>"Cancel"</TT>, and another version of the same resource might map
<TT>"CANCEL_STRING"</TT> to <TT>"Abbrechen"</TT>.</P><P>There are other aspects to localization, such as formatting of dates (3/5
vs.&#XA0;5/3 for March 5), that the checker does not check.</P><P>The Internationalization Checker verifies these two properties:</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">Any user-visible text should be obtained from a localization resource.
For example, <TT>String</TT> literals should not be output to the user.</LI><LI CLASS="li-enumerate">When looking up keys in a localization resource, the key should exist in
that resource. This check catches incorrect or misspelled localization
keys.</LI></OL><!--TOC subsection Internationalization annotations-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->12.2.1&#XA0;&#XA0;Internationalization annotations<A NAME="i18n-annotations"></A></H3><!--SEC END --><P>The Internationalization Checker supports two annotations:</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>@</TT><A HREF="doc/checkers/i18n/quals/Localized.html"><TT>Localized</TT></A>: indicates that the qualified
<TT>String</TT> is a message that has been localized and/or formatted with
respect to the used locale.</LI><LI CLASS="li-enumerate"><TT>@</TT><A HREF="doc/checkers/i18n/quals/LocalizableKey.html"><TT>LocalizableKey</TT></A>: indicates that the
qualified <TT>String</TT> or <TT>Object</TT> is a valid key found in the
localization resource.
This annotation is a specialization of the <TT>@PropertyKey</TT> annotation, that
gets checked by the generic property key checker.
</LI></OL><P>You may need to add the <TT>@Localized</TT> annotation to more methods in the
JDK or other libraries, or in your own code.</P><!--TOC subsection Running the Internationalization Checker-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->12.2.2&#XA0;&#XA0;Running the Internationalization Checker<A NAME="i18n-running"></A></H3><!--SEC END --><P>The Internationalization Checker can be invoked by running the following
command:</P><PRE CLASS="verbatim">  javac -processor checkers.i18n.I18nChecker -Abundlenames=MyResource MyFile.java ...
</PRE><P>You must specify the localization resource, which maps keys to user-visible
strings. Like the generic property key checker, the internationalization checker
supports two types of localization resource:
<TT>ResourceBundle</TT>s using the 
<TT>-Abundlenames=</TT><TT><EM>resource_name</EM></TT> option
or property files using the
<TT>-Apropfiles=</TT><TT><EM>prop_file</EM></TT> option.</P><!--TOC section Compiler Message Key checker-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="compilermsgs-checker">12.3</A>&#XA0;&#XA0;Compiler Message Key checker</H2><!--SEC END --><P>The Checker Framework uses compiler message keys to output error messages.
These keys are substituted by localized strings for user-visible error messages.
Using keys instead of the localized strings in the source code enables easier
testing, as the expected error keys can stay unchanged while the localized
strings can still be modified. 
We use the compiler message key checker to ensure that all internal
keys are correctly localized.
Instead of using the property file checker, we use a specialized checker,
giving us more precise documentation of the intended use of <TT>String</TT>s.</P><P>The single annotation used by this checker is 
<TT>@</TT><A HREF="doc/checkers/compilermsgs/quals/CompilerMessageKey.html"><TT>CompilerMessageKey</TT></A>.
The Checker Framework is completely annotated;
for example, class <TT>checkers.source.Result</TT>
uses <TT>@CompilerMessageKey</TT> in methods <TT>failure</TT> and <TT>warning</TT>.
For most users of the Checker Framework there will be no need to annotate any
<TT>String</TT>s, as the checker looks up all <TT>String</TT> literals and adds
annotations as appropriate.</P><P>The compiler message key checker can be invoked by running the following
command:</P><PRE CLASS="verbatim">  javac -processor checkers.compilermsgs.CompilerMessagesChecker
        -Apropfiles=messages.properties MyFile.java ...
</PRE><P>You must specify the resource, which maps compiler message keys to user-visible
strings. The checker supports the same options as the generic property key checker.
Within the Checker Framework we only use property files,
so the <TT>-Apropfiles=</TT><TT><EM>prop_file</EM></TT> option should be used.

</P><HR><!--TOC chapter Basic checker-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="basic-checker">Chapter&#XA0;13</A>&#XA0;&#XA0;Basic checker</H1><!--SEC END --><P>The Basic checker enforces only subtyping rules. It operates over
annotations specified by a user on the command line. Thus, users can
create a simple type checker without writing any code beyond definitions of
the type qualifier annotations.</P><P>The Basic checker can accommodate all of the type system enhancements that
can be declaratively specified (see Chapter&#XA0;<A HREF="#writing-a-checker">19</A>).
This includes type introduction rules (implicit
annotations, e.g., literals are implicitly considered <TT>@</TT><A HREF="doc/checkers/nullness/quals/NonNull.html"><TT>NonNull</TT></A>) via
the <TT>@</TT><A HREF="doc/checkers/quals/ImplicitFor.html"><TT>ImplicitFor</TT></A> meta-annotation, and other features such as
flow-sensitive type qualifier inference (Section&#XA0;<A HREF="#type-refinement">16.3.2</A>) and
qualifier polymorphism (Section&#XA0;<A HREF="#qualifier-polymorphism">16.1.2</A>).</P><P>The Basic checker is also useful to type system designers who wish to
experiment with a checker before writing code; the Basic checker
demonstrates the functionality that a checker inherits from the Checker
Framework.</P><P>If you need typestate analysis, then you can extend a typestate checker,
much as you would extend the Basic Checker if you do not need typestate
analysis. For more details (including a definition of &#X201C;typestate&#X201D;), see
Chapter&#XA0;<A HREF="#typestate-checker">14</A>.</P><P>For type systems that require special checks (e.g., warning about
dereferences of possibly-null values), you will need to write code and
extend the framework as discussed in Chapter&#XA0;<A HREF="#writing-a-checker">19</A>.</P><!--TOC section Using the Basic checker-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="basic-using">13.1</A>&#XA0;&#XA0;Using the Basic checker</H2><!--SEC END --><P>The Basic checker is used in the same way as other checkers (using the
<TT>-processor checkers.basic.BasicChecker</TT> option; see Chapter&#XA0;<A HREF="#using-a-checker">2</A>), except that it
requires an additional annotation processor argument via the standard
&#X201C;<TT>-A</TT>&#X201D; switch:</P><UL CLASS="itemize"><LI CLASS="li-itemize"><TT>-Aquals</TT>: this option specifies a comma-no-space-separated list of
the fully-qualified class
names of the annotations used as qualifiers in the custom type system.
It serves the same purpose as the <TT>@</TT><A HREF="doc/checkers/quals/TypeQualifiers.html"><TT>TypeQualifiers</TT></A>
annotation used by other checkers (see section
<A HREF="#writing-compiler-interface">19.6</A>).<P>The annotations listed in <TT>-Aquals</TT> must be accessible to
the compiler during compilation in the classpath. In other words, they must
already be compiled before you run the Basic checker with <TT>javac</TT>; it
is not sufficient to supply their source files on the command line.</P></LI></UL><P>To suppress a warning issued by the basic checker, use a 
<TT>@</TT><A HREF="http://download.oracle.com/javase/6/docs/api/java/lang/SuppressWarnings.html"><TT>SuppressWarnings</TT></A>
annotation, with the argument being the unqualified, uncapitalized name of
any of the annotations passed to <TT>-Aquals</TT>.</P><!--TOC section Basic checker example-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="encrypted-example">13.2</A>&#XA0;&#XA0;Basic checker example<A NAME="basic-example"></A></H2><!--SEC END --><P>Consider a hypothetical <TT>Encrypted</TT> type qualifier, which denotes that the
representation of an object (such as a <TT>String</TT>, <TT>CharSequence</TT>, or
<TT>byte[]</TT>) is encrypted. To use the Basic checker for the <TT>Encrypted</TT>
type system, follow three steps.</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
Define an annotation for the <TT>Encrypted</TT> qualifier:<PRE CLASS="verbatim">package myquals;

import checkers.quals.*;

/**
 * Denotes that the representation of an object is encrypted.
 * ...
 */
@TypeQualifier
@SubtypeOf(Unqualified.class)
@Target({ElementType.TYPE_PARAMETER, ElementType.TYPE_USE})
public @interface Encrypted {}
</PRE><P>Don&#X2019;t forget to compile this class:</P><PRE CLASS="verbatim">$ javac myquals/Encrypted.java
</PRE><P>The resulting <TT>.class</TT> file should either be on your classpath, or on the
processor path (set via the <TT>-processorpath</TT> command-line option to javac).</P></LI><LI CLASS="li-enumerate">Write <TT>@Encrypted</TT> annotations in your program (YourProgram.java):<PRE CLASS="verbatim">import myquals.Encrypted;

...

public @Encrypted String encrypt(String text) {
    // ...
}

// Only send encrypted data!
public void sendOverInternet(@Encrypted String msg) {
    // ...
}

void sendText() {
    // ...
    @Encrypted String ciphertext = encrypt(plaintext);
    sendOverInternet(ciphertext);
    // ...
}

void sendPassword() {
    String password = getUserPassword();
    sendOverInternet(password);
}
</PRE><P>You may also need to add <TT>@SuppressWarnings</TT> annotations to the
<TT>encrypt</TT> and <TT>decrypt</TT> methods. Analyzing them is beyond the
capability of any realistic type system.</P></LI><LI CLASS="li-enumerate">Invoke the compiler with the Basic checker, specifying the
<TT>@Encrypted</TT> annotation using the <TT>-Aquals</TT> option.
You should add the <TT>Encrypted</TT> classfile to the processor classpath:<PRE CLASS="verbatim">$ javac -processorpath myqualspath -processor checkers.basic.BasicChecker \
        -Aquals=myquals.Encrypted YourProgram.java

YourProgram.java:42: incompatible types.
found   : java.lang.String
required: @myquals.Encrypted java.lang.String
    sendOverInternet(password);
                     ^
</PRE></LI></OL><HR><!--TOC chapter Typestate checker-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="typestate-checker">Chapter&#XA0;14</A>&#XA0;&#XA0;Typestate checker</H1><!--SEC END --><P>In a regular type system, a variable has the same type throughout its
scope.
In a typestate system, a variable&#X2019;s type can change as operations
are performed on it.</P><P>The most common example of typestate is for a <TT>File</TT> object. Assume a file
can be in two states, <TT>@Open</TT> and <TT>@Closed</TT>. Calling the <TT>close()</TT> method
changes the file&#X2019;s state. Any subsequent attempt to read, write, or close
the file will lead to a run-time error. It would be better for the type
system to warn about such problems, or guarantee their absence, at compile
time.</P><P>Just as you can extend the Basic Checker to create a type checker, you can
extend a typestate checker to create a type checker that supports typestate
analysis. Two extensible typestate analyses that build on the Checker
Framework are available. One is by Adam Warski:
<A HREF="http://www.warski.org/typestate.html"><TT>http://www.warski.org/typestate.html</TT></A>.
The other is by Daniel Wand:
<A HREF="http://typestate.ewand.de/"><TT>http://typestate.ewand.de/</TT></A>.</P><!--TOC section Comparison to flow-sensitive type refinement-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="typestate-vs-type-refinement">14.1</A>&#XA0;&#XA0;Comparison to flow-sensitive type refinement</H2><!--SEC END --><P>The Checker Framework&#X2019;s flow-sensitive type refinement
(Section&#XA0;<A HREF="#type-refinement">16.3.2</A>) implements a form of typestate analysis.
For example, after code that tests a variable against null, the Nullness
Checker (Chapter&#XA0;<A HREF="#nullness-checker">3</A>) treats the variable&#X2019;s type as
<TT>@NonNull </TT><TT><EM>T</EM></TT>, for some <TT><EM>T</EM></TT>.</P><P>For many type systems, flow-sensitive type refinement is sufficient. But
sometimes, you need full typestate analysis. This section compares the
two. (Dependent types and unused variables
(Section&#XA0;<A HREF="#unused-fields-and-dependent-types">16.2</A>) also have similarities
with typestate analysis and can occasionally substitute for it. For
brevity, this discussion omits them.)</P><P>A typestate analysis is easier for a user to create or extend.
Flow-sensitive type refinement is built into the Checker Framework and is
optionally extended by each checker. Modifying the rules requires writing
Java code in your checker. By contrast, it is possible to write a simple
typestate checker declaratively, by writing annotations on the methods
(such as <TT>close()</TT>) that change a reference&#X2019;s typestate.</P><P>A typestate analysis can change a reference&#X2019;s type to something that is not
consistent with its original definition. For example, suppose that a
programmer decides that the <TT>@Open</TT> and <TT>@Closed</TT> qualifiers are
incomparable &#X2014; neither is a subtype of the other. A typestate analysis
can specify that the <TT>close()</TT> operation converts an <TT>@Open File</TT> into a
<TT>@Closed File</TT>. By contrast, flow-sensitive type refinement can only give
a new type that is a subtype of the declared type &#X2014; for flow-sensitive
type refinement to be effective, <TT>@Closed</TT> would need to be a child of
<TT>@Open</TT> in the qualifier hierarchy (and <TT>close()</TT> would need to be
treated specially by the checker).</P><HR><!--TOC chapter External checkers-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="external-checkers">Chapter&#XA0;15</A>&#XA0;&#XA0;External checkers</H1><!--SEC END --><P>The checker framework has been used to build other checkers that are not
distributed together with the framework.</P><P>If you want a reference to your checker included in this chapter,
send us a link and short description of your checker, </P><!--TOC section Units and dimensions checker-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="units-checker">15.1</A>&#XA0;&#XA0;Units and dimensions checker</H2><!--SEC END --><P>A checker for units and dimensions is available at
<A HREF="http://www.lexspoon.org/expannots/"><TT>http://www.lexspoon.org/expannots/</TT></A>.</P><HR><!--TOC chapter Advanced type system features-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="advanced-type-system-features">Chapter&#XA0;16</A>&#XA0;&#XA0;Advanced type system features</H1><!--SEC END --><P>This section describes features that are automatically supported by every
checker written with the Checker Framework.
You may wish to skim or skip this section on first reading. After you have
used a checker for a little while and want to be able to express more
sophisticated and useful types, or to understand more about how the Checker
Framework works, you can return to it.</P><!--TOC section Polymorphism and generics-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="polymorphism">16.1</A>&#XA0;&#XA0;Polymorphism and generics</H2><!--SEC END --><!--TOC subsection Generics (parametric polymorphism or type polymorphism)-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->16.1.1&#XA0;&#XA0;Generics (parametric polymorphism or type polymorphism)<A NAME="generics"></A></H3><!--SEC END --><P>The Checker Framework fully supports
type-qualified Java generic types (also known in the research literature as &#X201C;parametric
polymorphism&#X201D;). Before running any checker, we recommend that you eliminate
raw types from your code (e.g., your code should use <TT>List&lt;...&gt;</TT> as
opposed to <TT>List</TT>).
Using generics helps prevent type errors just as using a pluggable
type-checker does.
</P><P>When instantiating a generic type,
clients supply the qualifier along with the type argument, as in
<TT>List&lt;@NonNull String&gt;</TT>.</P><!--TOC paragraph Restricting instantiation of a generic class-->
<H5 CLASS="paragraph"><!--SEC ANCHOR -->Restricting instantiation of a generic class</H5><!--SEC END --><P>There are two ways to restrict the type qualifiers that may be used on
the actual type argument when instantiating a generic class.</P><P>The first technique is the standard Java approach of using the
<TT>extends</TT> or <TT>super</TT> clause to supply an upper or lower bound.
For example:</P><PRE CLASS="verbatim">  MyClass&lt;T extends @NonNull Object&gt; { ... }

  MyClass&lt;@NonNull String&gt; m1;       // OK
  MyClass&lt;@Nullable String&gt; m2;      // error
</PRE><P>The second technique is to write a type annotation on the declaration of a
generic type parameter, which specifies the exact annotation that is
required on the actual type argument, rather than just a bound. For example:</P><PRE CLASS="verbatim">  class MyClassNN&lt;@NonNull T&gt; { ... }
  class MyClassNble&lt;@Nullable T&gt; { ... }

  MyClassNN&lt;@NonNull Number&gt; v1;     // OK
  MyClassNN&lt;@Nullable Number&gt; v2;    // error
  MyClassNble&lt;@NonNull Number&gt; v4;   // error
  MyClassNble&lt;@Nullable Number&gt; v3;  // OK
</PRE><P>A way to view a type annotation on a generic type parameter declaration is
as syntactic sugar for the annotation on both the <TT>extends</TT> and the
<TT>super</TT> clauses of the declaration. For example, these two declarations
have the same effect:</P><PRE CLASS="verbatim">  class MyClassNN&lt;@NonNull T&gt; { ... }
  class MyClassNN&lt;T extends @NonNull Object super @NonNull void&gt; { ... }
</PRE><P>except that the latter is not legal Java syntax. The syntactic sugar is
necessary for two reasons: it is illegal to specify both the upper and the
lower bound, and it is impossible to specify a type annotation for a lower
bound without also specifying a type (use of <TT>void</TT> is illegal).</P><P>If a type parameter declaration is annotated with <TT>@A</TT>, and a bound is
also given, then the annotation applies everywhere that there is no
explicit annotation. For example, the following pairs of declarations are
identical.</P><PRE CLASS="verbatim">  class MyClassNN&lt;@A T&gt; { ... }
  class MyClassNN&lt;T extends @A Object super @A void&gt; { ... }

  class MyClassNN&lt;@A T extends Number&gt; { ... }
  class MyClassNN&lt;T extends @A Number super @A void&gt; { ... }

  class MyClassNN&lt;@A T extends @B Number&gt; { ... }
  class MyClassNN&lt;T extends @B Number super @A void&gt; { ... }

  class MyClassNN&lt;@A T super Number&gt; { ... }
  class MyClassNN&lt;T extends @A Object super @A Number&gt; { ... }

  class MyClassNN&lt;@A T super @B Number&gt; { ... }
  class MyClassNN&lt;T extends @A Object super @B Number&gt; { ... }
</PRE><P>Note that these types mean different things:
</P><PRE CLASS="verbatim">  class MyList1&lt;T extends @Nullable Object&gt; { ... }
  class MyList2&lt;@NonNull T&gt; { ... }
</PRE><P>Consider the implementation of the list (in the ellipsis). The
implementation of <TT>MyList2</TT> may only place non-null objects in the
list and may assume that retrieved elements are non-null. The
implementation of <TT>MyList1</TT> is similar in that it may only place
non-null objects in the list, because it might be instantiated as, say,
<TT>MyList1&lt;@NonNull Date&gt;</TT>. When retrieving elements from the list,
the implementation of <TT>MyList1</TT> must account for the fact that
elements of <TT>MyList1</TT> may be null, because it might be instantiated
as, say, <TT>MyList1&lt;@Nullable Date&gt;</TT>.
The differences are more
significant when the qualifier hierarchy is more complicated than just
<TT>@Nullable</TT> and <TT>@NonNull</TT>.</P><!--TOC paragraph Defaults for bounds-->
<H5 CLASS="paragraph"><!--SEC ANCHOR -->Defaults for bounds</H5><!--SEC END --><P>
Ordinarily, a type parameter declaration with no extends clause means the
type parameter can be instantiated with any type argument at all. For
example:</P><PRE CLASS="verbatim">  class C&lt;T&gt; { ... }
  class C&lt;T extends Object&gt; { ... }  // identical to previous line
</PRE><P>However, instantiation may be restricted if a default qualifier is in
effect (see Section&#XA0;<A HREF="#defaults">16.3.1</A>). For example, the Nullness checker
(Chapter&#XA0;<A HREF="#nullness-checker">3</A>) uses a (configurable) default of
<TT>@NonNull</TT> (see Section&#XA0;<A HREF="#null-defaults">3.2.2</A>). That means that either
declaration above is interpreted as</P><PRE CLASS="verbatim">  class C&lt;T extends @NonNull Object&gt; { ... }
</PRE><P>and an instantiation such as <TT>C&lt;@Nullable Number&gt;</TT> is illegal.
In such a case, to permit all type arguments, the programmer would write</P><PRE CLASS="verbatim">  class C&lt;T extends @Nullable Object&gt; { ... }
</PRE><P>It is possible to set the default qualifier for upper bounds separately
from other default qualifiers, by writing an annotation such as
<TT>@DefaultQualifier(value="Nullable", locations=</TT><TT>DefaultLocation.UPPER_BOUNDS</TT><TT>)</TT>.</P><!--TOC paragraph Type annotations on a use of a generic type variable-->
<H5 CLASS="paragraph"><!--SEC ANCHOR -->Type annotations on a use of a generic type variable</H5><!--SEC END --><P>A type annotation on a generic type variable overrides/ignores any type
qualifier (in the same type hierarchy) on the corresponding actual type
argument. For example, suppose that <TT>T</TT> is a formal type parameter.
Then using <TT>@Nullable T</TT> within the scope of <TT>T</TT> applies the type
qualifier <TT>@Nullable</TT> to the (unqualified) Java type of <TT>T</TT>.</P><P>Here is an example of applying a type annotation to a generic type
variable:</P><PRE CLASS="verbatim">  class MyClass2&lt;T&gt; {
    ...
    @Nullable T = null;
    ...
  }
</PRE><P>The type annotation does not restrict how <TT>MyClass2</TT> may be instantiated
(only the optional <TT>extends</TT> clause on the declaration of type
variable <TT>T</TT> would do so). In other words, both
<TT>MyClass2&lt;@NonNull String&gt;</TT> and <TT>MyClass2&lt;@Nullable String&gt;</TT> are
legal, and in both cases <TT>@Nullable T</TT> means <TT>@Nullable String</TT>.
In <TT>MyClass2&lt;@Interned String&gt;</TT>,
<TT>@Nullable T</TT> means <TT>@Nullable @Interned String</TT>.</P><!--TOC subsection Qualifier polymorphism-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->16.1.2&#XA0;&#XA0;Qualifier polymorphism<A NAME="qualifier-polymorphism"></A></H3><!--SEC END --><P>The Checker Framework also supports type <EM>qualifier</EM> polymorphism for
methods, which permits a single method to have multiple different qualified
type signatures.</P><P>To <EM>define</EM> a polymorphic qualifier, mark the definition with
<TT>@</TT><A HREF="doc/checkers/quals/PolymorphicQualifier.html"><TT>PolymorphicQualifier</TT></A>. For example,
<TT>@</TT><A HREF="doc/checkers/nullness/quals/PolyNull.html"><TT>PolyNull</TT></A> is a polymorphic type
qualifier for the Nullness type system:</P><PRE CLASS="verbatim">  @PolymorphicQualifier
  @Target(ElementType.TYPE_USE)
  public @interface PolyNull { }
</PRE><P>To <EM>use</EM> a polymorphic qualifier, just write it on a type.
For example, you can write <TT>@PolyNull</TT> anywhere that you would write
<TT>@NonNull</TT> or <TT>@Nullable</TT>.</P><P>A method written using a polymorphic qualifier conceptually has multiple
versions, somewhat like a template in C++ or the generics feature of Java.
In each version, each instance of the polymorphic qualifier has been
replaced by the same other qualifier from the hierarchy. See the examples
below in Section&#XA0;<A HREF="#qualifier-polymorphism-examples">16.1.2</A>.</P><P>The method body must type-check with all signatures. A method call is
type-correct if it type-checks under any one of the signatures. If a call
matches multiple signatures, then the compiler uses the most specific
matching signature for the purpose of type-checking. This is just like
Java&#X2019;s rule for resolving overriding methods, though there is no effect on
run-time dispatch or behavior.</P><P>Polymorphic qualifiers can be used on a method signature or body.
They may not be used on classes or fields.</P><!--TOC paragraph Examples of using polymorphic qualifiers-->
<H5 CLASS="paragraph"><!--SEC ANCHOR -->Examples of using polymorphic qualifiers<A NAME="qualifier-polymorphism-examples"></A></H5><!--SEC END --><P>As an example of the use of <TT>@PolyNull</TT>, method <A HREF="http://download.oracle.com/javase/6/docs/api/java/lang/Class.html#cast(java.lang.Object)"><TT>Class.cast</TT></A>
returns null if and only if its argument is <TT>null</TT>:</P><PRE CLASS="verbatim">  @PolyNull T cast(@PolyNull Object obj) { ... }
</PRE><P>This is like writing:</P><PRE CLASS="verbatim">   @NonNull T cast( @NonNull Object obj) { ... }
  @Nullable T cast(@Nullable Object obj) { ... }
</PRE><P>except that the latter is not legal Java, since it defines two
methods with the same Java signature.</P><P>As another example, consider</P><PRE CLASS="verbatim">  @PolyNull T max(@PolyNull T x, @PolyNull T y);
</PRE><P>which is like writing</P><PRE CLASS="verbatim">   @NonNull T max( @NonNull T x,  @NonNull T y);
  @Nullable T max(@Nullable T x, @Nullable T y);
</PRE><P>Another way of thinking about which one of the two <TT>max</TT> variants is
selected is that the nullness annotations of (the declared types of) both
arguments are <EM>unified</EM> to a type that is a supertype of both, also
known as the <EM>least upper bound</EM> or lub. If both
arguments are <TT>@NonNull</TT>, their unification (lub) is <TT>@NonNull</TT>, and the
method return type is <TT>@NonNull</TT>. But if even one of the arguments is <TT>@Nullable</TT>,
then the unification (lub) is <TT>@Nullable</TT>, and so is the return type.</P><!--TOC paragraph Use multiple polymorphic qualifiers in a method signature-->
<H5 CLASS="paragraph"><!--SEC ANCHOR -->Use multiple polymorphic qualifiers in a method signature<A NAME="qualifier-polymorphism-multiple-qualifiers"></A></H5><!--SEC END --><P>Usually, it does not make sense to write only a single instance of a polymorphic
qualifier in a method definition: if you write one instance of (say)
<TT>@PolyNull</TT>, then you should use at least two. (An exception is a
polymorphic qualifier on an array element type; this section ignores that
case, but see below for further details.)</P><P>For example, there is no point to writing</P><PRE CLASS="verbatim">  void m(@PolyNull Object obj)
</PRE><P>which expands to</P><PRE CLASS="verbatim">  void m(@NonNull Object obj)
  void m(@Nullable Object obj)
</PRE><P>This is no different (in terms of which calls to the method will
type-check) than writing just</P><PRE CLASS="verbatim">  void m(@Nullable Object obj)
</PRE><P>The benefit of polymorphic qualifiers comes when one is used multiple times
in a method, since then each instance turns into the same type qualifier.
Most frequently, the polymorphic qualifier appears on at least one formal
parameter and also on the return type. It can also be useful to have
polymorphic qualifiers on (only) multiple formal parameters, especially if
the method side-effects one of its arguments.
For example, consider</P><PRE CLASS="verbatim">void moveBetweenStacks(Stack&lt;@PolyNull Object&gt; s1, Stack&lt;@PolyNull Object&gt; s2) {
  s1.push(s2.pop());
}
</PRE><P>In this example, if it is acceptable to rewrite your code to use Java
generics, the code can be even cleaner:</P><PRE CLASS="verbatim">&lt;T&gt; void moveBetweenStacks(Stack&lt;T&gt; s1, Stack&lt;T&gt; s2) {
  s1.push(s2.pop());
}
</PRE><!--TOC paragraph Using a single polymorphic qualifier on an element type-->
<H5 CLASS="paragraph"><!--SEC ANCHOR -->Using a single polymorphic qualifier on an element type<A NAME="qualifier-polymorphism-element-types"></A></H5><!--SEC END --><P>There is an exception to the general rule that a polymorphic qualifier
should be used multiple times in a signature. It can make sense to use a
polymorphic qualifier just once, if it is on an array or generic element
type.</P><P>For example, consider a routine that returns the first index, in an array
or collection, of a given element:</P><PRE CLASS="verbatim">  public static int indexOf(@PolyNull Object[] a, Object elt) { ... }

  public static int indexOf(Collection&lt;@PolyNull Object&gt; a, Object elt) { ... }
</PRE><P>If <TT>@PolyNull</TT> were replaced with either <TT>@Nullable</TT> or <TT>@NonNull</TT>, then
some safe client calls would be rejected.</P><P>Of course, it would be better style to use a generic method, as in either
of these signatures (and likewise for the <TT>Collection</TT> version):</P><PRE CLASS="verbatim"> public static &lt;T&gt; int indexOf(T[] a, /*@Nullable*/ Object elt) { ... }
 public static &lt;T&gt; int indexOf(T[] a, T elt) { ... }
</PRE><P>In conclusion, use of a single polymorphic qualifier may be necessary in
legacy code, but can be avoided by use of better code style.</P><!--TOC section Unused fields and dependent types-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="unused-fields-and-dependent-types">16.2</A>&#XA0;&#XA0;Unused fields and dependent types</H2><!--SEC END --><P>Sometimes, the type of a field depends on the qualifier on the receiver.
The Checker Framework supports two varieties of such a field: a field that
may not be used if the receiver has a given qualifier, and a fields whose
qualifier changes based on the qualifier of the receiver.
(Also see the discussion of typestate checkers, in
Chapter&#XA0;<A HREF="#typestate-checker">14</A>.)</P><!--TOC subsection Unused fields-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->16.2.1&#XA0;&#XA0;Unused fields<A NAME="unused-fields"></A></H3><!--SEC END --><P>A Java subtype can have more fields than its supertype. You can simulate
the same effect for type qualifiers: a given field may not be accessed via
a reference with a supertype qualifier, but can be accessed via a reference
with a subtype qualifier.</P><P>This permits you to restrict use of a field to certain contexts.</P><P>The <TT>@</TT><A HREF="doc/checkers/quals/Unused.html"><TT>Unused</TT></A> annotation
on a field declares that the field may not be accessed via a receiver of
the given qualified type (or any supertype).</P><!--TOC subsection Dependent types-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->16.2.2&#XA0;&#XA0;Dependent types<A NAME="dependent-types"></A></H3><!--SEC END --><P>A variable has a <EM>dependent type</EM> if its type depends on some other
value or type.
</P><P>The Checker Framework supports a form of dependent types, via the
<TT>@</TT><A HREF="doc/checkers/quals/Dependent.html"><TT>Dependent</TT></A> annotation.
This annotation changes the type of a field or variable, based on the
qualified type of the receiver (<TT>this</TT>). This can be viewed as a more
expressive form of polymorphism (see Section&#XA0;<A HREF="#polymorphism">16.1</A>). It can
also be seen as a way of linking the meanings of two type qualifier
hierarchies.</P><P>When the <TT>@</TT><A HREF="doc/checkers/quals/Unused.html"><TT>Unused</TT></A> annotation is sufficient, you
should use it instead of <TT>@Dependent</TT>.</P><!--TOC subsection Example-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->16.2.3&#XA0;&#XA0;Example<A NAME="dependent-types-example"></A></H3><!--SEC END --><P>Suppose we have a class <TT>Person</TT> and a field <TT>spouse</TT> that is
non-<TT>null</TT> if the person is married. We could declare this as</P><PRE CLASS="verbatim">  class Person {
    ...
    // non-null if this person is married
    @Nullable Person spouse;
    ...
  }
</PRE><P>Now, suppose that we have defined the qualifier hierarchy in which
<TT>@Single</TT> (meaning &#X201C;not married&#X201D;) is a supertype of <TT>@Married</TT>.
A more informative declaration for <TT>Person</TT> would be</P><PRE CLASS="verbatim">  class Person {
    ...
    @Nullable @Dependent(result=NonNull.class, when=Married.class) Person spouse;
    ...
  }
</PRE><P>If a person is known to be <TT>@Married</TT>, the
<TT>spouse</TT> field is known to be non-<TT>null</TT>:</P><PRE CLASS="verbatim">  class Person {
    ...

    void celebrateWeddingAnniversary() @Married {
      System.out.println("Happy anniversary, "
                         + spouse.toString()); // no possible null pointer exception
    }

    ...
  }
</PRE><P>Without the <TT>@</TT><A HREF="doc/checkers/quals/Dependent.html"><TT>Dependent</TT></A> annotation on the
declaration of the <TT>spouse</TT> variable, the Nullness Checker would
complain that <TT>toString</TT> was invoked on a possibly-<TT>null</TT>
value.</P><P>An even better declaration is</P><PRE CLASS="verbatim">  class Person {
    ...
    @Unused(when=Single.class) @NonNull Person spouse;
    ...
  }
</PRE><P>Then, if a person is known to be <TT>@Married</TT> (or more
appropriately non-<TT>@Single</TT>), the <TT>spouse</TT> field is known to
be non-<TT>null</TT>. Also, if a person is known to be <TT>@Single</TT>,
the <TT>spouse</TT> field may not be accessed:</P><PRE CLASS="verbatim">  @Single Person person = ...;
  Person spouse = person.spouse;  // invalid field access
  ...
</PRE><!--TOC section The effective qualifier on a type (defaults and inference)-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="effective-qualifier">16.3</A>&#XA0;&#XA0;The effective qualifier on a type (defaults and inference)</H2><!--SEC END --><P>A checker sometimes treats a type as having a slightly different qualifier
than what is written on the type &#X2014; especially if the programmer wrote no
qualifier at all.
Most readers can skip this section on first reading, because you will
probably find the system simply &#X201C;does what you mean&#X201D;, without forcing
you to write too many qualifiers in your program.
In particular, qualifiers in method bodies are extremely rare.</P><P>The following steps determine the effective
qualifier on a type &#X2014; the qualifier that the checkers treat as being present.</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
The type system adds implicit qualifiers. Implicit qualifiers can be
built into a type system (Section&#XA0;<A HREF="#writing-type-introduction">19.4</A>), in
which case the type system&#X2019;s documentation should explain all of the type
system&#X2019;s implicit qualifiers. Or, a programmer may introduce an implicit
annotation on each use of class <I>C</I> by writing a qualifier on the
declaration of class <I>C</I>.<UL CLASS="itemize"><LI CLASS="li-itemize">
Example 1 (built-in): In the Nullness type system,
<TT>enum</TT> values are never null, nor is a method receiver.
</LI><LI CLASS="li-itemize">Example 2 (built-in): In the Interning type system, string literals
and <TT>enum</TT> values are always interned.
</LI></UL></LI><LI CLASS="li-enumerate">If a type qualifier is present in the source code, that qualifier is used.<P>If the type has an implicit qualifier, then it is an error to write an
explicit qualifier that is equal to (redundant with) or a supertype of
(weaker than) the implicit qualifier. A programmer may strengthen
(write a subtype of) an implicit qualifier, however.</P></LI><LI CLASS="li-enumerate">If there is no implicit or explicit qualifier on a type, then a default
qualifier may be applied; see Section&#XA0;<A HREF="#defaults">16.3.1</A>.<P><BR>
</P><P>At this point, every type has a qualifier.</P></LI><LI CLASS="li-enumerate">The type system may refine a qualified type on a local variable &#X2014; that
is, treat it as a subtype of how it was declared or defaulted. This
refinement is always sound and has the effect of eliminating false
positive error messages. See Section&#XA0;<A HREF="#type-refinement">16.3.2</A>.</LI></OL><!--TOC subsection Default qualifier for unannotated types-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->16.3.1&#XA0;&#XA0;Default qualifier for unannotated types<A NAME="defaults"></A></H3><!--SEC END --><P>A type system designer, or an end-user programmer, can cause unannotated
references to be treated as if they had a default annotation.</P><P>There are several defaulting mechanisms, for convenience and flexibility.
When determining the default qualifier for a use of a type, the following
rules are used in order, until one applies.
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Use the innermost user-written <TT>@DefaultQualifier</TT>, as explained in
this section.
</LI><LI CLASS="li-itemize">Use the default specified by the type system designer
(Section&#XA0;<A HREF="#typesystem-defaults">19.3.3</A>).
</LI><LI CLASS="li-itemize">Use <TT>@</TT><A HREF="doc/checkers/quals/Unqualified.html"><TT>Unqualified</TT></A>, which the framework
inserts to avoid ambiguity and simplify the programming interface for
type system designers. Users do not have to worry about this detail,
but type system implementers can rely on the fact that some
qualifier is present.
</LI></UL><P>The end-user programmer specifies a default qualifier by writing the <TT>@</TT><A HREF="doc/checkers/quals/DefaultQualifier.html"><TT>DefaultQualifier</TT></A>
annotation on a package, class, method, or variable declaration. The
argument to <TT>@</TT><A HREF="doc/checkers/quals/DefaultQualifier.html"><TT>DefaultQualifier</TT></A> is the <TT>String</TT>
name of an annotation. It may be a short name like <TT>"NonNull"</TT>, if an
appropriate import statement exists. Otherwise, it should be
fully-qualified, like <TT>"checkers.nullness.quals.NonNull"</TT>.
The optional second argument indicates where the default
applies. If the second argument is omitted, the specified annotation is
the default in all locations. See the Javadoc of <A HREF="doc/checkers/quals/DefaultQualifier.html"><TT>DefaultQualifier</TT></A> for details.</P><P>For example, using the Nullness type system (Chapter&#XA0;<A HREF="#nullness-checker">3</A>):</P><PRE CLASS="verbatim">import checkers.quals.*;        // for DefaultQualifier[s]
import checkers.nullness.quals.NonNull;

@DefaultQualifier("NonNull"),
class MyClass {

  public boolean compile(File myFile) { // myFile has type "@NonNull File"
    if (!myFile.exists())          // no warning: myFile is non-null
      return false;
    @Nullable File srcPath = ...;  // must annotate to specify "@Nullable File"
    ...
    if (srcPath.exists())          // warning: srcPath might be null
      ...
  }

  @DefaultQualifier("Mutable")
  public boolean isJavaFile(File myfile) {  // myFile has type "@Mutable File"
    ...
  }
}
</PRE><P>If you wish to write multiple
<TT>@</TT><A HREF="doc/checkers/quals/DefaultQualifier.html"><TT>DefaultQualifier</TT></A> annotations at a single location,
use
<TT>@</TT><A HREF="doc/checkers/quals/DefaultQualifiers.html"><TT>DefaultQualifiers</TT></A> instead. For example:</P><PRE CLASS="verbatim">@DefaultQualifiers({
  @DefaultQualifier("NonNull"),
  @DefaultQualifier("Mutable")
})
</PRE><P>If <TT>@DefaultQualifier</TT>[<TT>s</TT>] is placed on a package (via the
<TT>package-info.java</TT> file), then it applies to the given package <EM>and</EM>
all subpackages.
</P><P>Recall that an annotation on a class definition indicates an implicit
qualifier (Section&#XA0;<A HREF="#effective-qualifier">16.3</A>) that can only be
strengthened, not weakened. This can lead to unexpected results if
the default qualifier applies to a class definition. Thus, you may want to
put explicit qualifiers on class declarations (which prevents the default
from taking effect), or exclude class declarations from defaulting.</P><P>When a programmer omits an <TT>extends</TT> clause at a declaration of a type
parameter, the default still applies to the implicit upper bound. For
example, consider these two declarations:</P><PRE CLASS="verbatim">  class C&lt;T&gt; { ... }
  class C&lt;T extends Object&gt; { ... }  // identical to previous line
</PRE><P>The two declarations are treated identically by Java, and the default
qualifier applies to the <TT>Object</TT> upper bound whether it is implicit or
explicit. (The @NonNull default annotation applies only to the upper bound
in the <TT>extends</TT> clause, not to the lower bound in the inexpressible
implicit <TT>super void</TT> clause.)</P><!--TOC subsection Automatic type refinement (flow-sensitive type qualifier inference)-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->16.3.2&#XA0;&#XA0;Automatic type refinement (flow-sensitive type qualifier inference)<A NAME="type-refinement"></A></H3><!--SEC END --><P>In order to reduce the burden of annotating types in your program, the
checkers soundly treat certain variables and expressions as having a
subtype of their declared or defaulted (Section&#XA0;<A HREF="#defaults">16.3.1</A>)
type. This functionality
never introduces unsoundness or causes an error to be missed: it merely
suppresses false positive warnings.</P><P>By default, all checkers, including new checkers that you write, can take
advantage of this functionality. Most of the time, users don&#X2019;t have to
think about, and may not even notice, this feature of the framework. The
checkers simply do the right thing even when a programmer forgets an
annotation on a local variable, or when a programmers writes an
unnecessarily general type in a declaration.</P><P>If you are curious or want more details about this feature, then read on.</P><P>As an example, the Nullness checker (Chapter&#XA0;<A HREF="#nullness-checker">3</A>) can automatically
determine that certain variables are non-null, even if they were explicitly
or by default annotated as nullable.
The checker treats a variable or expression as <TT>@</TT><A HREF="doc/checkers/nullness/quals/NonNull.html"><TT>NonNull</TT></A>
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
starting at the time that it is either
assigned a non-null value or checked against null (e.g., via an assertion,
<TT>if</TT> statement, or being dereferenced)
</LI><LI CLASS="li-itemize">until it might be re-assigned (e.g.,
via an assignment that might affect this variable, or via a method call
that might affect this variable).
</LI></UL><P>As with explicit annotations, the implicitly non-null types permit
dereferences and assignments to non-null types, without
compiler warnings.</P><P>Consider this code, along with comments indicating whether the
Nullness checker (Chapter&#XA0;<A HREF="#nullness-checker">3</A>) issues a warning. Note that the same expression may yield a
warning or not depending on its context.</P><PRE CLASS="verbatim">  // Requires an argument of type @NonNull String
  void parse(@NonNull String toParse) { ... }

  // Argument does NOT have a @NonNull type
  void lex(@Nullable String toLex) {
    parse(toLex);        // warning:  toLex might be null
    if (toLex != null) {
      parse(toLex);      // no warning:  toLex is known to be non-null
    }
    parse(toLex);        // warning:  toLex might be null
    toLex = new String(...);
    parse(toLex);        // no warning:  toLex is known to be non-null
  }
</PRE><P>If you find examples where you think a value should be inferred to have
(or not have) a
given annotation, but the checker does not do so, please submit a bug
report (see Section&#XA0;<A HREF="#reporting-bugs">22.2</A>) that includes a small piece of
Java code that reproduces the problem.</P><P>Type inference is never performed for method parameters of non-private
methods and for non-private fields, because unknown client code could use
them in arbitrary ways. The inferred information is never written to the
<TT>.class</TT> file as user-written annotations are.</P><P>The inference indicates when a variable can be treated as having a subtype
of its declared type &#X2014; for instance, when an otherwise nullable type can be
treated as a <TT>@</TT><A HREF="doc/checkers/nullness/quals/NonNull.html"><TT>NonNull</TT></A> one. The inference never treats a variable as
a supertype of its declared type (e.g., an expression of <TT>@</TT><A HREF="doc/checkers/nullness/quals/NonNull.html"><TT>NonNull</TT></A>
type is never inferred to be treated as possibly-null).</P><!--TOC subsection Fields and flow sensitivity analysis-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->16.3.3&#XA0;&#XA0;Fields and flow sensitivity analysis</H3><!--SEC END --><P>Flow sensitivity analysis infers the type of fields in some restricted cases:</P><UL CLASS="itemize"><LI CLASS="li-itemize">A final initialized field:
Type inference is performed for final fields that are initialized to a
compile-time constant at the declaration site; so the type of <TT>protocol</TT>
is <TT>@NonNull String</TT> in the following declaration:<PRE CLASS="verbatim">    public final String protocol = "https";
</PRE><P>Please note that such inferred type may leak to the public interface of the
class. To override such behavior, you can explicitly insert the desired
annotation, e.g.</P><PRE CLASS="verbatim">    public final @Nullable String protocol = "https";
</PRE></LI><LI CLASS="li-itemize">Within method bodies:
Type inference is performed for fields in the context of method bodies,
like local variables, but method invocations invalidate any inferred
information. Consider the following example, where <TT>name</TT> is a nullable
field:<PRE CLASS="verbatim">class DBObject {
  @Nullable Date updatedAt;

  void update() {
    if (updatedAt == null)
        updatedAt = new Date();
    // updatedAt is nonnull
    log("Updating object at " + updatedAt.getTime());

    persistData();
    // updatedAt is nullable again
    log.debug("Saved object updated at " + updatedAt.getTime()); // invalid!
  }
}
</PRE><P>Here the call to <TT>persistData()</TT> invalidates the inferred non-null type
of <TT>updatedAt</TT>.</P><P>When methods do not modify any object state or have any identity side-effects
(e.g. <TT>log()</TT> method here), you can annotate these methods as
<TT>Pure</TT>. Annotating them as <TT>Pure</TT>, would cause the flow analyzer to
carry the inferred types across the method invocation boundary.</P></LI></UL><!--TOC section Inexpressible types-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="inexpressible-types">16.4</A>&#XA0;&#XA0;Inexpressible types</H2><!--SEC END --><P>The Type Annotations syntax&#XA0;[<A HREF="#jsr308">Ern08</A>] is designed to be easy to read. As a result,
there are types that it cannot express. An example is the type of
<TT>Collection.toArray()</TT>, which returns an array of objects, where the
objects have the same annotation as the elements of the receiver.</P><P>A possible annotation would be</P><PRE CLASS="verbatim">public @Polynull Object [] toArray() ArrayList&lt;@PolyNull E&gt; { ... }
</PRE><P>except that this is illegal syntax: &#X201C;<TT>ArrayList&lt;@PolyNull E&gt;</TT>&#X201D; is
not legal in the receiver position. (This is a motivation for
<A HREF="http://types.cs.washington.edu/jsr308/specification/java-annotation-design.html#receiver-type-parameter-annotations">extending</A>
the Type Annotations syntax.)</P><P>The annotated libraries (Section&#XA0;<A HREF="#annotating-libraries">18</A>) contain a less-precise annotation for
<TT>toArray</TT>. The Nullness Checker special-cases <TT>toArray</TT> to
act as if it had the above annotation. The cases that
are currently being handled are described in
<A HREF="doc/checkers/nullness/CollectionToArrayHeuristics.html"><TT>CollectionToArrayHeuristics</TT></A>.
This approach would be possible for other checkers and other methods as the
need arises.</P><HR><!--TOC chapter Handling warnings and legacy code-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="warnings-and-legacy">Chapter&#XA0;17</A>&#XA0;&#XA0;Handling warnings and legacy code</H1><!--SEC END --><P>Section&#XA0;<A HREF="#get-started-with-legacy-code">2.4.1</A> describes a methodology for
applying annotations to legacy code. This chapter tells you what to do if,
for some reason, you cannot change your code in such a way as to eliminate
a checker warning.</P><!--TOC section Checking partially-annotated programs: handling unannotated code-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="unannotated-code">17.1</A>&#XA0;&#XA0;Checking partially-annotated programs: handling unannotated code</H2><!--SEC END --><P>Sometimes, you wish to type-check only part of your program.
You might focus on the most mission-critical or error-prone part of your
code. When you start to use a checker, you may not wish to annotate
your entire program right away.
You may not have
enough knowledge to annotate poorly-documented libraries that your program uses.</P><P>If annotated code uses unannotated code, then the checker may issue
warnings. For example, the Nullness checker (Chapter&#XA0;<A HREF="#nullness-checker">3</A>) will
warn whenever an unannotated method result is used in a non-null context:</P><PRE CLASS="verbatim">  @NonNull myvar = unannotated_method();   // WARNING: unannotated_method may return null
</PRE><P>If the call <EM>can</EM> return null, you should fix the bug in your program by
removing the <TT>@</TT><A HREF="doc/checkers/nullness/quals/NonNull.html"><TT>NonNull</TT></A> annotation in your own program.</P><P>If the library call <EM>never</EM> returns null,
there are several ways to eliminate the compiler warnings.
</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
Annotate <TT>unannotated_method</TT> in full. This approach provides
the strongest guarantees, but may require you to annotate additional
methods that <TT>unannotated_method</TT> calls. See
Chapter&#XA0;<A HREF="#annotating-libraries">18</A> for a discussion of how to annotate
libraries for which you have no source code.
</LI><LI CLASS="li-enumerate">Annotate only the signature of <TT>unannotated_method</TT>, and
suppress warnings in its body. Two ways to suppress the warnings are via a
<TT>@SuppressWarnings</TT> annotation or by not running the checker on that
file (see Section&#XA0;<A HREF="#suppressing-warnings">17.2</A>).
</LI><LI CLASS="li-enumerate">Suppress all warnings related to uses of <TT>unannotated_method</TT>
via the <TT>skipClasses</TT> processor option
(see Section&#XA0;<A HREF="#suppressing-warnings">17.2</A>).
Since this can suppress more warnings than you may expect,
it is usually better to annotate at least the method&#X2019;s signature. If you
choose the boundary between the annotated and unannotated code wisely,
then you only have to annotate the signatures of a limited number of
classes/methods
(e.g., the public interface to a library or package).</LI></OL><P>Chapter&#XA0;<A HREF="#annotating-libraries">18</A> discusses adding annotations to
signatures when you do not have source code available.
Section&#XA0;<A HREF="#suppressing-warnings">17.2</A> discusses suppressing warnings.</P><P>If you annotate a third-party library, please share it with us so that we
can distribute the annotations with the Checker Framework; see
Section&#XA0;<A HREF="#reporting-bugs">22.2</A>.</P><!--TOC section Suppressing warnings-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="suppressing-warnings">17.2</A>&#XA0;&#XA0;Suppressing warnings</H2><!--SEC END --><P>You may wish to suppress checker warnings because of unannotated libraries
or un-annotated portions of your own code, because of application
invariants that are beyond the capabilities of the type system, because of
checker limitations, because you are interested in only some of the
guarantees provided by a checker, or for other reasons. You can suppress
warnings via
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
the <TT>@SuppressWarnings</TT> annotation,
</LI><LI CLASS="li-itemize">the <TT>-AskipClasses</TT> command-line option,
</LI><LI CLASS="li-itemize">the javac <TT>-Alint</TT> command-line option,
</LI><LI CLASS="li-itemize">not using the <TT>-processor</TT> switch to <TT>javac</TT>, or
</LI><LI CLASS="li-itemize">checker-specific mechanisms.
</LI></UL><P>We now explain these mechanisms in turn.</P><P>You can suppress specific errors and warnings by use of the
<TT>@SuppressWarnings("</TT><TT><EM>checkername</EM></TT><TT>")</TT> annotation, for example
<TT>@SuppressWarnings("interning")</TT> or <TT>@SuppressWarnings("nullness")</TT>.
This may be placed on program elements such as a local
variable declaration, a method, or a class. For instance, one common use is
to suppress warnings at a cast that you know is safe. Here is an example
that uses the Tainting Checker (Section&#XA0;<A HREF="#tainting-checker">9</A>):</P><PRE CLASS="verbatim">  @SuppressWarnings("tainting")
  String myvar = (@Untainted String) expr;  // expr has type: @Tainted String
</PRE><P>It is good practice to suppress warnings in the
smallest possible scope. For example, if a particular expression causes a
false positive warning, you should extract that expression into a local variable
and place a <TT>@SuppressWarnings</TT> annotation on the variable
declaration.
As another example, if you have annotated the signatures but not the bodies
of the methods in a class or package, put a <TT>@SuppressWarnings</TT>
annotation on the class declaration or on the package&#X2019;s
<TT>package-info.java</TT> file.</P><P>You can suppress all errors and warnings at all <EM>uses</EM> of a given
class (but the class itself is still type-checked).
Set the <TT>-AskipClasses</TT> command-line option to a
regular expression that matches classes for which warnings and errors
should be suppressed. For example, if you use
&#X201C;<CODE>-AskipClasses=^java\.</CODE>&#X201D; on the command line
(with appropriate quoting) when invoking
<TT>javac</TT>, then the checkers will suppress all warnings within
classes whose fully-qualified name starts with <CODE>java.</CODE>, all
warnings relating to invalid arguments, and all warnings relating to incorrect
use of the return value.</P><P>To suppress all errors and warnings related to multiple classes, you can use
the regular expression alternative operator &#X201C;<TT>|</TT>&#X201D;, as in
&#X201C;<CODE>-AskipClasses="java\.lang\.|java\.util\."</CODE>&#X201D; to suppress
all warnings related to classes belong to the <TT>java.lang</TT> or
<TT>java.util</TT> packages.</P><P><A NAME="lint-options"></A></P><P>The <TT>-Alint</TT> option enables or disables optional checks, analogously to
javac&#X2019;s <TT>-Xlint</TT> option.
Each of the distributed checkers supports at least the following lint options:</P><UL CLASS="itemize"><LI CLASS="li-itemize"><TT>cast:unsafe</TT> (default: on) warn about unsafe casts that are not
checked at run time, as in <TT>((@NonNull String) myref)</TT>. Such casts
are generally not necessary when flow-sensitive local type refinement is
enabled.</LI><LI CLASS="li-itemize"><TT>cast:redundant</TT> (default: on) warn about redundant
casts that are guaranteed to succeed at run time,
as in <TT>((@NonNull String) "m")</TT>. Such casts are not necessary,
because the target expression of the cast already has the given type
qualifier.</LI><LI CLASS="li-itemize"><TT>cast</TT> Enable or disable all cast-related warnings.</LI><LI CLASS="li-itemize"><TT>all</TT> Enable or disable all lint warnings, including
checker-specific ones if any. Examples include <TT>nulltest</TT> for the
Nullness Checker (see Section&#XA0;<A HREF="#lint-nulltest">3</A>) and <TT>dotequals</TT> for
the Interning Checker (see Section&#XA0;<A HREF="#lint-dotequals">4.3</A>). This option
does not enable/disable the checker&#X2019;s standard checks, just its optional
ones.</LI><LI CLASS="li-itemize"><TT>none</TT> The inverse of <TT>all</TT>: disable or enable all lint warnings,
including checker-specifc ones if any.</LI></UL><P>To activate a lint option, write <TT>-Alint=</TT> followed by a
comma-delimited list of check names. If the option is preceded by a
hyphen (<TT>-</TT>), the warning is disabled. For example, to disable all
lint options except redundant casts, you can pass
<TT>-Alint=-all,cast:redundant</TT> on the command line.</P><P>You can also compile parts of your code without use of the
<TT>-processor</TT> switch to <TT>javac</TT>. No checking is done during
such compilations.</P><P>Finally, some checkers have special rules. For example, the Nullness
checker (Chapter&#XA0;<A HREF="#nullness-checker">3</A>) uses <TT>assert</TT> statements that contain
null checks, and the special <TT>castNonNull</TT> method, to suppress warnings
(Section&#XA0;<A HREF="#suppressing-warnings-with-assertions">3.4.1</A>).</P><!--TOC section Writing annotations in comments for backward compatibility-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="annotations-in-comments">17.3</A>&#XA0;&#XA0;Writing annotations in comments for backward compatibility</H2><!--SEC END --><P>Sometimes, your code needs to be compilable by people who are not
using a Java 7 compiler.</P><!--TOC subsection Annotations in comments-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->17.3.1&#XA0;&#XA0;Annotations in comments</H3><!--SEC END --><P>A Java 4 compiler does not permit use of
annotations, and a Java 5 compiler only permits annotations on
declarations (but not on generic arguments, casts, <TT>extends</TT> clauses, method receiver, etc.).</P><P>So that your code can be compiled by any Java compiler (for any version of
the Java language), you may write any annotation inside a
<TT>/*</TT>&#X2026;<TT>*/</TT> Java comment, as in <TT>List&lt;/*@NonNull*/ String&gt;</TT>.
The Type Annotations compiler treats the code exactly as if you had not written the
<TT>/*</TT> and <TT>*/</TT>.
In other words, the Type Annotations compiler will recognize the
annotation, but your code will still compile with any other Java compiler.</P><P>This feature only works if you provide no <TT>-source</TT> command-line
argument to <TT>javac</TT>, or if the <TT>-source</TT> argument is <TT>1.7</TT>
or <TT>7</TT>.</P><P>(<B>Note:</B> This is a feature of the Type Annotations compiler that is
distributed along with the Checker Framework. It is <EM>not</EM> supported by the
mainline OpenJDK compiler, which ignores annotations written in
comments. This is the key difference between the Type Annotations
compiler and the OpenJDK compiler.)
</P><P>In a single program, you may write some annotations in comments, and others
without comments.</P><P>By default, the compiler ignores any comment that contains spaces at the
beginning or end, or between the <TT>@</TT> and the annotation name.
In other words, it reads <TT>/*@NonNull*/</TT> as an annotation but ignores
<TT>/* @NonNull*/</TT> or <TT>/*@ NonNull*/</TT> or <TT>/*@NonNull */</TT>.
This
feature enables backward compatibility with code that contains comments
that start with <TT>@</TT> but are not annotations. (The
ESC/Java&#XA0;[<A HREF="#FlanaganLLNSS02">FLL<SUP>+</SUP>02</A>], JML&#XA0;[<A HREF="#LeavensBR2006:JML">LBR06</A>], and
Splint&#XA0;[<A HREF="#Evans96">Eva96</A>] tools all use &#X201C;<TT>/*@</TT>&#X201D; or &#X201C;<TT>/*&#XA0;@</TT>&#X201D; as a
comment marker.)
Compiler flag
<TT>-XDTA:spacesincomments</TT> causes the compiler to parse annotation comments
even when they contain spaces. You may need to use
<TT>-XDTA:spacesincomments</TT> if you use Eclipse&#X2019;s &#X201C;Source &gt; Correct
Indentation&#X201D; command, since it inserts space in comments. But the
annotation comments are less readable with spaces, so you may wish to disable
inserting spaces: in the Formatter preferences, in the Comments tab,
unselect the &#X201C;enable block comment formatting&#X201D; checkbox.</P><!--TOC subsection Implicit import statements-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->17.3.2&#XA0;&#XA0;Implicit import statements<A NAME="implicit-import-statements"></A></H3><!--SEC END --><P>When writing source code with annotations, it is more convenient to write a
short form such as <TT>@NonNull</TT> instead of
<TT>@checkers.nullness.quals.NonNull</TT>.</P><P>The traditional way to do this is to write an import statement like
&#X201C;<TT>import checkers.nullness.quals.*;</TT>&#X201D;. This works, but everyone who
compiles the code (no matter what compiler they use, and even if the
annotations are in comments) must have the annotation definitions (e.g.,
the <TT>checkers.jar</TT> or <TT>checkers-quals.jar</TT> file) on their
classpath. The reason is that a Java compiler issues an error if an
imported package is not on the classpath. See Section&#XA0;<A HREF="#distributing">2.1.1</A>.</P><P><A NAME="jsr308_imports"></A></P><P>An alternative is to set the shell environment variable
<TT>jsr308_imports</TT> when you compile the code.
The Type Annotations compiler treats this as if the given packages were
imported, but other compilers
ignore the
<TT>jsr308_imports</TT> environment variable &#X2014; they do not need it, since
they do not support annotations in comments. Thus, your code can compile
whether or not the Type Annotations compiler is being used.</P><P>You can specify multiple packages separated by the classpath separator
(same as the file path separator: <TT>;</TT> for Windows, and <TT>:</TT> for Unix and
Mac). For example, to implicitly import the Nullness and Interning
qualifiers, set <TT>jsr308_imports</TT> to
<TT>checkers.nullness.quals.*:checkers.interning.quals.*</TT>.</P><P>If you issue the javac command from the command line or in a Makefile, you
may need to add quotes, to prevent your shell from expanding the <TT>*</TT>
character.
In bash, you could write <TT>export
jsr308_imports=&#X2019;checkers.nullness.quals.*&#X2019;</TT>, or prefix the <TT>javac</TT>
command by <TT>jsr308_imports=&#X2019;checkers.nullness.quals.*&#X2019;</TT> .
Alternately, you can set the environment variable via the javac
command-line argument <TT>-J-Djsr308_imports=&#X2019;checkers.nullness.quals.*&#X2019;</TT>.
If you supply the <TT>-J-Djsr308_imports</TT> argument via an Ant buildfile,
you do not need the extra quoting.</P><!--TOC subsection Migrating away from annotations in comments-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->17.3.3&#XA0;&#XA0;Migrating away from annotations in comments</H3><!--SEC END --><P>Suppose that your codebase currently uses annotations in comments, but you
wish to remove the comment characters around your annotations, because in
the future you will use only Java 7 compilers. This Unix command removes
the comment characters, for all Java files in the current
working directory or any subdirectory.</P><PRE CLASS="verbatim">   find . -type f -name '*.java' -print \
     | xargs grep -l -P '/\*\s*@([^ */]+)\s*\*/' \
     | xargs perl -pi.bak -e 's|/\*\s*@([^ */]+)\s*\*/|@\1|g'
</PRE><P>You can customize this command:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
To process comments with embedded spaces and asterisks, change
two instances of &#X201C;<CODE>[^ */]</CODE>&#X201D; to &#X201C;<CODE>[^/]</CODE>&#X201D;.
</LI><LI CLASS="li-itemize">To ignore comments with leading or trailing spaces, remove the four
instances of &#X201C;<CODE>\s*</CODE>&#X201D;.
</LI><LI CLASS="li-itemize">To not make backups, remove
&#X201C;<CODE>.bak</CODE>&#X201D;.
</LI></UL><P>If you are using implicit import statements
(Section&#XA0;<A HREF="#implicit-import-statements">17.3.2</A>), you may also need to introduce
explicit import statements into your code.</P><HR><!--TOC chapter Annotating libraries-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="annotating-libraries">Chapter&#XA0;18</A>&#XA0;&#XA0;Annotating libraries</H1><!--SEC END --><P>When annotated code uses an unannotated library, a checker may issue warnings.
As described in Section&#XA0;<A HREF="#unannotated-code">17.1</A>, the best way to correct
this problem is to add annotations to the library. (Alternately, you can instead
suppress all warnings related to an unannotated library by use of the
<TT>-AskipClasses</TT> command-line option; see
Section&#XA0;<A HREF="#suppressing-warnings">17.2</A>.) If you have source code for the
library, you can easily add the annotations.
This section tells you
how to add annotations to a library for which you have no source code,
because the library is distributed only in binary (<TT>.class</TT> or
<TT>.jar</TT>) form. This section is also useful if you do not wish to edit the
library&#X2019;s source code.</P><P>The Checker Framework distribution contains annotations
for popular libraries, such as the JDK.
If you annotate additional libraries, please share them with us so that we
can distribute the annotations with the Checker Framework; see
Section&#XA0;<A HREF="#reporting-bugs">22.2</A>.</P><P>You can determine the correct annotations for a library either
automatically by running an inference tool, or manually by reading the
documentation. Presently, type inference tools are available for the
Nullness (Section&#XA0;<A HREF="#nullness-inference">3.2.4</A>) and Javari
(Section&#XA0;<A HREF="#javari-inference">6.2.2</A>) type systems.</P><P>You can make the annotations known to the JSR 308 compiler (and thus
to the checkers) in two ways.</P><UL CLASS="itemize"><LI CLASS="li-itemize">You can use the stub class generation tool to create a &#X201C;stub
file&#X201D; containing classes with no method bodies,
and annotate the stub classes
file. Then, you can supply the stub files to the checker when
compiling/checking your program.
Section&#XA0;<A HREF="#stub">18.1</A> describes how to use the stub class generation
tools.</LI><LI CLASS="li-itemize">You can annotate the compiled
<TT>.jar</TT> or <TT>.class</TT> files using the Annotation File Utilities
(<A HREF="http://types.cs.washington.edu/annotation-file-utilities/"><TT>http://types.cs.washington.edu/annotation-file-utilities/</TT></A>).
First, express the annotations textually as an annotation index file, and
then the tools insert them in the compiled library class files.
See the Annotation File Utilities documentation for full details.</LI></UL><!--TOC section Using stub classes-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="stub-creating-and-using">18.1</A>&#XA0;&#XA0;Using stub classes<A NAME="stub"></A></H2><!--SEC END --><P>A stub file contains &#X201C;stub classes&#X201D; that contain annotated signatures. A
checker uses those annotated signatures at compile time, instead of or in
addition to annotations that appear in the library.</P><P>Section&#XA0;<A HREF="#stub-creating">18.1.1</A> describes how to create stub classes.
Section&#XA0;<A HREF="#stub-using">18.1.2</A> describes how to use stub classes.
These sections illustrate stub classes via the example of creating a <TT>@</TT><A HREF="doc/checkers/interning/quals/Interned.html"><TT>Interned</TT></A>-annotated
version of <TT>java.lang.String</TT>. (You don&#X2019;t need to repeat these steps,
since such a stub class is already included in the Checker Framework
distribution; see file <TT>checkers/src/checkers/interning/jdk.astub</TT>, which
is reproduced in Section&#XA0;<A HREF="#stub-format">18.1.3</A>.)</P><!--TOC subsection Creating a stub file-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->18.1.1&#XA0;&#XA0;Creating a stub file<A NAME="stub-creating"></A></H3><!--SEC END --><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">Create a stub file by running the stub class generator. (<TT>checkers.jar</TT>
must be on your classpath.)<PRE CLASS="verbatim">  cd nullness-stub
  java checkers.util.stub.StubGenerator java.lang.String &gt; String.astub
</PRE><P>Supply it with the fully-qualified name of the class for which you wish to
generate a stub class. The stub class generator prints the
stub class to standard out, so you may wish to redirect its output to a
file.</P></LI><LI CLASS="li-enumerate">Add import statements for the annotations. So you would need to
add the following import statement at the beginning of the file:<PRE CLASS="verbatim">  import checkers.interning.quals.Interned;
</PRE></LI><LI CLASS="li-enumerate">Add annotations to the stub class. For example, you might annotate
the <A HREF="http://download.oracle.com/javase/6/docs/api/java/lang/String.html#intern()"><TT>String.intern()</TT></A> method as follows:<PRE CLASS="verbatim">  @Interned String intern();
</PRE><P>You may also remove irrelevant parts of the stub file; see
Section&#XA0;<A HREF="#stub-format">18.1.3</A>.</P></LI></OL><!--TOC subsection Using a stub file-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->18.1.2&#XA0;&#XA0;Using a stub file<A NAME="stub-using"></A></H3><!--SEC END --><P>When you run <TT>javac</TT> with a given checker/processor, you can specify
a list of the stub files or directories using
<TT>-Astubs=</TT><TT><EM>file_or_path_name</EM></TT>. The stub path entries
are delimited by
<TT>File.pathSeparator</TT> (&#X2018;<TT>:</TT>&#X2019; for Linux and Mac, &#X2018;<TT>;</TT>&#X2019; for Windows).
When you supply a stub directory, the checker only considers the enclosed
stub files whose names end with <TT>.astub</TT>.</P><P>The <TT>-Astubs</TT> argument causes the Checker Framework to read annotations
from annotated stub classes in preference to the unannotated original
library classes.</P><PRE CLASS="verbatim">  javac -processor checkers.interning.InterningChecker -Astubs=String.astub:stubs MyFile.java MyOtherFile.java ...
</PRE><P>Checker and library writers are encouraged to distribute stub files for the
JDK and most commonly used libraries. Section&#XA0;<A HREF="#stub-distribution">18.1.4</A>
explains how to bundle a stub file, such that they get imported automatically.
Programmers should only explicitly specify the stub files they create
themselves.</P><!--TOC subsection Stub file format-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->18.1.3&#XA0;&#XA0;Stub file format<A NAME="stub-format"></A></H3><!--SEC END --><P>The stub file format is designed for simplicity, readability, and
compactness. It reads like a Java file but contains only the
necessary information for type checking.</P><P>As an illustration, the stub file for the Interning type system
(Chapter&#XA0;<A HREF="#interning-checker">4</A>) is as follows. This file appears as
<TT>checkers/src/checkers/interning/jdk.astub</TT> in the Checker Framework
distribution.</P><PRE CLASS="verbatim">  import checkers.interning.quals.Interned;

  package java.lang;

  // All instances of Class are interned.
  @Interned class Class&lt;T&gt; { }

  class String {
    // The only interning-related method in the JDK.
    @Interned String intern();
  }
</PRE><P>You can use a regular Java file as a stub file. Every valid Java file is a
valid stub file. However, you can omit
information that is not relevant to pluggable type-checking; this makes the
stub file smaller and easier for people to read and write. You can also
put annotated signatures for multiple classes in a single stub file.</P><P>The stub file format is allowed to differ from Java source code in the
following ways:
</P><DL CLASS="description"><DT CLASS="dt-description"></DT><DD CLASS="dd-description"><B>Method bodies:</B>
The stub class does not require method bodies for classes; any method
body may be replaced by a semicolon (<TT>;</TT>), as in an interface or
abstract method declaration.</DD><DT CLASS="dt-description"></DT><DD CLASS="dd-description"><B>Method declarations:</B>
You only have to specify the methods that you need to annotate.
Any method declaration may be omitted, in which case the checker reads
its annotations from the library. (If you are using a stub class, then
typically the library&#X2019;s version is unannotated.)</DD><DT CLASS="dt-description"></DT><DD CLASS="dd-description"><B>Declaration specifiers:</B>
Declaration specifiers (e.g., <TT>public</TT>, <TT>final</TT>, <TT>volatile</TT>)
may be omitted, since they have nothing to do with types.</DD><DT CLASS="dt-description"></DT><DD CLASS="dd-description"><B>Import statements:</B>
The only required import statements are the ones to import type
annotations. Such imports must be at the beginning of the
file. Other import statements are optional.</DD><DT CLASS="dt-description"></DT><DD CLASS="dd-description"><B>Multiple classes and packages:</B>
The stub file format permits having multiple classes and packages.
The packages are separated by a package statement:
<TT>package my.package;</TT>. Each package declaration may occur only once; in
other words, all classes from a package must appear together.</DD></DL><!--TOC subsection Distributing stub files-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->18.1.4&#XA0;&#XA0;Distributing stub files<A NAME="stub-distribution"></A></H3><!--SEC END --><P>A distributed stub files doesn&#X2019;t need to be explicitly specified by the
programmer; the checker automatically uses it.</P><P>A checker writer should include the JDK stub file as <TT>jdk.astub</TT> in the
same directory level as the Checker class (i.e., the subclass of
<TT>BaseTypeVisitor</TT>). The Checker Framework imports the <TT>jdk.astub</TT>
automatically.</P><!--TOC subsection Known problems-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->18.1.5&#XA0;&#XA0;Known problems</H3><!--SEC END --><P>The Checker Framework stub file reader has several limitations:</P><UL CLASS="itemize"><LI CLASS="li-itemize">
It does not handle <TT>enum</TT>s.
</LI><LI CLASS="li-itemize">It only handles type annotations, not declaration annotations (e.g. IGJ&#X2019;s <TT>Assignable</TT>).
</LI></UL><!--TOC subsection Style tips for stub files-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->18.1.6&#XA0;&#XA0;Style tips for stub files</H3><!--SEC END --><P>Every Java file is a stub file. If you have access to the Java file, then
it is usually best to use the Java file as the stub file, without removing
any of the parts that the stub file format permits you to. Just add
annotations to the full source code. This approach retains the original
documentation and source code, making it easier for a programmer to
double-check the annotations. It also enables creation of diffs, easing
the process of upgrading when a library adds new methods. And, the
annotations are in a format that the library maintainers can even
incorporate.</P><P>The downside of this approach is that the stub files are larger. This can
slow down parsing. Furthermore, a programmer must search the stub file
for a given method rather than just skimming one or two pages of signatures.</P><P>If you do not have access to the library source code, then you can create a
stub file from the Javadoc or the class file, and then annotate it.</P><!--TOC section Using distributed annotated JDKs-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="skeleton">18.2</A>&#XA0;&#XA0;Using distributed annotated JDKs<A NAME="skeleton-using"></A></H2><!--SEC END --><P>The Checker Framework distribution contains
annotated JDKs at the path <TT>checkers/jdk/jdk.jar</TT>.</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">When you run <TT>javac</TT>, add a <TT>-bootclasspath/p:</TT> argument to indicate
where to find the annotated JDK classes.
Supply <TT>-bootclasspath/p</TT> in addition to whatever other arguments you
usually use, including <TT>-classpath</TT>.<P>The <TT>-bootclasspath/p:</TT> argument causes the compiler to read annotations
from annotated JDK classes in preference to the unannotated original
library classes.</P><PRE CLASS="verbatim">  javac -processor checkers.nullness.NullnessChecker -Xbootclasspath/p:checkers/jdk/jdk.jar my_source_files
</PRE></LI><LI CLASS="li-enumerate">Run the compiled code as usual. The annotated JDK does not need to be
in your classpath at run time.</LI></OL><P>Please note that so far, only three checkers require passing the annotated JDK
explicitly, and they are the Nullness, the Javari, and the IGJ checkers.</P><HR><!--TOC chapter How to create a new checker-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="writing-a-checker">Chapter&#XA0;19</A>&#XA0;&#XA0;How to create a new checker</H1><!--SEC END --><P>This section describes how to create a checker
&#X2014; a type-checking compiler plugin that detects bugs or verifies their
absence. After a programmer annotates a program,
the checker plugin verifies that the code is consistent
with the annotations.
If you only want to <EM>use</EM> a checker, you do not need to read this
section.</P><P>Writing a simple checker is easy! For example, here is a complete, useful
type checker:</P><PRE CLASS="verbatim">@TypeQualifier
@SubtypeOf(Unqualified.class)
@Target({ElementType.TYPE_PARAMETER, ElementType.TYPE_USE})
public @interface Encrypted {}
</PRE><P>This checker is so short because it builds on the Basic Checker
(Chapter&#XA0;<A HREF="#basic-checker">13</A>).
See Section&#XA0;<A HREF="#basic-example">13.2</A> for more details about this particular checker.
When you wish to create a new checker, it is sometimes easiest to begin by
building it declaratively on top of the Basic Checker, and then return to
this chapter when you need more expressiveness or power than the Basic
Checker affords.</P><P>You can also customize a typestate checker, which enables a variable&#X2019;s type
to change &#X2014; for instance, a file might transition from the <TT>@Open</TT> to
the <TT>@Closed</TT> state after the <TT>close()</TT> method is called.
For more details, see Chapter&#XA0;<A HREF="#typestate-checker">14</A>.</P><P>The rest of this section contains many details for people who want to write more powerful
checkers.
You do not need all of the details, at least at first.
In addition to reading this section of the manual, you may find it helpful
to examine the implementations of the checkers that are distributed with
the Checker Framework. You can even create your checker by modifying one
of those.
The Javadoc documentation of the framework and the checkers is in the
distribution and is also available online at
<A HREF="http://types.cs.washington.edu/checker-framework/current/doc/"><TT>http://types.cs.washington.edu/checker-framework/current/doc/</TT></A>.</P><P>If you write a new checker and wish to advertise it to the world, let us
know so we can mention it in the Checker Framework manual, link to
it from the webpages, or include it in the Checker Framework distribution.</P><!--TOC section Relationship of the Checker Framework to other tools-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="tool-relationships">19.1</A>&#XA0;&#XA0;Relationship of the Checker Framework to other tools</H2><!--SEC END --><P>This table shows the relationship among various tools.
All of the tools use the Type Annotations (JSR 308) syntax.
You use the Checker Framework to build pluggable type systems, and the
Annotation File Utilities to manipulate <TT>.java</TT> and <TT>.class</TT> files.</P><DIV CLASS="center">
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1><TR><TD VALIGN=top ALIGN=left><DIV CLASS="center">Nullness </DIV><P>Checker</P></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">Mutation </DIV><P>Checker</P></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">Tainting </DIV><P>Checker</P></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">&#X2026;</DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">Your </DIV><P>Checker</P></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">Type </DIV><P>inference</P></TD><TD VALIGN=top ALIGN=left>Other <P>tools</P></TD></TR>
<TR><TD VALIGN=top ALIGN=left COLSPAN=5><DIV CLASS="center">Checker Framework </DIV><P>(enables creation of pluggable type-checkers)</P></TD><TD VALIGN=top ALIGN=left COLSPAN=2><DIV CLASS="center"><A HREF="http://types.cs.washington.edu/annotation-file-utilities/">Annotation File Utilities</A> </DIV><P>(<TT>.java</TT> &#X2194; <TT>.class</TT> files)</P></TD></TR>
<TR><TD VALIGN=top ALIGN=left COLSPAN=7><DIV CLASS="center"><A HREF="http://types.cs.washington.edu/jsr308/">Type Annotations</A> syntax
and classfile format (&#X201C;JSR 308&#X201D;) </DIV><P>(no built-in semantics)</P></TD></TR>
</TABLE>
</DIV><P>(Strictly speaking, the specific checkers, such as the Nullness Checker, are
built on top of the Basic Checker, which is built on top of the Checker
Framework. The Basic Checker can also be used directly by users.)</P><!--TOC section The parts of a checker-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="parts-of-a-checker">19.2</A>&#XA0;&#XA0;The parts of a checker</H2><!--SEC END --><P>The Checker Framework provides abstract base classes (default
implementations), and a specific checker overrides as little or as much of
the default implementations as necessary.
Sections&#XA0;<A HREF="#writing-typequals">19.3</A>&#X2013;<A HREF="#writing-compiler-interface">19.6</A> describe
the components of a type system as written using the Checker Framework:</P><DL CLASS="description"><DT CLASS="dt-description"></DT><DD CLASS="dd-description"><A HREF="#writing-typequals">19.3</A>
<B>Type qualifiers and hierarchy.</B> You define the annotations for
the type system and the subtyping relationships among qualified types
(for instance, that <TT>@NonNull Object</TT> is a subtype of <TT>@Nullable
Object</TT>).</DD><DT CLASS="dt-description"></DT><DD CLASS="dd-description"><A HREF="#writing-type-introduction">19.4</A>
<B>Type introduction rules.</B> For some types and
expressions, a qualifier should be treated as implicitly present even if a
programmer did not explicitly write it. For example, in the Nullness
type system every literal
other than <TT>null</TT> has a <TT>@</TT><A HREF="doc/checkers/nullness/quals/NonNull.html"><TT>NonNull</TT></A> type;
examples of literals include <TT>"some string"</TT> and <TT>java.util.Date.class</TT>.</DD><DT CLASS="dt-description"></DT><DD CLASS="dd-description"><A HREF="#extending-visitor">19.5</A>
<B>Type rules.</B> You specify the type system semantics (type
rules), violation of which yields a type error. There are two types of
rules.
<UL CLASS="itemize"><LI CLASS="li-itemize">
Subtyping rules related to the type hierarchy, such as that every
assignment and pseudo-assignment satisfies a subtyping relationship.
Your checker automatically inherits these subtyping rules from the Basic
Checker (Chapter&#XA0;<A HREF="#basic-checker">13</A>).
</LI><LI CLASS="li-itemize">Additional rules that are specific to your particular checker. For
example, in the Nullness type system, only references with a
<TT>@</TT><A HREF="doc/checkers/nullness/quals/NonNull.html"><TT>NonNull</TT></A> type may be dereferenced. You
write these additional rules yourself.
</LI></UL></DD><DT CLASS="dt-description"></DT><DD CLASS="dd-description"><A HREF="#writing-compiler-interface">19.6</A>
<B>Interface to the compiler.</B> The compiler interface indicates
which annotations are part of the type system, which command-line options
and <TT>@SuppressWarnings</TT> annotations the checker recognizes, etc.
</DD></DL><!--TOC section Annotations: Type qualifiers and hierarchy-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="writing-typequals">19.3</A>&#XA0;&#XA0;Annotations: Type qualifiers and hierarchy</H2><!--SEC END --><P>A type system designer specifies the qualifiers in the type system and
the type hierarchy that relates them.</P><P>Type qualifiers are defined as Java annotations&#XA0;[<A HREF="#JSR269">Dar06</A>]. In Java, an
annotation is defined using the Java <TT>@interface</TT> keyword.
Write the <TT>@</TT><A HREF="doc/checkers/quals/TypeQualifier.html"><TT>TypeQualifier</TT></A> meta-annotation on the annotation definition
to indicate that the annotation represents a type qualifier
and should be processed by the checker.
Also write a <TT>@</TT><A HREF="http://download.oracle.com/javase/6/docs/api/java/lang/annotation/Target.html"><TT>Target</TT></A>
meta-annotation to indicate where the annotation may be written.
For example:</P><PRE CLASS="verbatim">  // Define an annotation for the @NonNull type qualifier.
  @TypeQualifier
  @Target({ElementType.TYPE_PARAMETER, ElementType.TYPE_USE})
  public @interface NonNull { }
</PRE><P>(An annotation that is written on an annotation
definition, such as <TT>@</TT><A HREF="doc/checkers/quals/TypeQualifier.html"><TT>TypeQualifier</TT></A>, is called a <EM>meta-annotation</EM>.)</P><P>The type hierarchy induced by the qualifiers can be defined either
declaratively via meta-annotations (Section&#XA0;<A HREF="#declarative-hierarchy">19.3.1</A>), or procedurally through
subclassing <A HREF="doc/checkers/types/QualifierHierarchy.html"><TT>QualifierHierarchy</TT></A> or
<A HREF="doc/checkers/types/TypeHierarchy.html"><TT>TypeHierarchy</TT></A> (Section&#XA0;<A HREF="#procedural-hierarchy">19.3.2</A>).</P><!--TOC subsection Declaratively defining the qualifier and type hierarchy-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->19.3.1&#XA0;&#XA0;Declaratively defining the qualifier and type hierarchy<A NAME="declarative-hierarchy"></A></H3><!--SEC END --><P>Declaratively, the type system designer uses two meta-annotations (written
on the declaration of qualifier annotations) to specify the qualifier
hierarchy.</P><UL CLASS="itemize"><LI CLASS="li-itemize"><TT>@</TT><A HREF="doc/checkers/quals/SubtypeOf.html"><TT>SubtypeOf</TT></A> denotes that a qualifier is a subtype of
another qualifier or qualifiers, specified as an array of class
literals. For example, for any type <I>T</I>,
<TT>@</TT><A HREF="doc/checkers/nullness/quals/NonNull.html"><TT>NonNull</TT></A> <I>T</I> is a subtype of <TT>@</TT><A HREF="doc/checkers/nullness/quals/Nullable.html"><TT>Nullable</TT></A> <I>T</I>:<PRE CLASS="verbatim">    @TypeQualifier
    @Target({ElementType.TYPE_PARAMETER, ElementType.TYPE_USE})
    @SubtypeOf( { Nullable.class } )
    public @interface NonNull { }
  </PRE><P><TT>@</TT><A HREF="doc/checkers/quals/SubtypeOf.html"><TT>SubtypeOf</TT></A> accepts multiple annotation classes as an argument,
permitting the type hierarchy to be an arbitrary DAG. For example,
in the IGJ type system (Section&#XA0;<A HREF="#igj-annotations">5.2</A>), <TT>@</TT><A HREF="doc/checkers/igj/quals/Mutable.html"><TT>Mutable</TT></A>
and <TT>@</TT><A HREF="doc/checkers/igj/quals/Immutable.html"><TT>Immutable</TT></A> induce two mutually exclusive subtypes of the
<TT>@</TT><A HREF="doc/checkers/igj/quals/ReadOnly.html"><TT>ReadOnly</TT></A> qualifier.
</P><P>All type qualifiers, except for polymorphic qualifiers (see below and
also Section&#XA0;<A HREF="#qualifier-polymorphism">16.1.2</A>), need to be
properly annotated with <A HREF="doc/checkers/quals/SubtypeOf.html"><TT>SubtypeOf</TT></A>.</P><P>The root qualifier should be annotated with
<TT>@SubtypeOf( { } )</TT>. The root qualifier is the qualifier that is
a supertype of all other qualifiers. For example, <TT>@</TT><A HREF="doc/checkers/nullness/quals/Nullable.html"><TT>Nullable</TT></A>
is the root of the Nullness type system, hence is defined as:</P><PRE CLASS="verbatim">    @TypeQualifier
    @Target({ElementType.TYPE_PARAMETER, ElementType.TYPE_USE})
    @SubtypeOf( { } )
    public @interface Nullable { }
  </PRE><P>If the root of the hierarchy is the unqualified type, then its children
will use <TT>@SubtypeOf(Unqualified.class)</TT>, but no <TT>@SubtypeOf(
{ } )</TT> annotation on the root is necessary. For an example, see the
<TT>Encrypted</TT> type system of Section&#XA0;<A HREF="#encrypted-example">13.2</A>.</P></LI><LI CLASS="li-itemize"><TT>@</TT><A HREF="doc/checkers/quals/PolymorphicQualifier.html"><TT>PolymorphicQualifier</TT></A> denotes that a qualifier is a
polymorphic qualifier. For example:<PRE CLASS="verbatim">    @TypeQualifier
    @Target({ElementType.TYPE_PARAMETER, ElementType.TYPE_USE})
    @PolymorphicQualifier
    public @interface PolyNull { }
  </PRE><P>For a description of polymorphic qualifiers, see
Section&#XA0;<A HREF="#qualifier-polymorphism">16.1.2</A>. A polymorphic qualifier needs
no <TT>@</TT><A HREF="doc/checkers/quals/SubtypeOf.html"><TT>SubtypeOf</TT></A> meta-annotation and need not be
mentioned in any other <TT>@</TT><A HREF="doc/checkers/quals/SubtypeOf.html"><TT>SubtypeOf</TT></A>
meta-annotation.</P></LI></UL><P>The declarative and procedural mechanisms for specifying the hierarchy can
be used together. In particular, when using the <TT>@</TT><A HREF="doc/checkers/quals/SubtypeOf.html"><TT>SubtypeOf</TT></A>
meta-annotation, further customizations may be
performed procedurally (Section&#XA0;<A HREF="#procedural-hierarchy">19.3.2</A>)
by overriding the <A HREF="doc/checkers/basetype/BaseTypeChecker.html#isSubtype(checkers.types.AnnotatedTypeMirror,%20checkers.types.AnnotatedTypeMirror)"><TT>isSubtype</TT></A> method in the checker class
(Section&#XA0;<A HREF="#writing-compiler-interface">19.6</A>).
However, the declarative mechanism is sufficient for most type systems.</P><!--TOC subsection Procedurally defining the qualifier and type hierarchy-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->19.3.2&#XA0;&#XA0;Procedurally defining the qualifier and type hierarchy<A NAME="procedural-hierarchy"></A></H3><!--SEC END --><P>While the declarative syntax suffices for many cases, more complex
type hierarchies can be expressed by overriding, in <A HREF="doc/checkers/basetype/BaseTypeChecker.html"><TT>BaseTypeChecker</TT></A>,
either <A HREF="doc/checkers/basetype/BaseTypeChecker.html#createQualifierHierarchy()"><TT>createQualifierHierarchy</TT></A> or <A HREF="doc/checkers/basetype/BaseTypeChecker.html#createTypeHierarchy()"><TT>createTypeHierarchy</TT></A> (typically
only one of these needs to be overridden).
For more details, see the Javadoc of those methods and of the classes
<A HREF="doc/checkers/types/QualifierHierarchy.html"><TT>QualifierHierarchy</TT></A> and <A HREF="doc/checkers/types/TypeHierarchy.html"><TT>TypeHierarchy</TT></A>.</P><P>The <A HREF="doc/checkers/types/QualifierHierarchy.html"><TT>QualifierHierarchy</TT></A> class represents the qualifier hierarchy (not the
type hierarchy), e.g., <A HREF="doc/checkers/igj/quals/Mutable.html"><TT>Mutable</TT></A>
is a subtype of <A HREF="doc/checkers/igj/quals/ReadOnly.html"><TT>ReadOnly</TT></A>. A type-system designer may subclass
<A HREF="doc/checkers/types/QualifierHierarchy.html"><TT>QualifierHierarchy</TT></A> to express customized qualifier
relationships (e.g., relationships based on annotation
arguments).</P><P>The <A HREF="doc/checkers/types/TypeHierarchy.html"><TT>TypeHierarchy</TT></A> class represents the type hierarchy &#X2014;
that is, relationships between
annotated types, rather than merely type qualifiers, e.g., <TT>@Mutable
Date</TT> is a subtype of <TT>@ReadOnly Date</TT>. The default <A HREF="doc/checkers/types/TypeHierarchy.html"><TT>TypeHierarchy</TT></A> uses
<A HREF="doc/checkers/types/QualifierHierarchy.html"><TT>QualifierHierarchy</TT></A> to determine all subtyping relationships.
The default <A HREF="doc/checkers/types/TypeHierarchy.html"><TT>TypeHierarchy</TT></A> handles
generic type arguments, array components, type variables, and
wildcards in a similar manner to the Java standard subtype
relationship but with taking qualifiers into consideration. Some type
systems may need to override that behavior. For instance, the Java
Language Specification specifies that two generic types are subtypes only
if their type arguments are identical: for example,
<TT>List&lt;Date&gt;</TT> is not a subtype of <TT>List&lt;Object&gt;</TT>, or of any other
generic <TT>List</TT>.
(In the technical jargon, the generic arguments are &#X201C;invariant&#X201D; or &#X201C;novariant&#X201D;.)
The Javari type system overrides this
behavior to allow some type arguments to change covariantly in a type-safe
manner (e.g.,
<TT>List&lt;@Mutable Date&gt;</TT> is a subtype of <TT>List&lt;@QReadOnly Date&gt;</TT>).</P><!--TOC subsection Defining a default annotation-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->19.3.3&#XA0;&#XA0;Defining a default annotation<A NAME="typesystem-defaults"></A></H3><!--SEC END --><P>A type system designer may set a default annotation. A user may override
the default; see Section&#XA0;<A HREF="#defaults">16.3.1</A>.</P><P>The type system designer may specify a default annotation declaratively,
using the <TT>@</TT><A HREF="doc/checkers/quals/DefaultQualifierInHierarchy.html"><TT>DefaultQualifierInHierarchy</TT></A>
meta-annotation.
Note that the default will apply to any source code that the checker reads,
including stub libraries, but will not apply to compiled <TT>.class</TT>
files that the checker reads.</P><P>Alternately, the type system designer may specify a default procedurally,
by calling the
<A HREF="doc/checkers/util/QualifierDefaults.html#setAbsoluteDefaults(javax.lang.model.element.AnnotationMirror,%20java.util.Set)"><TT>QualifierDefaults.setAbsoluteDefaults</TT></A>
method. You may do this even if you have declaratively defined the
qualifier hierarchy; see the Nullness checker&#X2019;s implementation for an
example.</P><P>Recall that defaults are distinct
from implicit annotations; see Sections&#XA0;<A HREF="#effective-qualifier">16.3</A>
and&#XA0;<A HREF="#writing-type-introduction">19.4</A>.</P><!--TOC subsection Completeness of the type hierarchy-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->19.3.4&#XA0;&#XA0;Completeness of the type hierarchy<A NAME="bottom-qualifier"></A><A NAME="top-qualifier"></A></H3><!--SEC END --><!--TOC paragraph Bottom qualifier-->
<H5 CLASS="paragraph"><!--SEC ANCHOR -->Bottom qualifier</H5><!--SEC END --><P>
It is usually a good idea to have a bottom qualifier in your type hierarchy
&#X2014; a qualifier that is a (direct or indirect) subtype of every other
qualifier. For instance, the hierarchy of Figure&#XA0;<A HREF="#fig:igj-hierarchy">5.1</A> lacks
a bottom qualifier, because there is no qualifier that is a subtype of both
<TT>@Immutable</TT> and <TT>@Mutable</TT>.
The bottom qualifier is the natural type for the <TT>null</TT>
value, which can be viewed as having any type at all. Without a bottom
qualifier, type-checking becomes less precise.
Users should never write the bottom qualifier explicitly; it is merely used
for the <TT>null</TT> value.</P><P>The actual IGJ hierarchy contains a (non-user-visible) bottom qualifier,
defined like this:</P><PRE CLASS="verbatim">  @TypeQualifier
  @SubtypeOf({Mutable.class, Immutable.class, I.class})
  @Target({}) // forbids a programmer from writing it in a program
  @ImplicitFor(trees = { Kind.NULL_LITERAL, Kind.CLASS, Kind.NEW_ARRAY },
               typeClasses = { AnnotatedPrimitiveType.class })
  @interface IGJBottom { }
</PRE><!--TOC paragraph Top qualifier-->
<H5 CLASS="paragraph"><!--SEC ANCHOR -->Top qualifier</H5><!--SEC END --><P>
Similarly, it is a good idea to have a top qualifier in your type hierarchy
&#X2014; a qualifier that is a (direct or indirect) supertype of every other
qualifier. For instance, the <TT>@Encrypted</TT> type system of
Section&#XA0;<A HREF="#bottom-qualifier">19.3.4</A> lacks a top qualifier:</P><PRE CLASS="verbatim">  @TypeQualifier
  @SubtypeOf(Unqualified.class)
  @Target({ElementType.TYPE_PARAMETER, ElementType.TYPE_USE})
  public @interface Encrypted {}
</PRE><P>The interning type system of Section&#XA0;<A HREF="#interning-checker">4</A> also lacks a
top qualifier; there is no <TT>@Uninterned</TT> qualifier that is a supertype of 
<TT>@</TT><A HREF="doc/checkers/interning/quals/Interned.html"><TT>Interned</TT></A>.</P><P>When a type system lacks a top qualifier (or any other qualifier), then
users lose flexibility in expressing defaults. In the encryption example
there is no top qualifier, and every type is either unqualified or has the
<TT>@Encrypted</TT> qualifier. Another way of saying this is that the default is
<TT>@Unqualified</TT>. In such a case, it is not sensible for a user to specify
a default for unannotated types via the
<TT>@</TT><A HREF="doc/checkers/quals/DefaultQualifier.html"><TT>DefaultQualifier</TT></A> meta-annotation
(Section&#XA0;<A HREF="#defaults">16.3.1</A>), because there is no argument to pass to it.
<TT>@Unqualified</TT> is not appropriate, because it is not clear which type
system it is intended to refer to.</P><P>The ability to omit the top qualifier is a convenience
when writing a type system, because it reduces the number of qualifiers
that must be defined; this is especially convenient when using the Basic
Checker (Section&#XA0;<A HREF="#basic-checker">13</A>).
Omitting the top qualifier also restricts the user in ways that the type
system designer may have intended.</P><P>However, a type system designer should not frequently omit the top qualifier.
It is better if
the type hierarchy has an explicit qualifier for every
possible meaning. For example, the Nullness type system has
<TT>@</TT><A HREF="doc/checkers/nullness/quals/Nullable.html"><TT>Nullable</TT></A> types and
<TT>@</TT><A HREF="doc/checkers/nullness/quals/NonNull.html"><TT>NonNull</TT></A> types. It has no built-in meaning for
unannotated types; a user may specify a default qualifier.</P><!--TOC section Type factory: Implicit annotations-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="writing-type-introduction">19.4</A>&#XA0;&#XA0;Type factory: Implicit annotations</H2><!--SEC END --><P>For some types and expressions, a qualifier should be treated as present
even if a programmer did not explicitly write it. For example, every
literal (other than <TT>null</TT>) has a <TT>@</TT><A HREF="doc/checkers/nullness/quals/NonNull.html"><TT>NonNull</TT></A> type.</P><P>The implicit annotations may be specified declaratively and/or procedurally.</P><!--TOC subsection Declaratively specifying implicit annotations-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->19.4.1&#XA0;&#XA0;Declaratively specifying implicit annotations<A NAME="declarative-type-introduction"></A></H3><!--SEC END --><P>The <TT>@</TT><A HREF="doc/checkers/quals/ImplicitFor.html"><TT>ImplicitFor</TT></A> meta-annotation indicates implicit annotations.
When written on a qualifier, <A HREF="doc/checkers/quals/ImplicitFor.html"><TT>ImplicitFor</TT></A>
specifies the trees (AST nodes) and types for which the framework should
automatically add that qualifier.</P><P>In short, the types and trees can be
specified via any combination of five fields:</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<TT>trees</TT>: an array of
<A HREF="http://download.oracle.com/javase/7/docs/jdk/api/javac/tree/com/sun/source/tree/Tree.Kind.html?is-external=true"><TT>com.sun.source.tree.Tree.Kind</TT></A>, e.g.,
<TT>NEW_ARRAY</TT> or <TT>METHOD_INVOCATION</TT>
</LI><LI CLASS="li-itemize"><TT>types</TT>: an array of
<A HREF="http://download.oracle.com/javase/7/docs/api/javax/lang/model/type/TypeKind.html?is-external=true"><TT>TypeKind</TT></A>, e.g., <TT>ARRAY</TT>
or <TT>BOOLEAN</TT>
</LI><LI CLASS="li-itemize"><TT>treeClasses</TT>: an array of class literals for classes
implementing <A HREF="http://download.oracle.com/javase/7/docs/jdk/api/javac/tree/com/sun/source/tree/Tree.html?is-external=true"><TT>Tree</TT></A>, e.g.,
<TT>LiteralTree.class</TT> or <TT>ExpressionTree.class</TT>
</LI><LI CLASS="li-itemize"><TT>typeClasses</TT>: an array of class literals for classes
implementing <TT>javax.lang.model.type.TypeMirror</TT>, e.g.,
<TT>javax.lang.model.type.PrimitiveType</TT>. Often you should use
a subclass of <A HREF="doc/checkers/types/AnnotatedTypeMirror.html"><TT>AnnotatedTypeMirror</TT></A>.
</LI><LI CLASS="li-itemize"><TT>stringPatterns</TT>: an array of regular expressions that will
be matched against
string literals, e.g., <TT>"[01]+"</TT> for a binary number. Useful
for annotations that indicate the format of a string.
</LI></UL><P>For example, consider the definitions of the <TT>@</TT><A HREF="doc/checkers/nullness/quals/NonNull.html"><TT>NonNull</TT></A> and <TT>@</TT><A HREF="doc/checkers/nullness/quals/Nullable.html"><TT>Nullable</TT></A>
type qualifiers:</P><PRE CLASS="verbatim">  @TypeQualifier
  @SubtypeOf( { Nullable.class } )
  @ImplicitFor(
    types={TypeKind.PACKAGE},
    typeClasses={AnnotatedPrimitiveType.class},
    trees={
      Tree.Kind.NEW_CLASS,
      Tree.Kind.NEW_ARRAY,
      Tree.Kind.PLUS,
      // All literals except NULL_LITERAL:
      Tree.Kind.BOOLEAN_LITERAL, Tree.Kind.CHAR_LITERAL, Tree.Kind.DOUBLE_LITERAL, Tree.Kind.FLOAT_LITERAL,
      Tree.Kind.INT_LITERAL, Tree.Kind.LONG_LITERAL, Tree.Kind.STRING_LITERAL
    })
  @Target({ElementType.TYPE_PARAMETER, ElementType.TYPE_USE})
  public @interface NonNull {  }


  @TypeQualifier
  @SubtypeOf({})
  @ImplicitFor(trees={Tree.Kind.NULL_LITERAL})
  @Target({ElementType.TYPE_PARAMETER, ElementType.TYPE_USE})
  public @interface Nullable { }
</PRE><P>For more details, see the Javadoc for the <A HREF="doc/checkers/quals/ImplicitFor.html"><TT>ImplicitFor</TT></A>
annotation, and the Javadoc for the javac classes that are linked from
it. (You only need to understand a small amount about the javac AST, such
as the
<A HREF="http://download.oracle.com/javase/7/docs/jdk/api/javac/tree/com/sun/source/tree/Tree.Kind.html?is-external=true"><TT>Tree.Kind</TT></A>
and
<A HREF="http://download.oracle.com/javase/7/docs/api/javax/lang/model/type/TypeKind.html?is-external=true"><TT>TypeKind</TT></A>
enums. All the information you need is in the Javadoc, and
Section&#XA0;<A HREF="#javac-tips">19.9</A> can help you get started.)</P><!--TOC subsection Procedurally specifying implicit annotations-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->19.4.2&#XA0;&#XA0;Procedurally specifying implicit annotations</H3><!--SEC END --><P>The Checker Framework provides a representation of annotated types,
<A HREF="doc/checkers/types/AnnotatedTypeMirror.html"><TT>AnnotatedTypeMirror</TT></A>, that extends the standard <TT>TypeMirror</TT>
interface but integrates a representation of the annotations into a
type representation. A checker&#X2019;s <EM>type factory</EM> class, given an AST
node, returns the annotated type of that expression. The Checker
Framework&#X2019;s abstract
<EM>base type factory</EM> class, <A HREF="doc/checkers/types/AnnotatedTypeFactory.html"><TT>AnnotatedTypeFactory</TT></A>,
supplies a uniform, Tree-API-based interface
for querying the annotations on a program element, regardless of
whether that element is declared in a source file or in a class file.
It also handles default annotations, and it optionally performs
flow-sensitive local type inference.</P><P><A HREF="doc/checkers/types/AnnotatedTypeFactory.html"><TT>AnnotatedTypeFactory</TT></A> inserts the qualifiers that the programmer
explicitly inserted in the code. Yet, certain constructs should be
treated as having a type qualifier even when the programmer has not
written one. The type system designer may subclass
<A HREF="doc/checkers/types/AnnotatedTypeFactory.html"><TT>AnnotatedTypeFactory</TT></A> and override
<TT>annotateImplicit(Tree,AnnotatedTypeMirror)</TT> and
<TT>annotateImplicit(Element,AnnotatedTypeMirror)</TT> to account for
such constructs.</P><!--TOC section Visitor: Type rules-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="extending-visitor">19.5</A>&#XA0;&#XA0;Visitor: Type rules</H2><!--SEC END --><P>A type system&#X2019;s rules define which operations on values of a
particular type are forbidden.
These rules must be defined procedurally, not declaratively.</P><P>The Checker Framework provides a <I>base visitor class</I>,
<A HREF="doc/checkers/basetype/BaseTypeVisitor.html"><TT>BaseTypeVisitor</TT></A>, that performs type-checking at each node of a
source file&#X2019;s AST. It uses the visitor design pattern to traverse
Java syntax trees as provided by Sun&#X2019;s
<A HREF="http://java.sun.com/javase/6/docs/jdk/api/javac/tree/index.html">Tree
API</A>,
and it issues a warning whenever the type system is violated.</P><P>A checker&#X2019;s visitor overrides one method in the base visitor for each special
rule in the type qualifier system. Most type-checkers
override only a few methods in <A HREF="doc/checkers/basetype/BaseTypeVisitor.html"><TT>BaseTypeVisitor</TT></A>. For example, the
visitor for the Nullness type system of Chapter&#XA0;<A HREF="#nullness-checker">3</A>
contains a single 4-line method that warns if an expression of nullable type
is dereferenced, as in:
</P><PRE CLASS="verbatim">  myObject.hashCode();  // invalid dereference
</PRE><P>By default, <A HREF="doc/checkers/basetype/BaseTypeVisitor.html"><TT>BaseTypeVisitor</TT></A> performs subtyping checks that are
similar to Java subtype rules, but taking the type qualifiers into account.
<A HREF="doc/checkers/basetype/BaseTypeVisitor.html"><TT>BaseTypeVisitor</TT></A> issues these errors:</P><UL CLASS="itemize"><LI CLASS="li-itemize">invalid assignment (type.incompatible) for an assignment from
an expression type to an incompatible type. The assignment may be a
simple assignment, or pseudo-assignment like return expressions or
argument passing in a method invocation<P>In particular, in every assignment and pseudo-assignment, the
left-hand side of the assignment is a supertype of (or the same type
as) the right-hand side. For example, this assignment is not
permitted:</P><PRE CLASS="verbatim">    @Nullable Object myObject;
    @NonNull Object myNonNullObject;
    ...
    myNonNullObject = myObject;  // invalid assignment
  </PRE></LI><LI CLASS="li-itemize">invalid generic argument (generic.argument.invalid) when a type
is bound to an incompatible generic type variable</LI><LI CLASS="li-itemize">invalid method invocation (method.invocation.invalid) when a
method is invoked on an object whose type is incompatible with the
method receiver type</LI><LI CLASS="li-itemize">invalid overriding parameter type (override.parameter.invalid)
when a parameter in a method declaration is incompatible with that
parameter in the overridden method&#X2019;s declaration</LI><LI CLASS="li-itemize">invalid overriding return type (override.return.invalid) when a
parameter in a method declaration is incompatible with that
parameter in the overridden method&#X2019;s declaration</LI><LI CLASS="li-itemize">invalid overriding receiver type (override.receiver.invalid)
when a receiver in a method declaration is incompatible with that
receiver in the overridden method&#X2019;s declaration</LI></UL><!--TOC subsection AST traversal-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->19.5.1&#XA0;&#XA0;AST traversal<A NAME="ast-traversal"></A></H3><!--SEC END --><P>The Checker Framework needs to do its own traversal of the AST even though
it operates as an ordinary annotation processor&#XA0;[<A HREF="#JSR269">Dar06</A>]. Annotation
processors can utilize a visitor for Java code, but that visitor only
visits the public elements of Java code, such as classes, fields, methods,
and method arguments &#X2014; it does not visit code bodies or various other
locations. The Checker Framework hardly uses the built-in visitor &#X2014; as
soon as the built-in visitor starts to visit a class, then the Checker
Framework&#X2019;s visitor takes over and visits all of the class&#X2019;s source code.</P><P>Because there is no standard API for the AST of Java code, the Checker
Framework uses the javac implementation. This is why the Checker Framework
is not deeply integrated with Eclipse, but runs as an external tool (see
Section&#XA0;<A HREF="#eclipse">20.5</A>). Actually,
there is standard API for Java ASTs &#X2014; JSR 198 (Extension API for
Integrated Development Environments)&#XA0;[<A HREF="#JSR198">Cro06</A>]. If tools were to
implement it
(which would just require writing wrappers or adapters), then the Checker
Framework and similar tools could be portable among different compilers and
IDEs.</P><!--TOC subsection Avoid hardcoding-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->19.5.2&#XA0;&#XA0;Avoid hardcoding<A NAME="avoid-hardcoding"></A></H3><!--SEC END --><P>It may be tempting to write a type-checking rule for method invocation,
where your rule checks the name of the method being called and then treats
the method in a special way. This is usually the wrong approach. It
is better to write annotations, in a stub file
(Chapter&#XA0;<A HREF="#annotating-libraries">18</A>), and leave the work to the standard
type-checking rules.</P><!--TOC section The checker class: Compiler interface-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="writing-compiler-interface">19.6</A>&#XA0;&#XA0;The checker class: Compiler interface</H2><!--SEC END --><P>A checker&#X2019;s entry point is a subclass of <A HREF="doc/checkers/basetype/BaseTypeChecker.html"><TT>BaseTypeChecker</TT></A>. This entry
point, which we call the checker class, serves two
roles: an interface to the compiler and a factory for constructing
type-system classes.</P><P>Because the Checker Framework provides reasonable defaults, oftentimes the
checker class has no work to do. Here are the complete definitions of the
checker classes for the Interning and Nullness checkers:</P><PRE CLASS="verbatim">  @TypeQualifiers({ Interned.class, PolyInterned.class })
  @SupportedLintOptions({"dotequals"})
  public final class InterningChecker extends BaseTypeChecker { }

  @TypeQualifiers({ Nullable.class, Raw.class, NonNull.class, PolyNull.class })
  @SupportedLintOptions({"flow", "cast", "cast:redundant"})
  public class NullnessChecker extends BaseTypeChecker { }
</PRE><P>The checker class must be annotated by
<TT>@</TT><A HREF="doc/checkers/quals/TypeQualifiers.html"><TT>TypeQualifiers</TT></A>, which lists the annotations
that make up the type hierarchy for this checker (including
polymorphic qualifiers), provided as an array of class literals. Each
one is a type qualifier whose definition bears the
<TT>@</TT><A HREF="doc/checkers/quals/TypeQualifier.html"><TT>TypeQualifier</TT></A> meta-annotation (or is
returned by the
<A HREF="http://types.cs.washington.edu/checker-framework/current/doc/checkers/basetype/BaseTypeChecker.html#getSupportedTypeQualifiers()"><TT>BaseTypeChecker.getSupportedTypeQualifiers</TT></A>
method).</P><P>The checker class bridges between the compiler and the checker plugin. It
invokes the type-rule check visitor on every Java source file being
compiled, and provides a simple API, <A HREF="http://types.cs.washington.edu/checker-framework/current/doc/checkers/source/SourceChecker.html#report(checkers.source.Result,%20java.lang.Object)"><TT>report</TT></A>, to issue
errors using the compiler error reporting mechanism.</P><P>Also, the checker class follows the factory method pattern to
construct the concrete classes (e.g., visitor, factory) and annotation
hierarchy representation. It is a convention that, for
a type system named Foo, the compiler
interface (checker), the visitor, and the annotated type factory are
named as <TT>FooChecker</TT>, <TT>FooVisitor</TT>, and <TT>FooAnnotatedTypeFactory</TT>.
<A HREF="doc/checkers/basetype/BaseTypeChecker.html"><TT>BaseTypeChecker</TT></A> uses the convention to
reflectively construct the components. Otherwise, the checker writer
must specify the component classes for construction.</P><P>A checker can customize the default error messages through a
<A HREF="http://download.oracle.com/javase/6/docs/api/java/util/Properties.html"><TT>Properties</TT></A>-loadable text file named
<TT>messages.properties</TT> that appears in the same directory as the checker class.
The property file keys are the strings passed to <A HREF="http://types.cs.washington.edu/checker-framework/current/doc/checkers/source/SourceChecker.html#report(checkers.source.Result,%20java.lang.Object)"><TT>report</TT></A>
(like <TT>type.incompatible</TT>) and the values are the strings to be
printed (<TT>"cannot assign ..."</TT>).
The <TT>messages.properties</TT> file only need to mention the new messages that
the checker defines.
It is also allowed to override messages defined in superclasses, but this
is rarely needed.</P><!--TOC subsection Bundling multiple checkers-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->19.6.1&#XA0;&#XA0;Bundling multiple checkers</H3><!--SEC END --><P>To run a checker, a 
users supplies the 
<TT>-processor</TT> command-line option. When multiple related
checkers need to be run together as a unit, users can pass
multiple <TT>-processor</TT> arguments, like:</P><PRE CLASS="verbatim">  javac -processor DistanceUnitChecker -processor SpeedUnitChecker ... files ...
</PRE><P>This is verbose, and it is also error-prone, since a user might omit one of
several related checkers that are designed to be run together.</P><P>Alternatively, you can define an aggregate checker class that combines
multiple checkers. Extend <A HREF="doc/checkers/util/AggregateChecker.html"><TT>AggregateChecker</TT></A> and override
the <TT>getSupportedTypeCheckers</TT> method, like the following:</P><PRE CLASS="verbatim">  public class UnitCheckers extends AggregateChecker {
    protected Collection&lt;Class&lt;? extends SourceChecker&gt;&gt; getSupportedCheckers() {
      return Arrays.asList(DistanceUnitChecker.class, SpeedUnitChecker.class);
    }
  }
</PRE><P>Now, users can pass a single <TT>-processor</TT> argument on the command line:</P><PRE CLASS="verbatim">  javac -processor UnitCheckers ... files ...
</PRE><!--TOC section Testing framework-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="testing-framework">19.7</A>&#XA0;&#XA0;Testing framework</H2><!--SEC END --><P>[TODO: This section should discuss the testing framework that is used for
testing the distributed checkers.]</P><!--TOC section Debugging options-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="debugging-options">19.8</A>&#XA0;&#XA0;Debugging options</H2><!--SEC END --><P>The Checker Framework provides debugging options that can be helpful when
writing a checker. These are provided via the standard <TT>javac</TT> &#X201C;<TT>-A</TT>&#X201D;
switch, which is used to pass options to an annotation processor.</P><UL CLASS="itemize"><LI CLASS="li-itemize"><TT>-Anomsgtext</TT>: use message keys (such as &#X201C;<TT>type.invalid</TT>&#X201D;)
rather than full message text when reporting errors or warnings</LI><LI CLASS="li-itemize"><TT>-Ashowchecks</TT>: print debugging information for each
pseudo-assignment check (as performed by <A HREF="doc/checkers/basetype/BaseTypeVisitor.html"><TT>BaseTypeVisitor</TT></A>; see Section
<A HREF="#extending-visitor">19.5</A> above)</LI><LI CLASS="li-itemize"><TT>-Afilenames</TT>: print the name of each file before type-checking it</LI></UL><P>The following example demonstrates how these options are used:</P><PRE CLASS="verbatim">$ javac -processor checkers.interning.InterningChecker \
    examples/InternedExampleWithWarnings.java -Ashowchecks -Anomsgtext -Afilenames

[InterningChecker] InterningExampleWithWarnings.java
 success (line  18): STRING_LITERAL "foo"
     actual: DECLARED @checkers.interning.quals.Interned java.lang.String
   expected: DECLARED @checkers.interning.quals.Interned java.lang.String
 success (line  19): NEW_CLASS new String("bar")
     actual: DECLARED java.lang.String
   expected: DECLARED java.lang.String
examples/InterningExampleWithWarnings.java:21: (not.interned)
    if (foo == bar)
            ^
 success (line  22): STRING_LITERAL "foo == bar"
     actual: DECLARED @checkers.interning.quals.Interned java.lang.String
   expected: DECLARED java.lang.String
1 error
</PRE><P>You can use any standard debugger to observe the execution of your checker. Set the execution main class to <TT>com.sun.tools.javac.Main</TT>, and insert the JSR308 javac.jar (resides in <TT>$jsr308-langtools/dist/lib/javac.jar</TT>). If using an IDE, it is recommended that you add <TT>$jsr308-langtools</TT> as a project, so you can
step into its source code if needed.</P><!--TOC section javac implementation survival guide-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="javac-tips">19.9</A>&#XA0;&#XA0;javac implementation survival guide</H2><!--SEC END --><P>A checker built using the Checker Framework makes use of a few interfaces
from the underlying compiler. This section describes those interfaces.</P><!--TOC subsection Checker access to compiler information-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->19.9.1&#XA0;&#XA0;Checker access to compiler information</H3><!--SEC END --><P>The compiler uses and exposes three hierarchies to model the Java
source code and classfiles.</P><!--TOC subsubsection Types - Java Language Model API-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Types - Java Language Model API<A NAME="javac-types"></A></H4><!--SEC END --><P>A <A HREF="http://download.oracle.com/javase/7/docs/api/javax/lang/model/type/TypeMirror.html?is-external=true"><TT>TypeMirror</TT></A> represents a Java type.
</P><P>There is a <TT>TypeMirror</TT> interface to represent each type kind,
e.g., <TT>PrimitiveType</TT> for primitive types, <TT>ExecutableType</TT>
for method types, and <TT>NullType</TT> for the type of the <TT>null</TT> literal.</P><P><TT>TypeMirror</TT> does not represent annotated types though. Checkers should use the Framework types API <A HREF="doc/checkers/types/AnnotatedTypeMirror.html"><TT>AnnotatedTypeMirror</TT></A> instead. <TT>AnnotatedTypeMirror</TT> parallels the <TT>TypeMirror</TT> API, but also present the type annotations associated with the type.</P><P>The Checker Framework and the Checkers use the types API extensively.</P><!--TOC subsubsection Elements - Java Language Model API-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Elements - Java Language Model API<A NAME="javac-elements"></A></H4><!--SEC END --><P>An <A HREF="http://download.oracle.com/javase/7/docs/api/javax/lang/model/element/Element.html?is-external=true"><TT>Element</TT></A> represents a potentially-public
declaration that can be accessed from elsewhere: classes, interfaces, methods, constructors, and
fields. <TT>Element</TT> represents elements found in both source
code and bytecode.</P><P>There is an <TT>Element</TT> interface to represent each construct, e.g.
<TT>TypeElement</TT> for class/interfaces, <TT>ExecutableElement</TT> for
methods/constructors, <TT>VariableElement</TT> for local variables and
method parameters.</P><P>If you need to operate on the declaration level, always use elements rather
than trees (Section&#XA0;<A HREF="#javac-trees">19.9.1</A>). This allows the code to work on
both source and bytecode elements.</P><P>Example: retrieve declaration annotations, check variable
modifiers (e.g. <TT>strictfp</TT>, <TT>synchronized</TT>)</P><!--TOC subsubsection Trees - Compiler Tree API-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Trees - Compiler Tree API<A NAME="javac-trees"></A></H4><!--SEC END --><P>A <A HREF="http://download.oracle.com/javase/7/docs/jdk/api/javac/tree/com/sun/source/tree/Tree.html?is-external=true"><TT>Tree</TT></A> represents a syntactic units in the source code,
like method declarations, statements, blocks, <TT>for</TT> loop etc. Trees only
represent source code to be compiled (or found in <TT>-sourcepath</TT>);
no tree is available for classes read from bytecode.</P><P>There is a Tree interface for each Java source structure, e.g.
<TT>ClassTree</TT> for class declaration, <TT>MethodInvocationTree</TT>
for method invocations, <TT>ForEachTree</TT> for enhanced-for-loop
statement.</P><P>You should limit your use of trees. Checkers use Trees mainly to
traverse the source code, retrieve the types/elements corresponding to
them, and perform any needed checks on the types/elements instead.</P><!--TOC subsubsection Using the APIs-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Using the APIs</H4><!--SEC END --><P>The three APIs use some common idioms and conventions; knowing them will
help you to create your checker.</P><P><EM>Type-checking</EM>:
Do not use <TT>instanceof</TT> to determining the class of the object,
because you cannot necessarily predict the run-time type of the object that
implements an interface. Instead, use the <TT>getKind()</TT> method. The
method returns <A HREF="http://download.oracle.com/javase/7/docs/api/javax/lang/model/type/TypeKind.html?is-external=true"><TT>TypeKind</TT></A>,
<A HREF="http://download.oracle.com/javase/7/docs/api/javax/lang/model/element/ElementKind.html?is-external=true"><TT>ElementKind</TT></A>, and <A HREF="http://download.oracle.com/javase/7/docs/jdk/api/javac/tree/com/sun/source/tree/Tree.Kind.html?is-external=true"><TT>Tree.Kind</TT></A>
for the three interfaces, respectively.</P><P><EM>Visitors and Scanners</EM>:
The compiler and the Checker Framework use the visitor pattern
extensively. For example, visitors are used to traverse the source tree
(<A HREF="doc/checkers/basetype/BaseTypeVisitor.html"><TT>BaseTypeVisitor</TT></A> extends
<A HREF="http://download.oracle.com/javase/7/docs/jdk/api/javac/tree/com/sun/source/util/TreePathScanner.html?is-external=true"><TT>TreePathScanner</TT></A>) and for type
checking (<A HREF="doc/checkers/types/TreeAnnotator.html"><TT>TreeAnnotator</TT></A> implements
<A HREF="http://download.oracle.com/javase/7/docs/jdk/api/javac/tree/com/sun/source/tree/TreeVisitor.html?is-external=true"><TT>TreeVisitor</TT></A>).</P><P><EM>Utility classes</EM>:
Some useful methods appear in a utility class. The Sun convention is that
the utility class for a <TT>Foo</TT> hierarchy is <TT>Foos</TT> (e.g.,
<A HREF="http://download.oracle.com/javase/7/docs/api/javax/lang/model/util/Types.html?is-external=true"><TT>Types</TT></A>, <A HREF="http://download.oracle.com/javase/7/docs/api/javax/lang/model/util/Elements.html?is-external=true"><TT>Elements</TT></A>, and
<A HREF="http://download.oracle.com/javase/7/docs/jdk/api/javac/tree/com/sun/source/util/Trees.html?is-external=true"><TT>Trees</TT></A>). The Checker Framework uses a common
<TT>Utils</TT> post-fix instead (e.g. <A HREF="doc/checkers/util/TypesUtils.html"><TT>TypesUtils</TT></A>,
<A HREF="doc/checkers/util/TreeUtils.html"><TT>TreeUtils</TT></A>, <A HREF="doc/checkers/util/ElementUtils.html"><TT>ElementUtils</TT></A>), with one
notable exception: <A HREF="doc/checkers/types/AnnotatedTypes.html"><TT>AnnotatedTypes</TT></A>.</P><!--TOC subsection How a checker fits in the compiler as an annotation processor-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->19.9.2&#XA0;&#XA0;How a checker fits in the compiler as an annotation processor</H3><!--SEC END --><P>The Checker Framework builds on the Annotation Processing API
introduced in Java 6. A type annotation processors is one that extends
<A HREF="http://download.oracle.com/javase/7/docs/jdk/api/javac/tree/com/sun/source/util/AbstractTypeProcessor.html?is-external=true"><TT>AbstractTypeProcessor</TT></A>; these get run on each class
source file after the compiler confirms that the class is valid Java code.</P><P>The most important methods of <A HREF="http://download.oracle.com/javase/7/docs/jdk/api/javac/tree/com/sun/source/util/AbstractTypeProcessor.html?is-external=true"><TT>AbstractTypeProcessor</TT></A>
are <TT>typeProcess</TT> and <TT>getSupportedSourceVersion</TT>. The former
class is where you would insert any sort of method call to walk the AST,
and the latter just returns a constant indicating that we are targeting
version 7 of the compiler. Implementing these two methods should be enough
for a basic plugin; see the Javadoc for the class for other methods that
you may find useful later on.</P><P>The Checker Framework uses Sun&#X2019;s Tree API to access a program&#X2019;s AST.
The Tree API is specific to the Sun JDK, so the Checker Framework only
works with Sun&#X2019;s javac, not with Eclipse&#X2019;s compiler ecj or with
<A HREF="http://gcc.gnu.org/java/">gcj</A>. This also limits the tightness of
the integration of the Checker Framework into other IDEs such as <A HREF="http://www.jetbrains.com/idea/">IntelliJ IDEA</A>.
An implementation-neutral API would be preferable.
In the future, the Checker Framework
can be migrated to use the Java Model AST of JSR 198 (Extension API for
Integrated Development Environments)&#XA0;[<A HREF="#JSR198">Cro06</A>], which gives access to
the source code of a method. But, at present no tools
implement JSR&#XA0;198. Also see Section&#XA0;<A HREF="#ast-traversal">19.5.1</A>.</P><!--TOC subsubsection Learning more about javac-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Learning more about javac</H4><!--SEC END --><P>Sun&#X2019;s javac compiler interfaces can be daunting to a
newcomer, and its documentation is a bit sparse. The Checker Framework
aims to abstract a lot of these complexities.
You do not have to understand the implementation of javac to
build powerful and useful checkers.
Beyond this section, 
other useful resources include the Java Infrastructure
Developer&#X2019;s guide at
<A HREF="http://wiki.netbeans.org/Java_DevelopersGuide"><TT>http://wiki.netbeans.org/Java_DevelopersGuide</TT></A> and the compiler
mailing list archives at
<A HREF="http://news.gmane.org/gmane.comp.java.openjdk.compiler.devel"><TT>http://news.gmane.org/gmane.comp.java.openjdk.compiler.devel</TT></A>
(subscribe at
<A HREF="http://mail.openjdk.java.net/mailman/listinfo/compiler-dev"><TT>http://mail.openjdk.java.net/mailman/listinfo/compiler-dev</TT></A>).</P><HR><!--TOC chapter Integration with external tools-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="external-tools">Chapter&#XA0;20</A>&#XA0;&#XA0;Integration with external tools</H1><!--SEC END --><P>This section discusses how to run a checker from your favorite IDE.</P><P>Or, if your favorite isn&#X2019;t here, you should customize how it runs the
javac command on your behalf. See the IDE documentation to learn how to
customize it, adapting the instructions for javac in Section&#XA0;<A HREF="#running">2.2</A>.
If you make another tool support running a checker, please
inform us via the
<A HREF="http://groups.google.com/group/checker-framework-discuss">mailing
list</A> or
<A HREF="http://code.google.com/p/checker-framework/issues/list">issue tracker</A> so
we can add it to this manual.</P><P>This section also discusses type inference tools (see
Section&#XA0;<A HREF="#type-inference-tools">20.7</A>).</P><!--TOC section Javac Compiler-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="javac-installation">20.1</A>&#XA0;&#XA0;Javac Compiler</H2><!--SEC END --><P>If you use <TT>javac</TT> compiler from the command line, then you can use the
Java 7 <TT>javac</TT> that is bundled with the Checker Framework. The bundled
<TT>javac</TT> recognizes type annotations, and annotations in
comments (see Section&#XA0;<A HREF="#annotations-in-comments">17.3</A>).
(Eventually, you will be able to use any Java 7 compiler, but Oracle has
been slow to incorporate all the patches, so the bundled <TT>javac</TT> is
superior, for the purpose of pluggable type-checking.)</P><P>This section describes how you can install and use the bundled
<TT>javac</TT>, using either Unix/Linux/MacOS (see
Section&#XA0;<A HREF="#unix-installation">20.1.1</A>) or Windows (see
Section&#XA0;<A HREF="#windows-installation">20.1.2</A>).
The instructions are identical to those of Section&#XA0;<A HREF="#installation">1.2</A>,
but are given as commands that you can cut and paste into your command shell.</P><!--TOC subsection Unix/Linux/MacOS installation-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->20.1.1&#XA0;&#XA0;Unix/Linux/MacOS installation<A NAME="unix-installation"></A></H3><!--SEC END --><P>These instructions assume that you use the bash or sh shell. If you use a
different shell, you may need to slightly adjust the commands.</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">Download the latest Checker Framework distribution
and unzip it. You can put it anywhere you like by changing the
definition of environment variable <TT>JSR308</TT> below; a standard place
is in a
new directory named <TT>jsr308</TT>.<PRE CLASS="verbatim">  export JSR308=$HOME/jsr308
  mkdir -p ${JSR308}
  cd ${JSR308}
  # or:  wget http://types.cs.washington.edu/checker-framework/current/checkers.zip
  curl -O http://types.cs.washington.edu/checker-framework/current/checkers.zip
  unzip checkers.zip
  chmod +x checker-framework/checkers/binary/javac
  checker-framework/checkers/binary/javac -version
</PRE><P>The output of the last command should be:</P><PRE CLASS="verbatim">  javac 1.7.0-jsr308-1.1.1
</PRE></LI><LI CLASS="li-enumerate">Place the following commands in your <TT>.bashrc</TT> file:
<PRE CLASS="verbatim">  export JSR308=$HOME/jsr308
  export PATH=$JSR308/checker-framework/checkers/binary:${PATH}
</PRE><P>Also execute them on the command line, or log out and back in. Then,
verify that the installation works. From the command line, run:</P><PRE CLASS="verbatim">  javac -version
</PRE><P>The output should be:</P><PRE CLASS="verbatim">  javac 1.7.0-jsr308-1.1.1
</PRE></LI></OL><P>That&#X2019;s all there is to it! Now you are ready to start using the checkers with
the new <TT>javac</TT> compiler.</P><!--TOC subsection Windows installation-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->20.1.2&#XA0;&#XA0;Windows installation<A NAME="windows-installation"></A></H3><!--SEC END --><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">Download the latest Checker Framework distribution
and unzip it to create a <TT>checkers</TT> directory. You can put it anywhere
you like; a standard place is in a new directory under <TT>C:</TT><TT>\</TT><TT>Program
Files</TT>.<OL CLASS="enumerate" type=a><LI CLASS="li-enumerate">
Save the file
<A HREF="http://types.cs.washington.edu/checker-framework/current/checkers.zip"><TT>http://types.cs.washington.edu/checker-framework/current/checkers.zip</TT></A>
to your Desktop.
</LI><LI CLASS="li-enumerate">Double-click the <TT>checkers.zip</TT> file on your computer. Click on
the <TT>checkers</TT> directory, then Select <TT>Extract all files</TT>, and use
<TT>C:</TT><TT>\</TT><TT>Program Files</TT> as the destination. You will obtain a new
<TT>C:</TT><TT>\</TT><TT>Program Files</TT><TT>\</TT><TT>checkers</TT> folder.
</LI><LI CLASS="li-enumerate">Verify that the installation works. From a Windows command prompt, run
(all on one line):<PRE CLASS="verbatim">  java -Xbootclasspath/p:C:\Path\To\...\checker-framework\checkers\binary\jsr308-all.jar
       -jar C:\Program Files\checkers\binary\jsr308-all.jar -version
</PRE><P>The output should be:</P><PRE CLASS="verbatim">  javac 1.7.0-jsr308-1.1.1
</PRE></LI></OL></LI><LI CLASS="li-enumerate">In order to use the updated compiler when you type <TT>javac</TT>, add the
directory <TT>C:</TT><TT>\</TT><TT>Program Files</TT><TT>\</TT><TT>checkers</TT><TT>\</TT><TT>binary</TT> to the
beginning of your path variable. Also set a CHECKERS variable.<P>To set an environment variable, you have two options: make the change
temporarily or permanently.
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
To make the change <B>temporarily</B>, type at the command shell prompt:<PRE>
path = <EM>newdir</EM>;%PATH%
</PRE><P>For example:</P><PRE CLASS="verbatim">path = C:\Program Files\checkers\binary;%PATH%
set CHECKERS = C:\Program Files\checkers
</PRE><P>This is a temporary change that endures until the window is closed, and you
must re-do it every time you start a new command shell.</P></LI><LI CLASS="li-itemize">To make the change <B>permanently</B>,
Right-click the <TT>My Computer</TT> icon and
select <TT>Properties</TT>. Select the <TT>Advanced</TT> tab and click the
<TT>Environment Variables</TT> button. You can set the variable as a &#X201C;System
Variable&#X201D; (visible to all users) or as a &#X201C;User Variable&#X201D; (visible to
just this user). Both work; the instructions below show how to set as a
&#X201C;System Variable&#X201D;.
In the <TT>System Variables</TT> pane, select
<TT>Path</TT> from the list and click <TT>Edit</TT>. In the <TT>Edit System Variable</TT>
dialog box, move the cursor to the beginning of the string in the
<TT>Variable Value</TT> field and type the full directory name followed by a
semicolon (<TT>;</TT>).<P>Similarly, set the CHECKERS variable.</P><P>This is a permanent change that only needs to be done once ever.
</P></LI></UL><P>Now, verify that the installation works. From the command line, run:</P><PRE CLASS="verbatim">  javac -version
</PRE><P>The output should be:</P><PRE CLASS="verbatim">  javac 1.7.0-jsr308-1.1.1
</PRE></LI></OL><!--TOC section Ant task-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="ant-task">20.2</A>&#XA0;&#XA0;Ant task</H2><!--SEC END --><P>If you use the <A HREF="http://ant.apache.org/">Ant</A> build tool to compile
your software, then you can add an Ant task that runs a checker. We assume
that your Ant file already contains a compilation target that uses the
<TT>javac</TT> task.</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
Set the <TT>jsr308javac</TT> property:<PRE CLASS="verbatim">  &lt;property environment="env"/&gt;

  &lt;presetdef name="jsr308.javac"&gt;
    &lt;javac fork="yes"&gt;
      &lt;!-- JSR308 related compiler arguments --&gt;
      &lt;compilerarg value="-version"/&gt;
      &lt;compilerarg line="-target 5"/&gt;
      &lt;compilerarg value="-implicit:class"/&gt;
      &lt;compilerarg line="-Awarns -Xmaxwarns 10000"/&gt;
      &lt;compilerarg value="-J-Xbootclasspath/p:${env.CHECKERS}/binary/jsr308-all.jar"/&gt;

      &lt;classpath&gt;
        &lt;pathelement location="${env.CHECKERS}/checkers.jar"/&gt;
      &lt;/classpath&gt;
    &lt;/javac&gt;
  &lt;/presetdef&gt;
</PRE></LI><LI CLASS="li-enumerate">Duplicate the compilation target, then modify it slightly as
indicated in this example, filling in each ellipsis (&#X2026;) from the
original compilation target:<PRE CLASS="verbatim">  &lt;target name="check-nullness"
          description="Check for nullness errors"
          depends="clean,..."&gt;
    &lt;!-- use jsr308.javac instead of javac --&gt;
    &lt;jsr308.javac ... &gt;
      &lt;compilerarg line="-processor checkers.nullness.NullnessChecker"/&gt;
      &lt;compilerarg value="-Xbootclasspath/p:${env.CHECKERS}/jdk/jdk.jar"/&gt;
      &lt;!-- optional, for implicit imports: &lt;compilerarg value="-J-Djsr308_imports=checkers.nullness.quals.*"/&gt; --&gt;
      &lt;!-- optional, to not check library bodies: &lt;compilerarg value="-AskipClasses=^(java\.awt\.|javax\.swing\.)"/&gt; --&gt;
      ...
    &lt;/jsr308.javac&gt;
  &lt;/target&gt;
</PRE><P>In the example, the target is named <TT>check-nullness</TT>, but you can
name it whatever you like.</P><P>The target should not include a <TT>-source</TT> argument, such as
<TT>-source 1.5</TT>, because doing so will disable the annotations in
comments feature (see Section&#XA0;<A HREF="#annotations-in-comments">17.3</A>).
</P></LI></OL><!--TOC subsection Explanation-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->20.2.1&#XA0;&#XA0;Explanation<A NAME="ant-task-explanation"></A></H3><!--SEC END --><P>This section explains each part of the Ant task.</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
Definition of <TT>jsr308.javac</TT>:<P>The <TT>fork</TT> field of the <TT>javac</TT> task
ensures that an external javac program is called. Otherwise, Ant will run
javac via a Java method call, and there is no guarantee that it will get
the JSR 308 version that is distributed with the Checker Framework.</P><P>The <TT>-version</TT> compiler argument is just for debugging; you may omit
it.</P><P>The <TT>-target 5</TT> compiler argument is optional, if you use Java 5 in
ordinary compilation when not performing pluggable type-checking.</P><P>The <TT>-implicit:class</TT> compiler argument causes annotation processing
to be performed on implicitly compiled files. (An implicitly compiled file
is one that was not specified on the command line, but for which the source
code is newer than the <TT>.class</TT> file.) This is the default, but
supplying the argument explicitly suppresses a compiler warning.</P><P>The <TT>-Awarns ...</TT> compiler argument is optional, and causes the checker to
treat errors as warnings so that you can see all errors in all files rather
than only the errors in the first file; see Section&#XA0;<A HREF="#running">2.2</A>.</P></LI><LI CLASS="li-enumerate">The <TT>check-nullness</TT> target:<P>The target assumes the existence of a <TT>clean</TT> target that removes all
<TT>.class</TT> files. That is necessary because Ant&#X2019;s <TT>javac</TT> target
doesn&#X2019;t re-compile <TT>.java</TT> files for which a <TT>.class</TT> file
already exists.</P><P>The <TT>-processor ...</TT> compiler argument indicates which checker to
run. You can supply additional arguments to the checker as well.</P></LI></OL><!--TOC section Maven plugin-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="maven-plugin">20.3</A>&#XA0;&#XA0;Maven plugin</H2><!--SEC END --><P>If you use the <A HREF="http://maven.apache.org/">Maven</A> project tool,
then you can specify the distributed checkers as part of your build
process.</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">First, you need to add the repositories in your <TT>pom.xml</TT> file:<PRE CLASS="verbatim">    &lt;repositories&gt;
        &lt;repository&gt;
            &lt;id&gt;checker-framework-repo&lt;/id&gt;
            &lt;url&gt;http://types.cs.washington.edu/m2-repo&lt;/url&gt;
        &lt;/repository&gt;
    &lt;/repositories&gt;
    &lt;pluginRepositories&gt;
        &lt;pluginRepository&gt;
            &lt;id&gt;checker-framework-repo&lt;/id&gt;
            &lt;url&gt;http://types.cs.washington.edu/m2-repo&lt;/url&gt;
        &lt;/pluginRepository&gt;
    &lt;/pluginRepositories&gt;
</PRE></LI><LI CLASS="li-enumerate">Then, to use the annotations used by the distributed checkers, you&#X2019;ll
have to declared as a dependency:<PRE CLASS="verbatim">    &lt;dependencies&gt;
        &lt;!-- annotations for the standard checkers: nullness, interning, mutability --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.jolira.types.checkers&lt;/groupId&gt;
            &lt;artifactId&gt;checkers-quals&lt;/artifactId&gt;
            &lt;version&gt;1.0.6&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;!-- other dependencies --&gt;
    &lt;/dependencies&gt;
</PRE></LI><LI CLASS="li-enumerate">And finally, you need to attach the plugin to your build lifecycle:<PRE CLASS="verbatim">    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;com.jolira.types.checkers&lt;/groupId&gt;
                &lt;artifactId&gt;checkersplugin&lt;/artifactId&gt;
                &lt;version&gt;0.1&lt;/version&gt;
                &lt;executions&gt;
                    &lt;execution&gt;
                        &lt;!-- run the checkers after compilation; this can also be any later phase --&gt;
                        &lt;phase&gt;process-classes&lt;/phase&gt;
                        &lt;goals&gt;
                            &lt;goal&gt;check&lt;/goal&gt;
                        &lt;/goals&gt;
                    &lt;/execution&gt;
                &lt;/executions&gt;
                &lt;configuration&gt;
                    &lt;!-- required configuration options --&gt;
                    &lt;!-- a list of processors to run --&gt;
                    &lt;processors&gt;
                        &lt;processor&gt;checkers.nullness.NullnessChecker&lt;/processor&gt;
                        &lt;processor&gt;checkers.interning.InterningChecker&lt;/processor&gt;
                    &lt;/processors&gt;


                    &lt;!-- other optional configuration --&gt;
                    &lt;!-- full path to a java executable that should be used to create the forked JVM --&gt;
                    &lt;executable&gt;/opt/java1.6/bin/java&lt;/executable&gt;
                    &lt;!-- should an error reported by a checker cause a build failure, or only be logged as a warning; defaults to true --&gt;
                    &lt;failOnError&gt;true|false&lt;/failOnError&gt;
                    &lt;!-- a list of patterns to include, in the standard maven syntax; defaults to **/*.java --&gt;
                    &lt;includes&gt;
                        &lt;include&gt;org/company/important/**/*.java&lt;/include&gt;
                    &lt;/includes&gt;
                    &lt;!-- a list of patterns to exclude, in the standard maven syntax; defaults to an empty list --&gt;
                    &lt;excludes&gt;
                        &lt;exclude&gt;org/company/notimportant/**/*.java&lt;/exclude&gt;
                    &lt;/excludes&gt;
                    &lt;!-- additional parameters passed to the JSR308 java compiler --&gt;
                    &lt;javacParams&gt;-Alint&lt;/javacParams&gt;
                    &lt;!-- additional parameters to pass to the forked JVM --&gt;
                    &lt;javaParams&gt;-Xdebug&lt;/javaParams&gt;
                    &lt;!-- versions of checkers to use; defaults to the current newest version: 1.0.6 --&gt;
                    &lt;checkersVersion&gt;0.8.8&lt;/checkersVersion&gt;
                &lt;/configuration&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;
</PRE></LI></OL><P>The plugin was contributed by Adam Warski.
</P><!--TOC section IntelliJ IDEA-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="intellij">20.4</A>&#XA0;&#XA0;IntelliJ IDEA</H2><!--SEC END --><P>IntelliJ IDEA (Maia release)
<A HREF="http://blogs.jetbrains.com/idea/2009/07/type-annotations-jsr-308-support/">supports</A>
the Type Annotations (JSR-308) syntax.
See <A HREF="http://blogs.jetbrains.com/idea/2009/07/type-annotations-jsr-308-support/"><TT>http://blogs.jetbrains.com/idea/2009/07/type-annotations-jsr-308-support/</TT></A>.</P><!--TOC section Eclipse-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="eclipse">20.5</A>&#XA0;&#XA0;Eclipse</H2><!--SEC END --><P>There are two ways to run a checker from within the Eclipse IDE: via Ant
or using an Eclipse plug-in.</P><!--TOC paragraph Using an Ant task-->
<H5 CLASS="paragraph"><!--SEC ANCHOR -->Using an Ant task</H5><!--SEC END --><P>Add an Ant target as described in Section&#XA0;<A HREF="#ant-task">20.2</A>. You can
run the Ant target by executing the following steps
(instructions copied from
<A HREF="http://www.eclipse.org/documentation/?topic=/org.eclipse.platform.doc.user/gettingStarted/qs-84_run_ant.htm"><TT>http://www.eclipse.org/documentation/?topic=/org.eclipse.platform.doc.user/gettingStarted/qs-84_run_ant.htm</TT></A>):</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">Select <TT>build.xml</TT> in one of the navigation views and choose
<B>Run As </B><B>&gt;</B><B> Ant Build...</B> from its context menu.</LI><LI CLASS="li-enumerate">A launch configuration dialog is opened on a launch configuration
for this Ant buildfile.</LI><LI CLASS="li-enumerate">In the <B>Targets</B> tab, select the new ant task (e.g., check-interning).</LI><LI CLASS="li-enumerate">Click <B>Run</B>.</LI><LI CLASS="li-enumerate">The Ant buildfile is run, and the output is sent to the Console view.</LI></OL><!--TOC paragraph Eclipse plug-in for the Checker Framework-->
<H5 CLASS="paragraph"><!--SEC ANCHOR -->Eclipse plug-in for the Checker Framework</H5><!--SEC END --><P>The Checker Plugin is an Eclipse plugin that enables the use of the Checker
Framework.
Its website (<A HREF="http://types.cs.washington.edu/checker-framework/eclipse/"><TT>http://types.cs.washington.edu/checker-framework/eclipse/</TT></A>).
The website contains instructions for installing and using the plugin.
</P><!--TOC paragraph Eclipse plug-in for Type Annotations-->
<H5 CLASS="paragraph"><!--SEC ANCHOR -->Eclipse plug-in for Type Annotations</H5><!--SEC END --><P>A prototype version of Type Annotations support for Eclipse is
available from the Eclipse project. The goal is to enable full support for
writing
type annotations outside of comments. You do not need this to run the
Checker Framework, whether or not you write your type annotations in comments.</P><P>(Update: this apparently needs a username and password, so it may not be
publicly available.)
Use the following information to check
out the CVS repository:
</P><DL CLASS="description"><DT CLASS="dt-description">
<B>Host:</B></DT><DD CLASS="dd-description"> dev.eclipse.org
</DD><DT CLASS="dt-description"><B>Repository path:</B></DT><DD CLASS="dd-description"> /cvsroot/eclipse
</DD><DT CLASS="dt-description"><B>Module name:</B></DT><DD CLASS="dd-description"> org.eclipse.jdt.core
</DD><DT CLASS="dt-description"><B>Branch:</B></DT><DD CLASS="dd-description"> JSR_308
</DD></DL><!--TOC section tIDE-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="tide">20.6</A>&#XA0;&#XA0;tIDE</H2><!--SEC END --><P>tIDE, an open-source Java IDE, supports the Checker Framework. See its
documentation at <A HREF="http://tide.olympe-network.com/"><TT>http://tide.olympe-network.com/</TT></A>.</P><!--TOC section Type inference tools-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="type-inference-tools">20.7</A>&#XA0;&#XA0;Type inference tools</H2><!--SEC END --><!--TOC subsection Varieties of type inference-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->20.7.1&#XA0;&#XA0;Varieties of type inference</H3><!--SEC END --><P>There are two different tasks that are commonly called &#X201C;type inference&#X201D;.</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
Type inference during type checking (Section&#XA0;<A HREF="#type-refinement">16.3.2</A>):
During type checking, if certain variables have no type qualifier, the
type-checker determines whether there is some type qualifier that would
permit the program to type check. If so, the type checker uses that type
qualifier, but never tells the programmer what it was. Each time the
type checker runs, it re-infers the type qualifier for that variable. If
no type qualifier exists that permits the program to type-check, the
type-checker issues a type warning.<P>This variety of type inference is built into the Checker Framework. Every
checker can take advantage of it at no extra effort. However, it only
works within a method, not across method boundaries.</P><P>Advantages of this variety of type inference include:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
If the type qualifier is obvious to the programmer, then omitting it
can reduce annotation clutter in the program.
</LI><LI CLASS="li-itemize">The type inference can take advantage of only the code currently being
compiled, rather than having to be correct for all possible calls.
Additionally, if the code changes, then there is no old annotation to
update.
</LI></UL></LI><LI CLASS="li-enumerate">Type inference to annotate a program (Section&#XA0;<A HREF="#type-inference-to-annotate">20.7.2</A>):
As a separate step before type checking, a type inference tool takes the
program as input, and outputs a set of type qualifiers that would
type-check. These qualifiers are inserted into the source code or the
class file. They can be viewed and adjusted by the programmer, and can
be used by tools such as the type checker.<P>This variety of type inference must be provided by a separate tool. It
is not built into the Checker Framework.</P><P>Advantages of this variety of type inference include:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
The program contains documentation in the form of type qualifiers,
which can aid programmer understanding.
</LI><LI CLASS="li-itemize">Error messages may be more comprehensible. With type inference
during type checking, error messages can be obscure, because the
compiler has already inferred (possibly incorrect) types for a number
of variables.
</LI><LI CLASS="li-itemize">A minor advantage is speed: type-checking can be modular, which can be
faster than re-doing type inference every time the
program is type-checked.
</LI></UL></LI></OL><P>Advantages of both varieties of inference include:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Less work for the programmer.
</LI><LI CLASS="li-itemize">The tool chooses the most general type, whereas a programmer might
accidentally write a more specific, less generally-useful annotation.
</LI></UL><P>Each variety of type inference has its place. When using the Checker
Framework, type inference during type checking is performed only
<EM>within</EM> a method (Section&#XA0;<A HREF="#type-refinement">16.3.2</A>). Every method
signature (arguments and return values) and field must be explicitly annotated,
either by the programmer or by a separate type checking tool
(Section&#XA0;<A HREF="#type-inference-to-annotate">20.7.2</A>). This choice reduces programmer
effort (typically, a programmer does not have to write any qualifiers
inside the body of a method) while still retaining modular checking and
documentation benefits.</P><!--TOC subsection Type inference to annotate a program-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->20.7.2&#XA0;&#XA0;Type inference to annotate a program<A NAME="type-inference-to-annotate"></A></H3><!--SEC END --><P>This section lists tools that take a program and output a set of
annotations for it.</P><P>Section&#XA0;<A HREF="#nullness-inference">3.2.4</A> lists several tools that infer
annotations for the Nullness Checker.</P><P>Section&#XA0;<A HREF="#javari-inference">6.2.2</A> lists a tool that infers
annotations for the Javari Checker, which detects mutation errors.</P><HR><!--TOC chapter Frequently Asked Questions (FAQs)-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="faq">Chapter&#XA0;21</A>&#XA0;&#XA0;Frequently Asked Questions (FAQs)</H1><!--SEC END --><P>These are some common questions about the Checker Framework and about
pluggable type-checking in general. Feel free to suggest improvements to
the answers, or other questions to include here.</P><P>There is a separate FAQ for the type annotations syntax
(<A HREF="http://types.cs.washington.edu/jsr308/jsr308-faq.html"><TT>http://types.cs.washington.edu/jsr308/jsr308-faq.html</TT></A>).</P><P><B>Contents:</B><BR>
<A HREF="#faq-ease-of-use">21.1</A>: Are type annotations easy to read and write?<BR>
<A HREF="#faq-code-clutter">21.2</A>: Will my code become cluttered with type annotations?<BR>
<A HREF="#faq-no-absolute-guarantee">21.3</A>: Can a pluggable type-checker give an absolute guarantee of correctness?<BR>
<A HREF="#never-make-type-errors">21.4</A>: I don&#X2019;t make type errors, so would pluggable type checking help me?<BR>
<A HREF="#faq-no-annotation-on-types-and-declarations">21.5</A>: Why shouldn&#X2019;t a qualifier apply to both types and declarations?<BR>
<A HREF="#faq-qualifiers-vs-subclasses">21.6</A>: When should I use type qualifiers, and when should I use subclasses?<BR>
<A HREF="#faq-annotate-existing-program">21.7</A>: How do I get started annotating an existing program?<BR>
<A HREF="#faq-run-on-all-files">21.8</A>: How do I run a checker on all my source files?<BR>
<A HREF="#faq-shorten-command-line">21.9</A>: How do I shorten the command line when invoking a checker?<BR>
<A HREF="#faq-create-a-checker">21.10</A>: How do I create a new checker?<BR>
<A HREF="#faq-declarative-syntax-for-type-rules">21.11</A>: Why is there no declarative syntax for writing type rules?<BR>
<A HREF="#faq-type-checking-vs-bug-detectors">21.12</A>: Why not just use a bug detector (like FindBugs)?<BR>
<A HREF="#faq-jml">21.13</A>: How does pluggable type-checking compare with JML?<BR>
<A HREF="#faq-array-syntax-meaning">21.14</A>: What is the meaning of array annotations such as <TT>@NonNull Object @Nullable []</TT>?<BR>
<A HREF="#faq-list-map-nonnull-typeargs">21.15</A>: Why are the type parameters to <TT>List</TT> and <TT>Map</TT> annotated as <TT>@NonNull</TT>?<BR>
<A HREF="#faq-run-time-checking">21.16</A>: How can I do run-time monitoring of properties that were not statically checked?</P><!--TOC section Are type annotations easy to read and write?-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="faq-ease-of-use">21.1</A>&#XA0;&#XA0;Are type annotations easy to read and write?</H2><!--SEC END --><P>The paper
<A HREF="http://www.cs.washington.edu/homes/mernst/pubs/pluggable-checkers-issta2008-abstract.html">&#X201C;Practical
pluggable types for Java&#X201D;</A>&#XA0;[<A HREF="#PapiACPE2008">PAC<SUP>+</SUP>08</A>] discusses case studies in
which programmers
found type annotations to be natural to read and write. The code
continued to feel like Java, and the type-checking errors were easy to
comprehend and often led to real bugs.</P><P>You don&#X2019;t have to take our word for it, though. You can try the
Checker Framework for yourself.</P><P>The difficulty of adding and verifying annotations depends on your program.
If your program is well-designed and -documented, then skimming the
existing documentation and writing type annotations is extremely easy.
Otherwise, you may find yourself spending a lot of time trying to
understand, reverse-engineer, or fix bugs in your program, and then just a
moment writing a type annotation that describes what you discovered. This
process inevitably improves your code. You must decide whether it is a
good use of your time. For code that is not causing trouble now and is
unlikely to do so in the future (the code is bug-free, and you do not
anticipate changing it or using it in new contexts), then the
effort of writing type annotations for it may not be justified.</P><!--TOC section Will my code become cluttered with type annotations?-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="faq-code-clutter">21.2</A>&#XA0;&#XA0;Will my code become cluttered with type annotations?</H2><!--SEC END --><P>As with any language feature, it is possible to write ugly code that
over-uses annotations. However, in normal use, very few annotations need
to be written. Figure 1 of the paper
<A HREF="http://www.cs.washington.edu/homes/mernst/pubs/pluggable-checkers-issta2008-abstract.html">Practical
pluggable types for Java</A>&#XA0;[<A HREF="#PapiACPE2008">PAC<SUP>+</SUP>08</A>] reports data for over
350,000 lines of type-annotated code:</P><UL CLASS="itemize"><LI CLASS="li-itemize">
1 annotation per 62 lines for nullness annotations (<TT>@NonNull</TT>, <TT>@Nullable</TT>, etc.)
</LI><LI CLASS="li-itemize">1 annotation per 1736 lines for interning annotations (<TT>@Interned</TT>)
</LI><LI CLASS="li-itemize">1 annotation per 27 lines for immutability annotations (IGJ type system)
</LI></UL><P>Furthermore, these numbers are for annotating existing code. New code that
is written with the type annotation system in mind is cleaner and more
correct, so it requires even fewer annotations.</P><P>In other words, annotations do not clutter code, and they are used much
less frequently than generic types, which Java programmers find acceptable.</P><!--TOC section Can a pluggable type-checker give an absolute guarantee of correctness?-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="faq-no-absolute-guarantee">21.3</A>&#XA0;&#XA0;Can a pluggable type-checker give an absolute guarantee of correctness?</H2><!--SEC END --><P>Each checker looks for certain errors. You can use multiple checkers, but
even then your program might still contain other kinds of errors.</P><P>If you run a pluggable checker on only part of the code of a program, then
you do not get a guarantee that all parts of the program satisfy the type
system (that is, are error-free). An example is a framework that clients
are intended to extend. In this case, you should recommend that clients
run the pluggable checker. There is no way to force users to do so, so you
may want to retain dynamic checks or use other mechanisms to detect errors.</P><P>There are other circumstances in which a static type-checker may fail to
detect a possible type error. In Java, these include arrays, casts, raw
types, reflection, separate compilation (bytecodes from unverified sources),
native code, etc. (For details, see section&#XA0;<A HREF="#checker-guarantees">2.3</A>.)
Java uses dynamic checks for most of these, so that the
type error cannot cause a security vulnerability or a crash. The pluggable
type-checkers inherit many (not all) of these weaknesses of Java
type-checking, but do not currently have built-in dynamic checkers.
Writing dynamic checkers would be an interesting and valuable project.</P><P>Even if a tool such as a pluggable checker cannot give an ironclad
guarantee of correctness, it is still useful. It can finding errors, 
excluding certain types of possible problems (e.g., restricting the
possible class of problems), and increasing confidence in a piece of
software.</P><!--TOC section I don&#X2019;t make type errors, so would pluggable type checking help me?-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="never-make-type-errors">21.4</A>&#XA0;&#XA0;I don&#X2019;t make type errors, so would pluggable type checking help me?</H2><!--SEC END --><P>Occasionally, a developer says that he makes no errors that typechecking
could catch, or that any such errors are unimportant because they have low
impact and are easy to fix. When I investigate the claim, I invariably
find that the developer is mistaken.</P><P>Very frequently, the developer has underestimated what typechecking can
discover. Not every type error leads to an exception being thrown; and
even if an exception is thrown, it may not seem related to classical types.
Remember that a type system can discover
null pointer dereferences,
incorrect side effects, 
security errors such as information leakage or SQL injection,
partially-initialized data,
and many other errors. Even where type-checking does not discover a
problem directly, it can indicate code with bad smells, thus revealing
problems, improving documentation, and making future maintenance easier.</P><P>There are other ways to discover errors, including extensive testing and
debugging. But type-checking is a good complement to these. It is more
effective for some problems, and less effective for other problems. It can
reduce (but not eliminate) the time and effort that you spend on other
approaches. There are many important errors that type checking and other
automated approaches cannot find; pluggable typechecking gives you more
time to focus on those.</P><!--TOC section Why shouldn&#X2019;t a qualifier apply to both types and declarations?-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="faq-no-annotation-on-types-and-declarations">21.5</A>&#XA0;&#XA0;Why shouldn&#X2019;t a qualifier apply to both types and declarations?</H2><!--SEC END --><P>It is bad style for an annotation to apply to both types and declarations.
In other words, every annotation should have a <TT>@Target</TT> meta-annotation,
and the <TT>@Target</TT> meta-annotation should list either only declaration
locations or only type annotations. (It&#X2019;s OK for an annotation to target
both <TT>ElementType.TYPE_PARAMETER</TT> and <TT>ElementType.TYPE_USE</TT>, but no
other declaration location along with <TT>ElementType.TYPE_USE</TT>.)</P><P>Sometimes, it may seem tempting for an annotation to apply to both type
uses and (say) method declarations. Here is a hypothetical example:</P><BLOCKQUOTE CLASS="quote">
&#X201C;Each <TT>Widget</TT> type may have a <TT>@Version</TT> annotation.
I wish to prove that versions of widgets don&#X2019;t get assigned to
incompatible variables, and that older code does not call newer code (to
avoid problems when backporting).<P>A <TT>@Version</TT> annotation could be written like so:</P><PRE CLASS="verbatim">  @Version("2.0") Widget createWidget(String value) { ... }
</PRE><P><TT>@Version("2.0")</TT> on the method could mean that the <TT>createWidget</TT> method
only appears in the 2.0 version. <TT>@Version("2.0")</TT> on the return type
could mean that the returned <TT>Widget</TT> should only be used by code that
uses the 2.0 API of <TT>Widget</TT>. It should be possible to specify these
independently, such as a 2.0 method that returns a value that allows the
1.0 API method invocations.&#X201D;
</P></BLOCKQUOTE><P>Both of these are type properties and should be specified with type
annotations. No method annotation is necessary or desirable. The best way
to require that the receiver has a certain property is to use a type
annotation on the receiver of the method. (Slightly more formally, the
property being checked is compatibility between the annotation on the type
of the formal parameter receiver and the annotation on the type of the
actual receiver.)</P><P>Another example of a type-and-declaration annotation that represents poor
design is JCIP&#X2019;s <TT>@GuardedBy</TT> annotation&#XA0;[<A HREF="#Goetz2006">GPB<SUP>+</SUP>06</A>]. As discussed
in Section&#XA0;<A HREF="#jcip-annotations">7.1.3</A>, it means two different things when
applied to a field or a method. To reduce confusion and increase
expressiveness, the Lock Checker (see Chapter&#XA0;<A HREF="#lock-checker">7</A>) uses the
<TT>@Holding</TT> annotation for one of these meanings, rather than overloading
<TT>@GuardedBy</TT> with two distinct meanings.</P><!--TOC section When should I use type qualifiers, and when should I use subclasses?-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="faq-qualifiers-vs-subclasses">21.6</A>&#XA0;&#XA0;When should I use type qualifiers, and when should I use subclasses?</H2><!--SEC END --><P>In brief, use subtypes when you can, and use type qualifiers when you cannot
use subtypes.
For more details, see section&#XA0;<A HREF="#when-to-use-type-qualifiers">2.4.6</A>.</P><!--TOC section How do I get started annotating an existing program?-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="faq-annotate-existing-program">21.7</A>&#XA0;&#XA0;How do I get started annotating an existing program?</H2><!--SEC END --><P>See Section&#XA0;<A HREF="#get-started-with-legacy-code">2.4.1</A>.</P><!--TOC section How do I run a checker on all my source files?-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="faq-run-on-all-files">21.8</A>&#XA0;&#XA0;How do I run a checker on all my source files?</H2><!--SEC END --><P>The <TT>javac</TT> compiler halts compilation as soon as it processes a
source file with an error, including an error issued by a pluggable
type-checker. Section&#XA0;<A HREF="#running">2.2</A> describes the <TT>-Awarns</TT> command-line
option that turns checker errors into warnings, permitting <TT>javac</TT> to
continue past the first erroneous source file.</P><!--TOC section How do I shorten the command line when invoking a checker?-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="faq-shorten-command-line">21.9</A>&#XA0;&#XA0;How do I shorten the command line when invoking a checker?</H2><!--SEC END --><P>The compile options to javac can be a pain to type; for example,
<TT>javac -processor checkers.nullness.NullnessChecker ...</TT>.
See Section&#XA0;<A HREF="#checker-auto-discovery">2.2.2</A> for a way to avoid the need for
the <TT>-processor</TT> command-line option.</P><!--TOC section How do I create a new checker?-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="faq-create-a-checker">21.10</A>&#XA0;&#XA0;How do I create a new checker?</H2><!--SEC END --><P>In addition to using the checkers that are distributed with the Checker
Framework, you can write your own checker to check specific properties that
you care about. Thus, you can find and prevent the bugs that are most
important to you.</P><P>Chapter&#XA0;<A HREF="#writing-a-checker">19</A> gives
complete details regarding how to write a checker. It also suggests places
to look for more help, such as the <A HREF="doc/">Checker Framework
API documentation (Javadoc)</A> and the source code of the distributed
checkers.</P><P>To whet your interest and demonstrate how easy it is to get started, here
is an example of a complete, useful type checker.</P><PRE CLASS="verbatim">  @TypeQualifier
  @SubtypeOf(Unqualified.class)
  @Target({ElementType.TYPE_PARAMETER, ElementType.TYPE_USE})
  public @interface Encrypted { }
</PRE><P>Section&#XA0;<A HREF="#basic-example">13.2</A> explains this checker and tells
you how to run it.</P><!--TOC section Why is there no declarative syntax for writing type rules?-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="faq-declarative-syntax-for-type-rules">21.11</A>&#XA0;&#XA0;Why is there no declarative syntax for writing type rules?</H2><!--SEC END --><P>A type system implementer can declaratively specify the type qualifier
hierarchy (Section&#XA0;<A HREF="#declarative-hierarchy">19.3.1</A>) and the type introduction rules
(Section&#XA0;<A HREF="#declarative-type-introduction">19.4.1</A>). However, the Checker
Framework uses a procedural syntax for specifying type-checking
rules (Section&#XA0;<A HREF="#extending-visitor">19.5</A>).
A declarative syntax might be more concise, more readable, and more
verifiable than a procedural syntax.</P><P>We have not found the procedural syntax to be the most important impediment
to writing a checker.</P><P>Previous attempts to devise a declarative syntax 
for realistic type systems have failed; see a technical
paper&#XA0;[<A HREF="#PapiACPE2008">PAC<SUP>+</SUP>08</A>] for a discussion. When an
adequate syntax exists, then the Checker Framework can be extended to
support it.</P><!--TOC section Why not just use a bug detector (like FindBugs)?-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="faq-type-checking-vs-bug-detectors">21.12</A>&#XA0;&#XA0;Why not just use a bug detector (like FindBugs)?</H2><!--SEC END --><P>Pluggable type-checking finds more bugs than a bug detector does, for any
given variety of bug.</P><P>A bug detector like <A HREF="http://findbugs.sourceforge.net/">FindBugs</A>&#XA0;[<A HREF="#HovemeyerP2004">HP04</A>, <A HREF="#HovemeyerSP2005">HSP05</A>],
<A HREF="http://artho.com/jlint/">JLint</A>&#XA0;[<A HREF="#Artho2001">Art01</A>], or
<A HREF="http://pmd.sourceforge.net/">PMD</A>&#XA0;[<A HREF="#Copeland2005">Cop05</A>] aims to find <EM>some</EM>
of the most obvious bugs in your program. It uses a lightweight analysis,
then uses heuristics to discard some of its warnings. Thus, even if the tool
prints no warnings, your code might still have errors &#X2014; maybe the
analysis was too weak to find them, or the tool&#X2019;s heuristics classified the
warnings as likely false positives and discarded them.</P><P>A type checker aims to find <EM>all</EM> the bugs (of certain varieties).
It requires you to write type qualifiers in your program, or to use a tool
that infers types. Thus, it requires more work from the programmer, and in
return it gives stronger guarantees.</P><P>Each tool is useful in different circumstances, depending on how important
your code is and your desired level of confidence in your code. For more
details on the comparison, see section&#XA0;<A HREF="#other-tools">22.5</A>. For a case study
that compared the nullness analysis of FindBugs, JLint, PMD, and the
Checker Framework, see section 6 of the paper
<A HREF="http://www.cs.washington.edu/homes/mernst/pubs/pluggable-checkers-issta2008.pdf">&#X201C;Practical pluggable types for Java&#X201D;</A>&#XA0;[<A HREF="#PapiACPE2008">PAC<SUP>+</SUP>08</A>].</P><!--TOC section How does pluggable type-checking compare with JML?-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="faq-jml">21.13</A>&#XA0;&#XA0;How does pluggable type-checking compare with JML?</H2><!--SEC END --><P><A HREF="http://www.cs.ucf.edu/~leavens/JML/">JML</A>, the Java Modeling
Language&#XA0;[<A HREF="#LeavensBR2006:JML">LBR06</A>], is a language for writing formal
specifications. JML aims to be more expressive than pluggable
type-checking. JML is not as practical as pluggable type-checking.</P><P>A programmer can write a JML specification that
describes arbitrary facts about program behavior. Then, the programmer can
use formal reasoning or a theorem-proving tool to verify that the code
meets the specification. Run-time checking is also possible.
By contrast, pluggable type-checking can express a more limited set of
properties about your program.</P><P>The JML toolset is less mature. For instance, if your code uses
generics or other features of Java 5, then you cannot use JML. 
However, JML has a run-time checker, which the Checker Framework currently
lacks.</P><!--TOC section What is the meaning of array annotations such as <TT>@NonNull Object @Nullable []</TT>?-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="faq-array-syntax-meaning">21.14</A>&#XA0;&#XA0;What is the meaning of array annotations such as <TT>@NonNull Object @Nullable []</TT>?</H2><!--SEC END --><P><TT>@NonNull Object @Nullable []</TT> is a possibly-null array of non-null
objects. Note that even though the first token in the type is
&#X201C;<TT>@NonNull</TT>&#X201D;, that annotation applies to the element
type <TT>Object</TT>. The annotation <TT>@Nullable</TT> applies to the
array (<TT>[]</TT>).</P><P>Similarly,
<TT>@Nullable Object @NonNull []</TT> is a non-null array of possibly-null
objects.</P><!--TOC section Why are the type parameters to <TT>List</TT> and <TT>Map</TT> annotated as <TT>@NonNull</TT>?-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="faq-list-map-nonnull-typeargs">21.15</A>&#XA0;&#XA0;Why are the type parameters to <TT>List</TT> and <TT>Map</TT> annotated as <TT>@NonNull</TT>?</H2><!--SEC END --><P>The annotation on <TT>java.util.Collection</TT> only allows non-null elements:</P><PRE CLASS="verbatim">  public interface Collection&lt;E extends @NonNull Object&gt; {
    ...
  }
</PRE><P>Thus, you will get a type error if you write code like
<TT>Collection&lt;@Nullable Object&gt;</TT>.
A nullable
type parameter is also forbidden for certain other collections, including
<TT>AbstractCollection</TT>, <TT>List</TT>, <TT>Map</TT>, and <TT>Queue</TT>.</P><P>The <TT>extends @NonNull Object</TT> bound is a direct consequence of the design
of the collections classes; it merely formalizes the Javadoc specification.
The Javadoc for <TT>Collection</TT> states:</P><BLOCKQUOTE CLASS="quote">
Some list implementations have restrictions on the elements that they may
contain. For example, some implementations prohibit null elements, &#X2026;</BLOCKQUOTE><P>Here are some consequences of the requirement to detect all nullness errors
at compile time. If even one subclass of a given collection class may
prohibit null, then the collection class and all its subclasses must
prohibit null. Conversely, if a collection class is specified to accept
null, then all its subclasses must honor that specification.</P><P>The Checker Framework&#X2019;s annotations make apparent a flaw in the JDK
design, and helps you to avoid problems that might be caused by that flaw.</P><!--TOC paragraph Justification from type theory-->
<H5 CLASS="paragraph"><!--SEC ANCHOR -->Justification from type theory</H5><!--SEC END --><P>
Suppose <TT>B</TT> is a subtype of <TT>A</TT>.
Then an overriding method in <TT>B</TT> must have a stronger (or equal) signature
than the overridden method in&#XA0;<TT>A</TT>. In a stronger signature, the formal
parameter types may be supertypes, and the return type may be a subtype.
Here are examples:</P><PRE CLASS="verbatim">  class A           {  @NonNull Object Number m1( @NonNull Object arg) { ... } }
  class B extends A { @Nullable Object Number m1( @NonNull Object arg) { ... } } // error!
  class C extends A {  @NonNull Object Number m1(@Nullable Object arg) { ... } } // OK
  class D           { @Nullable Object Number m2(@Nullable Object arg) { ... } }
  class E extends D {  @NonNull Object Number m2(@Nullable Object arg) { ... } } // OK
  class F extends D { @Nullable Object Number m2( @NonNull Object arg) { ... } } // error!
</PRE><P>According to these rules, since some subclasses of <TT>Collection</TT> do not
permit nulls, then <TT>Collection</TT> cannot either:</P><PRE CLASS="verbatim">  // does not permit null elements
  class PriorityQueue&lt;E&gt; implements Collection&lt;E&gt; {
    boolean add(E);
    ...
  }
  // must not permit null elements, or PriorityQueue would not be a subtype of Collection
  interface Collection&lt;E&gt; {
    boolean add(E);    
    ...
  }
</PRE><!--TOC paragraph Justification from checker behavior-->
<H5 CLASS="paragraph"><!--SEC ANCHOR -->Justification from checker behavior</H5><!--SEC END --><P>Suppose that you changed the bound in the <TT>Collection</TT> declaration to
<TT>extends @Nullable Object</TT>. Then, the checker would issue no warning for
this method:</P><PRE CLASS="verbatim">  static void addNull(Collection l) {
    l.add(null);
  }
</PRE><P>However, calling this method <EM>can</EM> result in a null pointer exception,
for instance caused by the following code:</P><PRE CLASS="verbatim">  addNull(new PriorityQueue());
</PRE><P>Therefore, the bound must remain as <TT>extends @NonNull Object</TT>.</P><P>By contrast, this code is OK because <TT>ArrayList</TT> is documented to support
null elements:</P><PRE CLASS="verbatim">  static void addNull(ArrayList l) {
    l.add(null);
  }
</PRE><P>Therefore, the upper bound in <TT>ArrayList</TT> is <TT>extends @Nullable Object</TT>.
Any subclass of <TT>ArrayList</TT> must also support null elements.</P><!--TOC paragraph Suppressing warnings-->
<H5 CLASS="paragraph"><!--SEC ANCHOR -->Suppressing warnings</H5><!--SEC END --><P>Suppose your program has a list variable, and you know that any list referenced
by that variable will definitely support null. Then, you can suppress the
warning:</P><PRE CLASS="verbatim">  @SuppressWarnings("nullness:generic.argument")
  static void addNull(List l) {
    l.add(null);
  }
</PRE><P>You need to use <TT>@SuppressWarnings("nullness:generic.argument")</TT>
whenever you use a collection that may contain <TT>null</TT> elements in
contradiction to its documentation. Fortunately, such uses are relatively
rare.</P><P>For more details on suppressing nullness warnings, see
Section&#XA0;<A HREF="#suppressing-warnings-nullness">3.4</A>.</P><!--TOC section How can I do run-time monitoring of properties that were not statically checked?-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="faq-run-time-checking">21.16</A>&#XA0;&#XA0;How can I do run-time monitoring of properties that were not statically checked?</H2><!--SEC END --><P>Currently, the Checker Framework has no support for adding code to check,
at run time, code that was not checked (see
Chapter&#XA0;<A HREF="#warnings-and-legacy">17</A> for reasons that code might not be
checked). An exception is the Nullness Checker, which has ways to
dynamically check nullness via assertions and casts (the
<A HREF="doc/checkers/nullness/NullnessUtils.html#castNonNull(T)"><TT>NullnessUtils.castNonNull</TT></A> method); see
Section&#XA0;<A HREF="#suppressing-warnings-with-assertions">3.4.1</A>.</P><P>More general support would be an interesting and valuable project. If you
are able to add run-time verification functionality, we would gladly
welcome it as a contribution to the Checker Framework.</P><HR><!--TOC chapter Troubleshooting and getting help-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="troubleshooting">Chapter&#XA0;22</A>&#XA0;&#XA0;Troubleshooting and getting help</H1><!--SEC END --><P>Please read the entire manual, including this chapter and the FAQ
(Chapter&#XA0;<A HREF="#faq">21</A>), because the manual might already answer your question.
If not, you can use the mailing list,
<TT>checker-framework-discuss@googlegroups.com</TT>, to ask other users for
help. For archives and to subscribe, see <A HREF="http://groups.google.com/group/checker-framework-discuss"><TT>http://groups.google.com/group/checker-framework-discuss</TT></A>.
To report bugs, use the issue tracker at
<A HREF="http://code.google.com/p/checker-framework/issues/list"><TT>http://code.google.com/p/checker-framework/issues/list</TT></A>.
If you want to help out, you can choose a bug and fix it, or select a
project from the ideas list at
<A HREF="http://code.google.com/p/checker-framework/wiki/Ideas"><TT>http://code.google.com/p/checker-framework/wiki/Ideas</TT></A>.</P><!--TOC section Common problems and solutions-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="common-problems">22.1</A>&#XA0;&#XA0;Common problems and solutions</H2><!--SEC END --><UL CLASS="itemize"><LI CLASS="li-itemize">To verify that you are using the compiler you think you are, you can add
<TT>-version</TT> to the command line. For instance, instead of running
<TT>javac -g MyFile.java</TT>, you can run <TT>javac </TT><TT><U>-version</U></TT><TT> -g
MyFile.java</TT>. Then, javac will print out its version number in addition
to doing its normal processing.</LI><LI CLASS="li-itemize">If you get the error<PRE CLASS="verbatim">com.sun.tools.javac.code.Symbol$CompletionFailure: class file for com.sun.source.tree.Tree not found
</PRE><P>then you are using the source installation and file <TT>tools.jar</TT> is not
on your classpath. See the installation instructions
(Section&#XA0;<A HREF="#installation">1.2</A>).</P></LI><LI CLASS="li-itemize">If you get an error such as<PRE CLASS="verbatim">package checkers.nullness.quals does not exist
</PRE><P>despite no apparent use of <TT>import checkers.nullness.quals.*;</TT> in
the source code, then perhaps
<TT>jsr308_imports</TT> is set as a Java system property, a shell
environment variable, or a command-line option (see
Section&#XA0;<A HREF="#jsr308_imports">17.3.2</A>). You can solve this by unsetting the
variable/option, or by ensuring that the <TT>checkers.jar</TT> file is on
your classpath.</P><P>If the error is </P><PRE CLASS="verbatim">package 'checkers.nullness.quals does not exist
</PRE><P>(note the extra apostrophe!), then you have probably mis-used quoting when
supplying the <TT>jsr308_imports</TT> environment variable.</P><PRE CLASS="verbatim">package checkers.nullness.quals does not exist
</PRE></LI><LI CLASS="li-itemize">If a checker seems to be ignoring the annotation on a method, then it is
possible that the checker is reading the method&#X2019;s signature from its
<TT>.class</TT> file, but the <TT>.class</TT> file was not created by the JSR
308 compiler. You can check whether the annotations actually appear in the
<TT>.class</TT> file by using the <TT>javap</TT> tool.<P>If the annotations do not appear in the <TT>.class</TT> file, here are two
ways to solve the problem:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Re-compile the method&#X2019;s class with the Type Annotations compiler. This will
ensure that the type annotations are written to the class file, even if
no type-checking happens during that execution.
</LI><LI CLASS="li-itemize">Pass the method&#X2019;s file explicitly on the command line when type-checking,
so that the compiler reads its source code instead of its <TT>.class</TT>
file.
</LI></UL></LI><LI CLASS="li-itemize">If the compiler reports that it cannot find a method from the
JDK or another external library, then maybe the stub/skeleton file for that
class is incomplete. You can edit it to add the missing method. The
libraries appear, for example, at <TT>checkers/jdk/nullness/src/</TT> for the
Nullness checker.<P>The error might take one of these forms:</P><PRE CLASS="verbatim">method sleep in class Thread cannot be applied to given types
cannot find symbol: constructor StringBuffer(StringBuffer)
</PRE></LI><LI CLASS="li-itemize">If you get an error like the following when using the Ant task
(Section&#XA0;<A HREF="#ant-task">20.2</A>),<PRE CLASS="verbatim">...\build.xml:59: Error running ${env.CHECKERS}\binary\javac.bat compiler
</PRE><P>then the problem may be that you have not set the CHECKERS environment
variable, as described in Section&#XA0;<A HREF="#windows-installation">20.1.2</A>. Or, maybe
you made it a user variable instead of a system variable.</P></LI><LI CLASS="li-itemize">If you get one of these errors:<PRE>
The hierarchy of the type <EM>ClassName</EM> is inconsistent

The type com.sun.source.util.AbstractTypeProcessor cannot be resolved.
  It is indirectly referenced from required .class files", 
</PRE><P>then you are missing <TT>jsr308-all.jar</TT> from your classpath.</P></LI><LI CLASS="li-itemize">If you get the error<PRE CLASS="verbatim">  java.lang.ArrayStoreException: sun.reflect.annotation.TypeNotPresentExceptionProxy
</PRE><P>then an annotation is not present at run time that was present at compile
time. For example, maybe when you compiled the code, the <TT>@NonNull</TT>
annotation was available, but it was not available at run time.
You can use JDK 7 at run time, or compile
with a Java 6 compiler that will ignore the annotations in comments.</P></LI></UL><!--TOC subsection Known problems in the framework-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->22.1.1&#XA0;&#XA0;Known problems in the framework<A NAME="known-problems"></A></H3><!--SEC END --><UL CLASS="itemize"><LI CLASS="li-itemize">The framework may not parse annotations from skeleton files if the
skeleton files are older than the classfiles. Running <TT>ant
touch-jdk</TT> solves this problem, by applying the 
<TT>touch</TT> program to each distributed skeleton file.</LI><LI CLASS="li-itemize">The framework is missing a check for type argument subtyping in
method invocations if the type arguments are inferred.</LI><LI CLASS="li-itemize">The checks for enclosed types are not yet fully tested.</LI></UL><!--TOC subsection Known problems in the Nullness checker-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->22.1.2&#XA0;&#XA0;Known problems in the Nullness checker</H3><!--SEC END --><UL CLASS="itemize"><LI CLASS="li-itemize">
The Nullness checker is often able to determine that a call to
<TT>Map.get()</TT> will not return null. This enables the checker to avoid
issuing false positive warnings, in circumstances like the following.<PRE CLASS="verbatim">    @NonNull String value;
    if (myMap.containsKey(key)) {
      value = myMap.get(key);
    }
    for (String keyInMap : myMap.keySet()) {
        value = myMap.get(keyInMap);
    }
</PRE><P>The Nullness checker can sometimes fail to issue a warning if the map is
modified or re-assigned between the check of <TT>containsKey</TT> and the
call to <TT>get</TT>.</P></LI><LI CLASS="li-itemize">The Nullness checker issues a warning when a constructor does not
initialize every non-null field. However, because the checker does not
fully implement all of Java&#X2019;s definite assignment rules (e.g., for
<TT>finally</TT> blocks), the checker sometimes issues a false positive
warning. The checker&#X2019;s behavior is sound but unnecessarily restrictive.
If you encounter this problem in practice, please submit a bug report so
that we can improve the checker.</LI></UL><!--TOC section How to report problems-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="reporting-bugs">22.2</A>&#XA0;&#XA0;How to report problems</H2><!--SEC END --><P>If you have a problem with any checker, or with the Checker Framework,
please file a bug at 
<A HREF="http://code.google.com/p/checker-framework/issues/list"><TT>http://code.google.com/p/checker-framework/issues/list</TT></A>.
(First, check whether there is an existing bug report for that issue.)</P><P>Alternately (especially if your communication is not a bug report), you can
send mail to checker-framework-dev@googlegroups.com.
We welcome suggestions, annotated libraries, bug fixes, new
features, new checker plugins, and other improvements.</P><P>Please ensure that your bug report is clear and that it is complete.
Otherwise, we may be unable to understand it or to reproduce it, either of
which would prevent us from fixing the bug. Your bug report will be most
helpful if you:</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Add <TT>-version -verbose</TT> to the javac options. This causes the compiler to output
debugging information, including its version number.
</LI><LI CLASS="li-itemize">Indicate exactly what you did. Don&#X2019;t skip any steps, and don&#X2019;t merely
describe your actions in words. Show the exact commands by attaching a
file or using cut-and-paste from your command shell;
</LI><LI CLASS="li-itemize">Include all files that are necessary to reproduce the problem. This
includes every file that is used by any of the commands you reported, and
possibly other files as well.
</LI><LI CLASS="li-itemize">Indicate exactly what the result was by attaching a file or using
cut-and-paste from your command shell (don&#X2019;t merely describe it in
words). Also indicate what you expected the result to be &#X2014; remember, a
bug is a difference between desired and actual outcomes.
</LI></UL><P>A particularly useful format for a test case is as a diff, or a new file,
for the existing checker test cases. For instance, for the Nullness
Checker, see directory <TT>checker-framework/checkers/tests/nullness/</TT>.</P><!--TOC section Building from source-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="build-source">22.3</A>&#XA0;&#XA0;Building from source</H2><!--SEC END --><P>The Checker Framework release (Section&#XA0;<A HREF="#installation">1.2</A>) contains
everything that most users need, both to use the distributed checkers and
to write your own checkers. This section describes how to re-build its
binaries from source. You will be using the latest development version of
the Checker Framework, rather than an official release.</P><!--TOC subsection Obtain the source-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->22.3.1&#XA0;&#XA0;Obtain the source</H3><!--SEC END --><P>Obtain the latest source code from the version control repository:</P><PRE CLASS="verbatim">export JSR308=$HOME/jsr308
mkdir -p $JSR308
cd $JSR308
hg clone https://jsr308-langtools.googlecode.com/hg/ jsr308-langtools
hg clone https://checker-framework.googlecode.com/hg/ checker-framework
</PRE><P>(Alternately, you could use the version of the source code that is packaged
in the Checker Framework release.)</P><!--TOC subsection Build the Type Annotations compiler-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->22.3.2&#XA0;&#XA0;Build the Type Annotations compiler</H3><!--SEC END --><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
Set the <TT>JAVA_HOME</TT> environment variable to the location of your JDK 6 or
7 installation (not the JRE installation. (It may already be set for Ant to work.)</LI><LI CLASS="li-enumerate">Compile the Type Annotations javac compiler and the javap tool:<PRE CLASS="verbatim">  cd $JSR308/jsr308-langtools/make
  ant clean build-javac build-javap
</PRE></LI><LI CLASS="li-enumerate">Add the <TT>jsr308-langtools/dist/bin</TT> directory to the front of your PATH environment variable.
Example command:<PRE CLASS="verbatim">  export PATH=$JSR308/jsr308-langtools/dist/bin:${PATH}
</PRE></LI></OL><!--TOC subsection Build the Checker Framework-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->22.3.3&#XA0;&#XA0;Build the Checker Framework<A NAME="building"></A></H3><!--SEC END --><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
Run <TT>ant</TT> to create <TT>checkers.jar</TT>:<PRE CLASS="verbatim">  cd $JSR308/checker-framework/checkers
  ant
</PRE></LI><LI CLASS="li-enumerate">Add <TT>tools.jar</TT> and <TT>checkers.jar</TT> to your classpath
(If you do not do this, you will have to supply the <TT>-cp</TT> option
whenever you run <TT>javac</TT> and use a checker plugin.)
Example command:<PRE CLASS="verbatim">  export CLASSPATH=${CLASSPATH}:$JAVA_HOME/lib/tools.jar:$JSR308/checker-framework/checkers/checkers.jar
</PRE></LI><LI CLASS="li-enumerate">Test that everything works:<UL CLASS="itemize"><LI CLASS="li-itemize">Run <TT>ant all-tests</TT> in the <TT>checkers</TT> directory:
<PRE CLASS="verbatim"> cd $JSR308/checker-framework/checkers
ant all-tests
</PRE></LI><LI CLASS="li-itemize">Run the Nullness checker examples (see
Section&#XA0;<A HREF="#nullness-example">3.7</A>).</LI></UL></LI></OL><!--TOC subsection Build the Checker Framework manual (this document)-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->22.3.4&#XA0;&#XA0;Build the Checker Framework manual (this document)</H3><!--SEC END --><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
To build the manual you will need plume-bib (<A HREF="http://code.google.com/p/plume-bib/"><TT>http://code.google.com/p/plume-bib/</TT></A>) and H<FONT SIZE=2><sup>E</sup></FONT>V<FONT SIZE=2><sup>E</sup></FONT>A (<A HREF="http://hevea.inria.fr/"><TT>http://hevea.inria.fr/</TT></A>) installed.</LI><LI CLASS="li-enumerate">Run <TT>make</TT> in the <TT>checkers/manual</TT> directory to build both the PDF and HTML versions of the manual.
</LI></OL><!--TOC section Learning more-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="learning-more">22.4</A>&#XA0;&#XA0;Learning more</H2><!--SEC END --><P>The technical paper &#X201C;Practical pluggable types for Java&#X201D;&#XA0;[<A HREF="#PapiACPE2008">PAC<SUP>+</SUP>08</A>]
(<A HREF="http://www.cs.washington.edu/homes/mernst/pubs/pluggable-checkers-issta2008.pdf"><TT>http://www.cs.washington.edu/homes/mernst/pubs/pluggable-checkers-issta2008.pdf</TT></A>)
gives more technical detail about many
aspects of the Checker Framework and its implementation.
The technical
paper also describes case
studies in which each of the checkers found
previously-unknown errors in real software.</P><!--TOC section Comparison to other tools-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="other-tools">22.5</A>&#XA0;&#XA0;Comparison to other tools</H2><!--SEC END --><P>A pluggable type-checker, such as those created by the Checker Framework,
aims to help you prevent or detect all errors of a given variety. An
alternate approach is to use a bug detector such as
<A HREF="http://findbugs.sourceforge.net/">FindBugs</A>,
<A HREF="http://artho.com/jlint/">JLint</A>, or
<A HREF="http://pmd.sourceforge.net/">PMD</A>.</P><P>A pluggable type-checker
differs from a bug detector in several ways:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
A type-checker aims to find <EM>all</EM> errors. Thus, it can verify the
<EM>absence</EM> of errors: if the type checker says there are no null
pointer errors in your code, then there are none. (This guarantee only
holds for the code it checks, of course; see
Section&#XA0;<A HREF="#checker-guarantees">2.3</A>.)<P>A bug detector aims to find <EM>some</EM> of the most obvious errors. Even
if it reports no errors, then there may still be errors in your code.</P><P>Both types of tools may issue false positive warnings; see
Section&#XA0;<A HREF="#suppressing-warnings">17.2</A>.</P></LI><LI CLASS="li-itemize">A type-checker requires you to annotate your code with type qualifiers,
or to run an inference tool that does so for you. A bug detector may not
require annotations. This means that it may be easier to get started
running a bug detector.</LI><LI CLASS="li-itemize">A type-checker may use a more sophisticated and complete analysis.
A bug detector typically does a more lightweight analysis, coupled with
heuristics to suppress false positives.<P>As one example, a type-checker can take advantage of annotations on
generic type parameters, such as <TT>List&lt;@NonNull String&gt;</TT>, permitting
it to be much more precise for code that uses generics.</P></LI></UL><P>A case study&#XA0;[<A HREF="#PapiACPE2008">PAC<SUP>+</SUP>08</A>, &#XA7;6] compared the Checker Framework&#X2019;s nullness
checker with those of FindBugs, JLint, and PMD. The case study was on a
well-tested program in daily use. The Checker Framework tool found 8
nullness errors. None of the other tools found any errors.</P><P>Also see the
<A HREF="http://types.cs.washington.edu/jsr308/">JSR 308</A>&#XA0;[<A HREF="#jsr308">Ern08</A>]
documentation for a detailed discussion of related work.</P><!--TOC section Credits and changelog-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="credits">22.6</A>&#XA0;&#XA0;Credits and changelog</H2><!--SEC END --><P>The key developers of the Checker Framework are Mahmood Ali, Telmo Correa,
Michael D. Ernst, and Matthew M. Papi.
Many users have provided valuable feedback, for which we are grateful.</P><P>Differences from previous versions of the checkers and framework can be found
in the <TT>changelog-checkers.txt</TT> file. This file is included in the
Checker Framework distribution and is also available on the web at
<A HREF="http://types.cs.washington.edu/checker-framework/current/changelog-checkers.txt"><TT>http://types.cs.washington.edu/checker-framework/current/changelog-checkers.txt</TT></A>.</P><HR><!--TOC chapter References-->
<H1 CLASS="chapter"><!--SEC ANCHOR -->References</H1><!--SEC END --><DL CLASS="thebibliography"><DT CLASS="dt-thebibliography">
<A NAME="Artho2001"><FONT COLOR=purple>[Art01]</FONT></A></DT><DD CLASS="dd-thebibliography">
Cyrille Artho.
Finding faults in multi-threaded programs.
Master&#X2019;s thesis, Swiss Federal Institute of Technology, March&#XA0;15,
2001.</DD><DT CLASS="dt-thebibliography"><A NAME="Copeland2005"><FONT COLOR=purple>[Cop05]</FONT></A></DT><DD CLASS="dd-thebibliography">
Tom Copeland.
<EM>PMD Applied</EM>.
Centennial Books, November 2005.</DD><DT CLASS="dt-thebibliography"><A NAME="JSR198"><FONT COLOR=purple>[Cro06]</FONT></A></DT><DD CLASS="dd-thebibliography">
Jose Cronembold.
JSR 198: A standard extension API for Integrated Development
Environments.
<A HREF="http://jcp.org/en/jsr/detail?id=198"><TT>http://jcp.org/en/jsr/detail?id=198</TT></A>, May&#XA0;8, 2006.</DD><DT CLASS="dt-thebibliography"><A NAME="JSR269"><FONT COLOR=purple>[Dar06]</FONT></A></DT><DD CLASS="dd-thebibliography">
Joe Darcy.
JSR 269: Pluggable annotation processing API.
<A HREF="http://jcp.org/en/jsr/detail?id=269"><TT>http://jcp.org/en/jsr/detail?id=269</TT></A>, May&#XA0;17, 2006.
Public review version.</DD><DT CLASS="dt-thebibliography"><A NAME="jsr308"><FONT COLOR=purple>[Ern08]</FONT></A></DT><DD CLASS="dd-thebibliography">
Michael&#XA0;D. Ernst.
Type Annotations specification (JSR 308).
<A HREF="http://types.cs.washington.edu/jsr308/"><TT>http://types.cs.washington.edu/jsr308/</TT></A>, September&#XA0;12, 2008.</DD><DT CLASS="dt-thebibliography"><A NAME="Evans96"><FONT COLOR=purple>[Eva96]</FONT></A></DT><DD CLASS="dd-thebibliography">
David Evans.
Static detection of dynamic memory errors.
In <EM>PLDI 1996, Proceedings of the SIGPLAN &#X2019;96 Conference on
Programming Language Design and Implementation</EM>, pages 44&#X2013;53, Philadelphia,
PA, USA, May&#XA0;21&#X2013;24, 1996.</DD><DT CLASS="dt-thebibliography"><A NAME="FahndrichL2003"><FONT COLOR=purple>[FL03]</FONT></A></DT><DD CLASS="dd-thebibliography">
Manuel F&#XE4;hndrich and K.&#XA0;Rustan&#XA0;M. Leino.
Declaring and checking non-null types in an object-oriented language.
In <EM>Object-Oriented Programming Systems, Languages, and
Applications (OOPSLA 2003)</EM>, pages 302&#X2013;312, Anaheim, CA, USA, November&#XA0;6&#X2013;8,
2003.</DD><DT CLASS="dt-thebibliography"><A NAME="FlanaganLLNSS02"><FONT COLOR=purple>[FLL</FONT><SUP><FONT COLOR=purple>+</FONT></SUP><FONT COLOR=purple>02]</FONT></A></DT><DD CLASS="dd-thebibliography">
Cormac Flanagan, K.&#XA0;Rustan&#XA0;M. Leino, Mark Lillibridge, Greg Nelson, James&#XA0;B.
Saxe, and Raymie Stata.
Extended static checking for Java.
In <EM>PLDI 2002, Proceedings of the </EM><EM>ACM</EM><EM> </EM><EM>SIGPLAN</EM><EM> 2002 Conference
on Programming Language Design and Implementation</EM>, pages 234&#X2013;245, Berlin,
Germany, June&#XA0;17&#X2013;19, 2002.</DD><DT CLASS="dt-thebibliography"><A NAME="Goetz2006:typedef"><FONT COLOR=purple>[Goe06]</FONT></A></DT><DD CLASS="dd-thebibliography">
Brian Goetz.
The pseudo-typedef antipattern: Extension is not type definition.
<A HREF="http://www.ibm.com/developerworks/library/j-jtp02216.html"><TT>http://www.ibm.com/developerworks/library/j-jtp02216.html</TT></A>,
February&#XA0;21, 2006.</DD><DT CLASS="dt-thebibliography"><A NAME="Goetz2006"><FONT COLOR=purple>[GPB</FONT><SUP><FONT COLOR=purple>+</FONT></SUP><FONT COLOR=purple>06]</FONT></A></DT><DD CLASS="dd-thebibliography">
Brian Goetz, Tim Peierls, Joshua Bloch, Joseph Bowbeer, David Holmes, and Doug
Lea.
<EM>Java Concurrency in Practice</EM>.
Addison-Wesley, 2006.</DD><DT CLASS="dt-thebibliography"><A NAME="HovemeyerP2004"><FONT COLOR=purple>[HP04]</FONT></A></DT><DD CLASS="dd-thebibliography">
David Hovemeyer and William Pugh.
Finding bugs is easy.
In <EM>Companion to Object-Oriented Programming Systems, Languages,
and Applications (OOPSLA 2004)</EM>, pages 132&#X2013;136, Vancouver, BC, Canada,
October&#XA0;26&#X2013;28, 2004.</DD><DT CLASS="dt-thebibliography"><A NAME="HovemeyerSP2005"><FONT COLOR=purple>[HSP05]</FONT></A></DT><DD CLASS="dd-thebibliography">
David Hovemeyer, Jaime Spacco, and William Pugh.
Evaluating and tuning a static analysis to find null pointer bugs.
In <EM>ACM SIGPLAN/SIGSOFT Workshop on Program Analysis for Software
Tools and Engineering (PASTE 2005)</EM>, pages 13&#X2013;19, Lisbon, Portugal,
September&#XA0;5&#X2013;6, 2005.</DD><DT CLASS="dt-thebibliography"><A NAME="LeavensBR2006:JML"><FONT COLOR=purple>[LBR06]</FONT></A></DT><DD CLASS="dd-thebibliography">
Gary&#XA0;T. Leavens, Albert&#XA0;L. Baker, and Clyde Ruby.
Preliminary design of JML: A behavioral interface specification
language for Java.
<EM>ACM SIGSOFT Software Engineering Notes</EM>, 31(3), March 2006.</DD><DT CLASS="dt-thebibliography"><A NAME="PapiACPE2008"><FONT COLOR=purple>[PAC</FONT><SUP><FONT COLOR=purple>+</FONT></SUP><FONT COLOR=purple>08]</FONT></A></DT><DD CLASS="dd-thebibliography">
Matthew&#XA0;M. Papi, Mahmood Ali, Telmo&#XA0;Luis Correa&#XA0;Jr., Jeff&#XA0;H. Perkins, and
Michael&#XA0;D. Ernst.
Practical pluggable types for Java.
In <EM>ISSTA 2008, Proceedings of the 2008 International Symposium
on Software Testing and Analysis</EM>, pages 201&#X2013;212, Seattle, WA, USA,
July&#XA0;22&#X2013;24, 2008.</DD><DT CLASS="dt-thebibliography"><A NAME="QuinonezTE2008"><FONT COLOR=purple>[QTE08]</FONT></A></DT><DD CLASS="dd-thebibliography">
Jaime Quinonez, Matthew&#XA0;S. Tschantz, and Michael&#XA0;D. Ernst.
Inference of reference immutability.
In <EM>ECOOP 2008 &#X2014; Object-Oriented Programming, 22nd European
Conference</EM>, pages 616&#X2013;641, Paphos, Cyprus, July&#XA0;9&#X2013;11, 2008.</DD><DT CLASS="dt-thebibliography"><A NAME="TschantzE2005"><FONT COLOR=purple>[TE05]</FONT></A></DT><DD CLASS="dd-thebibliography">
Matthew&#XA0;S. Tschantz and Michael&#XA0;D. Ernst.
Javari: Adding reference immutability to Java.
In <EM>Object-Oriented Programming Systems, Languages, and
Applications (OOPSLA 2005)</EM>, pages 211&#X2013;230, San Diego, CA, USA,
October&#XA0;18&#X2013;20, 2005.</DD><DT CLASS="dt-thebibliography"><A NAME="ZibinPAAKE2007"><FONT COLOR=purple>[ZPA</FONT><SUP><FONT COLOR=purple>+</FONT></SUP><FONT COLOR=purple>07]</FONT></A></DT><DD CLASS="dd-thebibliography">
Yoav Zibin, Alex Potanin, Mahmood Ali, Shay Artzi, Adam Kie&#X17C;un, and
Michael&#XA0;D. Ernst.
Object and reference immutability using Java generics.
In <EM>ESEC/FSE 2007: Proceedings of the 11th European Software
Engineering Conference and the 15th </EM><EM>ACM</EM><EM> </EM><EM>SIGSOFT</EM><EM> Symposium on the
Foundations of Software Engineering</EM>, pages 75&#X2013;84, Dubrovnik, Croatia,
September&#XA0;5&#X2013;7, 2007.</DD></DL><!--CUT END -->
<!--HTMLFOOT-->
<!--ENDHTML-->
</BODY>
</HTML>
