\documentclass{pracamgr}

% Encoding and charsets
\usepackage[utf8]{inputenc}
\usepackage{t1enc}

% Utility packages
\usepackage{url}
\usepackage{subfigure}
\usepackage{color}
\usepackage{amsthm}
\usepackage{enumitem}
\usepackage{mathtools}
\usepackage{bussproofs}

% Tikz
\usepackage{tikz}
\usetikzlibrary{positioning,shapes,arrows,shadows}

% Listings configuration 
\usepackage{listings}
\lstset{language=Java,columns=fullflexible, xleftmargin=1cm, captionpos=b, abovecaptionskip=12pt, belowcaptionskip=12pt}
% \renewcommand{\texttt}{\textsf}

\author{Sławomir Rudnicki}
\nralbumu{248277}

\title{Weryfikacja niemutowalności obiektów w Javie}
\tytulang{Verifying immutability of Java objects}
\kierunek{Informatyka}

\opiekun{dr. Aleksego Schuberta\\
  Instytut Informatyki\\
  }
\date{Maj 2011}
\dziedzina{11.3 Informatyka}
\klasyfikacja{D. Software\\
  D.2 SOFTWARE ENGINEERING\\
  D.2.4. Software/Program Verification
}

\keywords{Java, immutability, ownership, verification, Jimuva}

\newtheoremstyle{all}% name
     {\topsep}%      Space above
     {\topsep}%      Space below
     {\rm}%         Body font
     {}%         Indent amount (empty = no indent, \parindent = para indent)
     {}% Thm head font
     {:}%        Punctuation after thm head
     {\newline}%     Space after thm head: " " = normal interword space;
           %       \newline = linebreak
     {\textbf{#1 #2 (#3)}}%         Thm head spec (can be left empty, meaning `normal')

\theoremstyle{all}

\newtheorem{defi}{Definition}[chapter]
\newtheorem{invariant}{Property}
\newtheorem{verrule}{Rule}

\newcommand{\todo}[1]{{\color{red} [#1] }}
\newcommand{\crlf}[0]{$\ $ \newline}

% Hoare triple
\newcommand{\htr}[3]{\{#1\} #2 \{#3\}}

\begin{document}
\maketitle

\begin{abstract}
  \todo{Abstract}
\end{abstract}

\tableofcontents
%\listoffigures
%\listoftables

\chapter{Introduction}
\label{chap:intro}

\todo{More on immutability}

\section{Jimuva}
\label{sec:jimuva}

In their work, Haack, Poll, Schäfer and Schubert~\cite{haack} aim to
extend a Java-like language with specifications for object
immutability and ownership. They also provide a type inference system
for statically enforcing properties related to immutability.

This section aims to present the features of Jimuva which are
important to this work. Please refer to~\cite{haack} for a
comprehensive specification of the syntax and semantics of the
language. 

Throughout Section \ref{sec:modelling}, we will refer to how the
notions introduced below are reflected in the JimuvaChecker type
system. Section \ref{sec:checking} will deal with how the related
desired properties are verified in practice.

\subsection{Immutability and ownership specifications}
\label{subsec:imm-spec}

Haack et al. extended the object types of their language with
immutability and ownership specifications. Each object type in Jimuva
is therefore of the form
\begin{center}
  \texttt{C<ar, v>},
\end{center}
where \texttt{C} is a class name, \texttt{ar} determines the
\emph{access rights} to the object and \texttt{v} specifies the
\emph{owner} of the object.

Access rights may be used to restrict the operations that may be
performed on a given object. The access rights specification may be
one of three kinds:
\begin{itemize}
\item \texttt{C<rdwr, v> x} -- access to \texttt{x} is unrestricted, 
\item \texttt{C<rd, v> x} -- \texttt{x} is \emph{read-only}: its state
  cannot change throughout the lifespan of the object.
\item \texttt{C<myaccess, v> x} -- \texttt{x} has the same access
  rights as the object that references it.
\end{itemize}

Owner specifications may include an object identifier, or one of the
special identifiers and variables:
\begin{itemize}
\item \texttt{C<ar, world> x} -- no other object owns the given object
  \texttt{x}, making it freely accessible from the outside world. This
  is the default ownership specification in Jimuva.
\item \texttt{C<ar, myowner> x} -- the owner of the given object
  \texttt{x} is the same as the owner of the object which references
  \texttt{x} as a field, parameter or local variable.
\item \texttt{C<ar, this> x} -- the object \texttt{x} is a part of the 
  object which references \texttt{x}. 
\end{itemize}

\subsection{Auxiliary specifications}
\label{sub:jimuva-aux}

In addition to the immutability and ownership specifications for
objects, Jimuva introduces several other annotations that apply to
classes and methods.

\subsubsection{Immutable classes}

If a class is marked \texttt{immutable}, all its instances must be
immutable, i.e. access to them must be read-restricted.

\subsubsection{Read-only methods}

The \texttt{rdonly} attribute of a method indicates that the receiver
(the object referenced by \texttt{this}) must not be modified within
the method's body.

\subsubsection{Anonymous constructors}

An \emph{anonymous} constructor does not leak references to
\texttt{this} to other objects~\cite{vitek}. The body of a constructor
is the place where even immutable objects still mutate. Therefore, if
such a constructor would pass a reference to the constructed object to
the outside world, a foreign object could witness two different states
of the object, breaking the immutability property. All constructors of
an immutable class are verified for anonymity in
Jimuva.

\subsubsection{Write-local constructors}
\label{sub:jimuva-wrlocal}

Java visibility modifiers (\texttt{private}, \texttt{public} and
\texttt{protected}) constrain visibility with regards to classes
rather than objects. As a consequence, it would be possible for a
constructor to mutate an object of the same class different from the
constructed object. The \texttt{wrlocal} annotation was devised to
disallow such mutations: a \emph{write-local} constructor cannot
modify foreign objects nor call non-readonly methods on objects whose
ownership is not \texttt{world}. Such actions would break the
visibility modifiers, which are now to be understood as per-instance
constraints.

The concept of write-locality was deemed unneccessary in
JimuvaChecker, as explained in Section \ref{sub:mirroring-writelocal}.

\subsection{Ownership polymorphism}

\label{sec:jimuva:poly}

Jimuva allows for \emph{owner-polymorphic} methods, which have
parameters whose owner objects may be established in the invocation. A
polymorphic method is declared in the following way:
\begin{center}
  \texttt{<x,y> void copy(C<x> from, C<y> to)}
\end{center}
and the object identifiers \texttt{x} and \texttt{y} may be
instantiated to any object. The presence of owner-polymorphic methods
lets ease the ownership restriction on formal parameters of
methods. If it were not for owner polymorphism, each formal parameter
would have a required owner specified, which would be a huge
limitation on the usability of methods. Owner polymorphism allows for
creating methods which are universal, such as the \texttt{copy} method
declared above.

The authors note that if one or more arguments is instantiated to
\texttt{this}, it is important to ensure that no static aliases to
such internal representation objects are created, lest they could be
used to modify the state of \texttt{this}. Section \ref{sec:safe}
deals with this problem in the context of JimuvaChecker.

\chapter{The JimuvaChecker tool}

This chapter will present JimuvaChecker, the checker tool created as
part of this thesis. We aimed to implement the concepts of the
language Jimuva, as presented in section \ref{sec:jimuva}, and develop
a checker tool which would satisfy the following requirements:
\begin{itemize}
\item \textbf{Applicability to full Java.} The syntax of Jimuva
  differs from that of full Java. In some ways, it is reduced: there
  are no loops and even no conditional branches in the core
  language. In other ways, the syntax is modified -- for example, it
  utilizes let-binding of local variables rather than declarations --
  or extended, as it is the case with the ownership and access rights
  specifications and owner-polymorphism of methods.
\item \textbf{Efficient checking.} Checking the immutability
  properties of a system should come together with normal
  development. If there is no delay between compilation and
  immutability verification, the developers can fix the surfacing
  errors immediately, ensuring that the software is free of
  immutability violations.

  To be incorporated into normal development, however, a checker must
  be efficient, i.e. the verification must come with no significant
  time overhead. A way to ascertain this is to make the checking
  \emph{modular} -- to verify a compilation unit, a modular checker
  only requires the source code for the unit and the declarations for
  the methods and classes used therein.
\end{itemize}

In order to mirror the notions introduced in Jimuva, Java annotations
are used in JimuvaChecker to describe properties of objects, methods
and classes within the syntax of Java. However, the syntax of Java
annotations, as introduced in Java 5~\cite{jls3}, is insufficient to
express all immutability-related properties. Therefore, we needed to
use the extended annotation syntax proposed in the Java Specification
Request 308~\cite{jsr308}. As a proof of concept, the authors of the
JSR 308 specification created a Checker Framework~\cite{checkers},
which can be used to build compiler plugins acting as annotation
processors for the extended syntax.

JimuvaChecker, the checker tool created as part of our work, was
implemented using the Checker Framework.

The following section lists some of the syntax extensions introduced
by JSR 308 which are crucial to the functioning of our checker.
Section \ref{sec:framework} proceeds to describe the main concepts of
the Checker Framework. Section \ref{sec:checking} details on the type
system and verification implemented in JimuvaChecker.

\section{JSR 308}
\label{sec:jsr308}

JSR 308 is a specification request which regards an extension to the
syntax of Java annotations. First proposed in 2006, it was meant to
become a part of the Java 7 standard. Although it was not incorporated
into Java 7, the extension proves to be especially useful in the field
of program verification. This work relies on the enhancements proposed
in JSR 308.

The JSR allows annotations to appear on any occurrence of a
type. Below, we list the syntactic constructs originating from this
extension which are the most useful for the analysis of JimuvaChecker,
along with examples of their use. Please refer to \ref{jsr308} for a
complete discussion of the syntax changes. 

\begin{itemize}
\item \textbf{Object creation.} The type of objects created using the
  \texttt{new} operator may be annotated:
  \begin{center} 
    \texttt{x = new @Important Document()}
  \end{center}
\item \textbf{Method receivers.} The type of a method's receiver
  object may be annotated by putting the annotations after the list of
  arguments:
  \begin{center} 
    \texttt{void process(Document x) @ReadOnly \{ ... \}}
  \end{center}
\item \textbf{Array levels.} The user may annotate chosen levels of a
  multidimensional array. The semantics of such annotations are best
  shown on the following examples:
  \begin{itemize}
  \item Two-dimensional array of read-only documents: 
    \begin{center}
      \texttt{@Readonly Document [][]}
    \end{center}
  \item A read-only array of Document arrays:
    \begin{center}
      \texttt{Document @ReadOnly [][]}
    \end{center}
  \item An array of read-only arrays of Documents:
    \begin{center}
      \texttt{Document [] @ReadOnly []}
    \end{center}
  \end{itemize}
\item \textbf{Arguments of generic types and polymorphic methods.} The
  formal parameters of generic types and polymorphic methods may be
  annotated, as well as the actual parameters passed to a generic type
  when it is instantiated:
  \begin{center}
    \texttt{x = new LinkedList<@NonNull @ReadOnly String>()}
  \end{center}
\end{itemize}


\section{The Checker Framework}
\label{sec:framework}

\begin{figure}
  \centering
  
  \subfigure[Example hierarchy of type annotations]{
    \tikzstyle{block} = [draw, rectangle, fill=blue!10, rounded corners, thick, inner sep=4pt]  
    \begin{tikzpicture}[auto, node distance=3cm, >=latex]
      \node [minimum width=6cm] at (2, 1.5) (dummy) {};
      \node [block] (top) at (2, 1.5) {@Nullable}; 
      \node [block, below of=top] (bot) at (2, 1.2) {@NonNull}; 
      \draw [->] (bot) -- (top); 
    \end{tikzpicture}
  }
  \subfigure[The resulting type hierarchy]{
    \tikzstyle{block} = [draw, rectangle, fill=orange!10, rounded corners, thick, inner sep=4pt]  
    \begin{tikzpicture}[auto, node distance=3cm, >=latex]
      \node [block] (top) {@Nullable Object}; 
      \node [block, below left of=top] (left) {@NonNull Object}; 
      \node [block, below right of=top] (right) {@Nullable Date}; 
      \node [block, below right of=left] (bot) {@NonNull Date}; 
      
      \draw [->] (bot) -- (left); 
      \draw [->] (bot) -- (right); 
      \draw [->] (right) -- (top); 
      \draw [->] (left) -- (top); 
      
    \end{tikzpicture}
  }
  \caption{Relations between annotated types in a checker. An arrow from
    A to B indicates that A is a subtype of B.}
  \label{fig:example-checker-hierarchy}
\end{figure}


The Checker Framework is a tool which can be used to create new
annotation processors for Java. Basically, the checkers extend the
type-checking functionality of the Java compiler itself by introducing
a hierarchy of \emph{type annotations} on top of the hierarchy
stemming from simple subclassing and interfacing. Type annotations are
Java annotations which can be used on any type occurrence, as enabled
by the syntax extensions of JSR 308. They can be organised in a
supertype-subtype hierarchy which enhances the existing Java type
hierarchy.

Figure \ref{fig:example-checker-hierarchy} shows how such an enhanced
type hierarchy works. Here, the type annotation @NonNull is defined to
be a subtype of the default annotation @Nullable. Subtyping in the
resulting type hierarchy may come from two sources: normal Java
subclassing and the subtyping between type annotations.

Normally, a pluggable type checker works by extending the
functionality of the simple \texttt{BaseTypeChecker} shipped with the
framework. The \texttt{BaseTypeChecker} verifies that all assignments,
including implicit ones such as the assignment of parameters to formal
arguments of methods during method invocation, follow the subtyping
rules. Specifically, if a value of type $B$ is assigned to a reference
of type $B$, the checker verifies that $B$ is a subtype of $A$ as per
the enhanced type hierarchy.

A checker based on the Checker Framework usually consists of two main
modules:
\begin{itemize}
\item the \textbf{annotated type factory}, which provides syntactical
  constructs of the Java language with type annotations according to a
  given set of rules,
\item the \textbf{visitor} which traverses the nodes of the abstract
  syntax tree (AST) of the given compilation unit and verifies
  properties based on their annotated types inferred by the annotated
  type factory. This module acts upon the AST by making use of the
  Visitor design pattern~\cite{visitor}. Of course, the properties to
  be checked are not limited to simple subtyping checking; one may
  implement any rule which the code being compiled will be checked
  against.
\end{itemize}
Figure \ref{fig:simple-checker} contains the schema of how the modules
of a checker work to verify the properties of a given source code
file.

\begin{figure}
  \centering

  \tikzstyle{block} = [draw, rectangle, fill=orange!10, minimum
  width=3cm, minimum height=0.6cm, rounded corners, inner sep=4pt, thick]
  \begin{tikzpicture}[auto, node distance=3cm, >=latex]
    \node [block, fill=blue!10] (compiler) at (5, 5) {\texttt{javac -processor checkers.x.XChecker code.java}};
    \node [block, fill=orange!10] (checker) at (5, 4) {XChecker}; 
    \node [block, fill=yellow!20, node distance=5cm, pin={[pin edge={latex-, thin, black}] above:{source code}}] 
    (code) at (0, 3) {\texttt{code.java}};
    \node [block] (visitor) at (3, 1) {XVisitor};
    \node [block] (factory) at (9, 1) {XAnnotatedTypeFactory};

    \draw [->, dashed] (compiler) -- (checker);
    \draw [->, dashed] (checker) -- (factory);
    \draw [->, dashed] (checker) -- (visitor);
    \draw [->] (visitor.east) [bend left] edge node [above] {\small{elements}} (factory.west); 
    \draw [<-] (visitor.east) [bend right] edge node [below] {\parbox[c]{1cm}{\small{assign types}}} (factory.west);
    \draw [->] (visitor) edge node {\parbox[c]{1.2cm}{\small{check} \tiny{(Visitor pattern)}}} (code);
  \end{tikzpicture}

  \caption{A simplified schema of source code file analysis by a
    Checker Framework-based checker.}
  \label{fig:simple-checker}
\end{figure}


\section{Modelling Jimuva in Java}
\label{sec:modelling}

This section contains details on the translation of Jimuva access
rights and~ownership specifications into Java annotations. For
information on how the desired properties are verified, please refer
to Section \ref{sec:checking}.

\subsection{Introduction}

There are two basic concepts of Jimuva which extend the Java language
syntax and therefore need to be translated into Java annotations: the
access rights and ownership specifications. The other differences
between the syntax of Jimuva and Java are virtually insignificant for
this work. For example, the \texttt{let}-bindings, which Jimuva uses
in place of local variables, are easily mirrored into simple local
variable declarations. Taking care of the syntactical construct of
Java which do not exist in Jimuva, such as loops, will also prove to
be easy for the purpose of verifying immutability properties.

As mentioned in the previous section, \todo{check if it is previous}
the checkers which make use of the Checker Framework should build a
hierarchy of type annotations. Such a hierarchy has been created in
JimuvaChecker, along with rules which need to be enforced in order to
ensure immutability and ownership-related correctness. The following
sections elaborate upon the mapping from Jimuva to this hierarchy and
may be considered as a discussion of the syntax of the language
JimuvaChecker works upon.

\subsection{Modelling immutability specifications}

The immutability specifications of Jimuva are mapped into three type
annotations as shown in Table \ref{tab:mapping-immut}. 

\begin{table}[htb]
  \centering
  \begin{tabular}{|l|l|l|}
    \hline
    \textbf{Jimuva type} & \textbf{Description} & \textbf{Java annotated type} \\
    \hline \hline
    \texttt{C<rdwr>} & Unrestricted & \texttt{@Mutable C} \\
    \texttt{C<myaccess>} & Same as referencing object & \texttt{@Myaccess C} \\
    \texttt{C<rd>} & Read-restricted & \texttt{@Immutable C} \\
    \hline
  \end{tabular}
  \caption{Mapping of Jimuva type specifications into Java annotated types.}
  \label{tab:mapping-immut}
\end{table}

Note that \texttt{@Immutable} objects must be created as such, using
the syntax introduced by JSR 308, e.g.:
\begin{center}
  \texttt{@Immutable C x = new @Immutable C()}
\end{center}

If no access rights type annotation is specified for an object, the
type annotation will default to \texttt{@Mutable}. Therefore, there is
no need for an user to insert the \texttt{@Mutable} annotation in
their code, though they may want to emphasise the mutability of a
particular object.

There are several limitations on the use of access rights annotations
to be checked by JimuvaChecker:
\begin{itemize}
\item \textbf{Arrays must be \texttt{@Mutable}.} An object of array type
  \texttt{C []} has no constructor visible to the outside
  world. Therefore, there would be no way to initialize the contents
  of an \texttt{@Immutable} array other than by a static initializer,
  \begin{table}[htb]
    \centering

    \caption{Mapping of Jimuva ownership specifications into Java annotated types.}
    
  \end{table}
  which is too limited for most uses. 
\item \textbf{\texttt{@Myaccess} is invalid on static members.} As in
  Jimuva, the \texttt{@Myaccess} annotation is designed to be an
  access rights variable which is instantiated to the access rights of
  another object which references the given object. The notion of a
  \emph{referencing object} is invalid in the case of static members
  of classes, parameters of static methods and local variables
  declared inside static methods. JimuvaChecker does not permit
  \texttt{@Myaccess} annotations on those elements. 
\end{itemize}

Of course, the access rights annotations may be used on every
occurrence of a type. We might for example constrain the access rights
for a method parameter or the returned value, as shown in the
following listing:
\begin{lstlisting}
public class B {
  protected @Myaccess A a;

  void set(@Myaccess A a) {
    this.a = a;
  }

  @Myaccess A get() {
    return this.a;
  }
}
\end{lstlisting}
Note that the \texttt{@Myaccess} will be instantiated in a given
object of class $B$ to whatever access rights the object has. If the
object is \texttt{@Immutable}, JimuvaChecker will enforce that the
value returned from \texttt{get()} and the value passed to
\texttt{set()} as a parameter are also immutable.

\paragraph{Note: \texttt{@Immutable} is not \texttt{final}} $\,$ \\

There is a certain distinction between \texttt{final} references and
\texttt{@Immutable} objects. Consider the following series of
instructions:
\begin{lstlisting}
@Immutable Integer x = new @Immutable Integer(42);
x = new @Immutable Integer(0);
\end{lstlisting}
Even though it might be somewhat counter-intuitive at first, the
second assignment is perfectly valid. It is important to remember that
the \texttt{@Immutable} annotation refers to the \emph{object} and not
the \emph{reference}. The reference \texttt{x} changes, but the object
remains unchanged. Of course, the reference could be made unmodifiable
by using the \texttt{final} modifier. In that case, the second
assignment would yield a compile-time error.

\subsection{Modelling auxiliary specifications}

The auxiliary specifications for classes and methods described in
Section \ref{sub:jimuva-aux} are mirrored in the JimuvaChecker's type
system in the following way: 

\subsubsection{Immutable classes}

The \texttt{@ImmutableClass} annotation may precede any class
declaration, including local classes and member classes, e.g.:

\begin{lstlisting}
@ImmutableClass
public class C {
  ...
}
\end{lstlisting}

\subsubsection{Read-only methods}

The user may constrain a method not to modify the object it is called
on by preceding its declaration with the \texttt{@ReadOnly} annotation:

\begin{lstlisting}
@ReadOnly public A getX() { 
  return x; 
}
\end{lstlisting}
This annotation is equivalent (and internally translated by Jimuva) to 
annotating the receiver type of the method with \texttt{@Immutable}.

\subsubsection{Anonymous constructors}

Similarly to the \texttt{@ReadOnly} annotation on methods,
constructors may be annotated with \texttt{@Anonymous}, which
indicates that the constructor should be checked for not leaking
references to \texttt{this} to the outside world.

\subsubsection{Write-local constructors}
\label{sub:mirroring-writelocal}

In JimuvaChecker, the notion of write-local constructors, as described
in Section \ref{sub:jimuva-wrlocal}, is unneccessary and, as a
consequence, absent. The fact that visibility modifiers are understood
\emph{per class}, as it is done in Java, and not \emph{per object},
does pose a problem, but not one that is related solely to
constructors. Let us consider the relevant example brought up by Haack
et al.:
\begin{lstlisting}[morekeywords={immutable, anon, wrlocal, rdonly}]
immutable class Wrong {
  Mutable<this> m; 
  rdonly int get() { m.get() }
  anon wrlocal Wrong.k(Wrong o) {
    this.m = new Mutable<this>.k(o.get()); 
    o.m.set(23); /* side-effect on other object */
  }
}
\end{lstlisting}
The authors argue that constructors must be prohibited from calling
non-\texttt{rdonly} methods on members owned by other
objects. However, the same example could be contrived if
\texttt{Wrong.k} were a method rather than a constructor. Apparently,
the actual problem lies in the fact that the constructor may access
the field \texttt{m} which is a part of the internal representation of
the object \texttt{o}. In JimuvaChecker, we prohibit all objects from
accessing the internal representation of another object, even if such
access would be enabled by Java's member visibility mechanism. As a
result, the \texttt{wrlocal} annotation is unneccessary, because all
methods and constructors are write-local in the sense introduced in
Jimuva.

Section \ref{sec:checking-rep} offers more insight on how internal
representation of objects is protected in JimuvaChecker. 


\subsection{Modelling ownership specifications}
\label{sec:mod:ownership}

The ownership specifications introduced in Jimuva are very liberal: an
object may be owned by any other object within its scope. \todo{true?}
There are several ownership variables which can be used in place of
object identifiers in the ownership specification of an object. 

Table \ref{tab:mapping-owner} shows how the different possible
ownership specifications are reflected into Java type annotations.
\begin{table}[htb]
  \centering
  \begin{tabular}{|l|l|l|}
    \hline
    \textbf{Jimuva type} & \textbf{Description} & \textbf{Java annotated type} \\
    \hline \hline 
    \texttt{C<this>} & owned by the referencing object & \texttt{@Rep C} \\
    \texttt{C<myowner>} & same owner as the referencing object & \texttt{@Peer C} \\
    \texttt{C<world>} & no owner & \texttt{@World C} (default) \\
    \texttt{C<v>} (general case) & owned by \texttt{v} & \texttt{@OwnedBy(''v'') C} \\
    \hline
  \end{tabular}
  \caption{Mapping Jimuva ownership specifications into Java annotated types}
  \label{tab:mapping-owner}
\end{table}
If no ownership specification is given for an object, the type
annotation defaults to \texttt{@World}. The user does not need to use
the \texttt{@World} annotation in their code.

\subsubsection{Encapsulation of representation}
\label{sec:mod:encap}

JimuvaChecker implements the concept of \emph{encapsulation of
  representation}. The objects which are pointed to by references
marked with the \texttt{@Rep} annotation are considered a part of the
internal representation of the enclosing object. As such, they are
protected from being accessed from outside the enclosing
object. Section \ref{sec:checking-owner} provides more details on the
mechanism used to enforce encapsulation of representation in
JimuvaChecker. 

It should be noticed that encapsulation of representation proves a
hindrance to the language. Some real-life constructs which would make
use of internal representation cannot be expressed by means of
\texttt{@Rep} only. The most prominent class of examples of such
limitations are collections (understood as pointer structures such as
lists) of elements which would be protected from outside access using
the \texttt{@Rep} ownership specification.

\lstinputlisting[float, label={lst:stack-rep}, caption={An erroneous
  implementation of a stack whose element are protected from outside
  access, built using the \texttt{@Rep} annotation
  only.}]{code/coll-rep.java}

Listing \ref{lst:stack-rep} indicates the main problems with this
approach by showing an implementation of a simple stack. If the
stack's elements are to be protected inside the \texttt{Cell} class by
the \texttt{@Rep} annotation, the representation protection mechanism
will allow the method \texttt{Cell::getData} neither to return
\texttt{data} directly nor to pass it to the copying constructor, as
both actions may potentially expose internal representation of the
cell to a foreign object. What is more, the implementation would
require that the collection's elements are copied while they are
retrieved, which makes it impossible for the whole collection
impossible to be generic.

\lstinputlisting[float, label={lst:stack-peer},
caption={Implementation of a stack whose elements belong to the owner
  of the stack. }]{code/coll-peer.java}

\begin{figure}[p]
  \tikzstyle{object} = [matrix, draw, thick, rectangle, rounded corners, inner ysep=10pt, fill=orange!10]
  \tikzstyle{class} = [draw, thick, rectangle, rounded corners, fill=orange!30, minimum width=2.2cm]
  \pgfdeclarelayer{background}
  \pgfdeclarelayer{foreground}
  \pgfsetlayers{background,main,foreground}  
  \begin{tikzpicture}[auto, >=latex]
    \node [object, minimum width=2cm, fill=blue!5] (obj) at (0, 1.5) {
      \node [draw, rectangle, inner sep=3pt, thick, minimum width=0cm] (s) {stack}; \\
    };
    \node [class, fill=blue!30] at (obj.north) {SomeObject};

    \node [object, minimum width=2cm] (stack) at (3, 0) {
      \node [draw, rectangle, inner sep=3pt, thick, minimum width=0cm] (hd) {head}; \\
    };
    \node [class] (stc) at (stack.north) {PeerStack<T>};

    \draw [->] (s) [bend left, above] edge node {\small{@Rep}} (stc.north);

    \foreach \c/\x in {1/6.5,2/9.5,3/12.5} {
      \node [object, minimum width=1.5cm] (c\c) at (\x, 0.3) {
        \node [draw, rectangle, inner ysep=3pt, outer ysep=3pt, thick, minimum width=0cm] (n\c) {next}; \\
        \node [draw, rectangle, inner ysep=3pt, thick, minimum width=0cm] (i\c) {data}; \\
      };
      \node [class] (cc\c) at (c\c.north) {Cell<T>};
      \node [class] (ci\c) at (\x, -1.5) {T};
      \draw [->] (i\c) [bend right, anchor=west, near end] edge node {\small{@Peer}} (ci\c.north);
    }
    \draw [->] (hd) [bend right, below] edge node {\small{@Peer}} (c1.west);

    \foreach \c/\n in {1/2,2/3} {
      \draw [->] (n\c) [below] edge node {\small{@Peer}} (c\n);
    }
    
    \begin{pgfonlayer}{background}
      \draw (c1)+(1.5, -0.5) [draw=blue!50, fill=blue!5, thick] ellipse (6.8 and 2.5);
    \end{pgfonlayer}
    
    \draw [draw=blue!50, thick, text=blue!50] (c1)+(-5.3,-0.5) [bend left, anchor=north east] 
    edge node {\parbox{1.3cm}{context of this object}} (obj.south);

  \end{tikzpicture}
  \caption{The structure of a PeerStack. The whole collection is in
    the context of the object holding the \texttt{stack} reference.}
  \label{fig:peer-contexts}
\end{figure}

The \texttt{@Peer} annotation comes to rescue by offering a way to
protect objects from external access, while being more lenient when it
comes to the operations permitted on the objects. Actually, protection
of internal representation is still active, but it is taken to another
level. By annotating them with \texttt{@Peer}, objects are arranged
into groups sharing the same owner. The objects of each group may
still only be accessed through the owner's interface.

This grouping lays at the base of the Universes type system introduced
by Dietl and~Müller~\cite{universes}, where objects are considered to
be in the same \emph{context} if they share owners. In their work, the
reference types equivalent to both \texttt{@Rep} and \texttt{@Peer}
are supertyped by \emph{read-only} references in order to allow
non-modifying access to an object's context. In Jimuva, as well as in
our checker, the concepts of ownership and immutability are
orthogonal. \todo{Allow representation sharing with immutable
  references?}

Listing \ref{lst:stack-peer} shows an implementation of a stack using
both variable ownership specifications \texttt{@Rep} and
\texttt{@Peer}. As opposed to the previously considered
\texttt{RepStack}, this implementation can be correctly type-checked
in our type system. Figure \ref{fig:peer-contexts} shows the structure
of the collection. The \texttt{@Peer} annotation groups all cells and
elements of the collection into the context of the object which holds
the reference to the stack.

\subsubsection{Ownership by any object}

While mirroring the ownership variables does not pose a problem,
creating a mechanism which would allow an object to be owned by any
other object in its scope is more complicated. Since Java annotations
only allow simple types as their parameters, the ownership
specification has to consist in a textual description of the owner
rather than reference the owner itself. This leads to two major
limitations relating to the syntax as well as the semantics of the
construct in JimuvaChecker.

Firstly, due to the fact that a textual description of the owner
object must be analysed, the range of objects which can be specified
as owners of a given object is bound to be limited. In JimuvaChecker,
the following objects are allowed as owners:
\begin{itemize}
\item \textbf{Formal parameters of enclosing methods:}
  \begin{lstlisting}
void changeHead(IntList list, Integer n) {
  @OwnedBy(''list'') Integer nc = new @OwnedBy(''list'') Integer(n);
  list.setHead(nc);
}
  \end{lstlisting}
\item \textbf{Static and instance fields of enclosing classes:}
  \begin{lstlisting}
public class A {
  IntList list;

  void addZero() {
    @OwnedBy(''list'') Integer zero = new @OwnedBy(''list'') Integer(0);
    list.add(zero);
  }
}
\end{lstlisting}
\item \textbf{Static fields of member classes in the object's scope:}
  \begin{lstlisting}
public class A {
  public static class B {
    static IntList list;
  }

  @OwnedBy(''B.list'') Integer n;
}
\end{lstlisting}
Note that only the fields of member classes of the classes that
enclose the annotated reference may be used. Introducing support for
static fields of any class visible in the scope of the reference would
be possible with the Java reflection mechanism
\cite{reflection}. However, this might lead to circular dependencies
and other problems when compiling a large project. Adding
reflection-based support for the ownership by static fields of any
class is a possible future enhancement for the checker.
\item \textbf{Local variables present in the object's scope:}
\begin{lstlisting}
IntList initList() {
  IntList list = new IntList();
  list.add(new @OwnedBy(''list'') Integer(0)); 
  return list;
}
\end{lstlisting}
\item \textbf{Public fields in the transitive reach of all of the
    above objects.} For each object listed above, the user may specify
  as owners their public fields and the public fields of the objects
  in those public fields etc. What is more, if a member of the
  transitive reach has an instance class, its static members and their
  transitive reach may also be referenced. The string descriptions of
  the reachable objects are constructed with the normal Java notation
  for member access. All of the following annotations are valid:
  \begin{lstlisting}
public class A {
  public static class B {
    public IntList list;
  }
  public static class C {
    static B b;
    public B d;
    public A a;
  }
  public class E {  /* Instance class */
    static IntList list
  }
  
  @OwnedBy(''C.b.list'') Integer n;   
  @OwnedBy(''C.a.E.list'') Integer m; 
  void process() {
    C x = new C();
    @OwnedBy(''x.d.list'') Integer p;
    x.d.list.add(p);
  }  
}
  \end{lstlisting}
\end{itemize}

The second limitation regarding this general case of ownership is
connected to the semantics. Because ownership is represented by a
string rather than a true reference to an object, we do not have a way
of verifying that the reference described in the annotation's
parameter does not change. Consider the following example:
\begin{lstlisting}
void process() {
  IntList list = new IntList();
  @OwnedBy(''list'') Integer n = new @OwnedBy(''list'') Integer(0);
  list = new IntList();
}
\end{lstlisting}
The reference \texttt{list} changes, but the description in the
ownership specification for \texttt{n} does not. The \texttt{@OwnedBy}
annotation introduces references, rather than particular objects, as
owners. 

Another related problem with the general ownership lies in the fact
that the owner descriptions are relative to the annotated object. We
cannot directly refer to the chosen object, but instead we have to
follow references which are available from the scope of the annotated
object. The resulting issue is that the same object can be referenced
as the owner in some places of code, while being out of scope in other
places. The most prominent example here is the case of formal method
parameters which are constrained to be owned by a private field of the
enclosing class:
\begin{lstlisting}
public class A {
  private IntList list;
  void add(@OwnedBy(''list'') Integer n) {
    list.add(n);
  }
}
...
void process(A a) {
  a.add(new @OwnedBy(''a.list'') Integer(0)); 
                       /* ^^^^^ Illegal! @OwnedBy cannot refer to private fields */
}
\end{lstlisting}
JimuvaChecker follows the visibility mechanism of Java in that it does
not allow owner specifications to refer to non-public fields.  As a
result, no other object may call such a method. It is impossible for a
foreign object pass an appropriate argument, because the requested
owner of the argument is out of the object's scope.

\paragraph{Encapsulation of representation} \crlf

It would seem that, by introducing the general case of ownership into
their code using the \texttt{@OwnedBy} annotation, the user forfeits
the protection of the internal representation of objects. Indeed, the
property that no object may witness the internal state of another
object is violated in that case. The more important property of
encapsulation is enforced in JimuvaChecker: the internal
representation of an immutable object may not be
modified. JimuvaChecker disallows a situation where the access rights
to an object \texttt{@OwnedBy(''x'')} are less restrictive than those
of \texttt{x} itself. More information on how this is achieved is
available in Section \todo{Reference}.

\subsection{Modelling owner-polymorphic methods}

The Jimuva language includes \emph{owner-polymorphic} methods, which
accept parameters with generic (variable) ownership. Let us recall the
introductory example method from Section \ref{sec:jimuva:poly} for
further discussion:
\begin{center}
  \texttt{<x,y> void copy(C<x> from, C<y> to)}
\end{center}

Java offers a seldom used mechanism of polymorphic methods, which are
declared using a similar syntax~\cite{genericmethods}:
\begin{lstlisting}
static <T> void fromArrayToCollection(T[] a, Collection<T> c) {
    for (T o : a) {
        c.add(o);
    }
}
\end{lstlisting}

We might consider the following declaration for the example
\texttt{copy} method:
\begin{lstlisting}
<T1 extends C, T2 extends C> void copy(T1 from, T2 to) {...}
\end{lstlisting}
The syntax of Jimuva lets the method's body access the actual owners
of the parameters passed to an owner-polymorphic method. In the case
of the above Java declaration, however, there is no way we could refer
to the actual owners, as we can only operate on the formal type
parameters \texttt{T1} and \texttt{T2}.

Overcoming this limitation related to generic methods is difficult, if
not impossible, without introducing changes into the Java syntax. A
simpler approach, described below, has been adopted in JimuvaChecker.

In order to introduce an owner-polymorphic method, one may annotate
any or all of the formal parameters with \texttt{@AnyOwner}. The
\texttt{copy} method would then be declared as follows:
\begin{lstlisting}
void copy(@AnyOwner C from, @AnyOwner C to) {...}
\end{lstlisting}

There is an important issue left to consider related to encapsulation
of representation. On the one hand, it would be too strict to entirely
prohibit passing \texttt{@Rep} objects as arguments to foreign
methods. On the other hand, the internal representation should not
cease to be protected from access by outside objects. Figuratively
speaking, the caller entrusts the polymorphic method with a part of
its representation, but it should be assured that the callee will not
leak the object any further.

Our type system must ensure that this is the case in
JimuvaChecker. Therefore, the \texttt{@Safe} annotation was
introduced, which is designed for use with formal parameters of
methods. The checker allows protected objects, i.e. those annotated
with \texttt{@Rep} and \texttt{@Peer}, to be passed to methods as
\texttt{@Safe} parameters, but it enforces their protection by
prohibiting the method to create \emph{static aliases} to the
parameters \todo{or any object transitively reachable from them}. This
concept of \emph{safe parameters} is similar to that presented by
Sălcianu and~Rinard in their work related to method
purity~\cite{purity}.

Objects annotated with \texttt{@OwnedBy} or the implicit
\texttt{@World} specifier are not protected from outside access and
may be passed both as \texttt{@Safe} arguments and \texttt{@AnyOwner}
arguments. 

Section \ref{sec:checking:safety} provides more details on the
enforcing of parameter safety in JimuvaChecker.

\chapter{Verifying immutability}

JimuvaChecker may be used to verify properties of programs which are
related to the concept of object immutability. This chapter presents
those properties, as well as the mechanism of verification.

\section{Immutability properties}

\subsection{Preliminary discussion and definitions}

Haack et al. provide a complete small-step operational semantics of
their simple language. Since this work aims at processing full Java,
trying to base immutability properties on the language semantics in a
formal way is more complicated.

Several approaches have been taken to define the formal semantics of
Java, but all of them were limited in the breadth of language
constructs they covered. Some of the related work focused on
developing formal semantics of small fragments of the language, or
\emph{calculi}, some of the examples being Featherweight
Java~\cite{javasem:feather} or the imperative core calculus
MJ~\cite{javasem:mj}. Perhaps the most complete approach is
Jinja~\cite{javasem:jinja}, a language aiming to model a significant
portion of Java. There even exists an executable implementation of the
operational semantics of Java which allows for visualisation of the
system's execution~\cite{javasem:exec}. 

Even if a complete formal specification of Java semantics existed, it
would be out of proportion to recall it in this work. Instead, we
state the properties to be verified by JimuvaChecker relying on the
apprehensive but less-than-formal notion of object state defined below.

Let us begin with an auxiliary definition related to the Java memory
model:
\begin{defi}[Value function]
  For an object $w$, a field identifier $f$ and program state $s$, let
  $val_s^w(f)$ denote the value referenced by $f$. The value may be of
  a Java primitive type (\texttt{float}, \texttt{int} etc.) or an object.
\end{defi}
Because we don't intend to introduce full semantics of Java, program
state is introduced informally in the above definition, but it should
be understood as the full information on the threads, stack frames and
the mapping of heap addresses to values. 

\begin{defi}[Object state]
  \label{def:state}
  The \emph{state} of object $w$ in program state $q$ is a set $S_q(w)$
  of objects defined inductively as follows:
  \begin{enumerate}[label=(\arabic*)]
  \item The object is in its own state: 
    $$w \in S(w).$$
  \item For each instance field $f$ of $w$, if $f$ is annotated with
    \texttt{@Rep} and $val_s^w(f) = v$,
    $$v \in S(w).$$
  \item For each object $v$ in $S(w)$ and each field $f$ of $v$
    annotated with \texttt{@Peer}, if $val_s^v(f) = x$, 
    $$ x \in S(w).$$
  \item For each object $v$ annotated with \texttt{@OwnedBy(''s'')},
    where \texttt{s} may refer to $w$,
    $$v \in S(w).$$
  \end{enumerate}
\end{defi}
Notice that the presence of the last rule makes Definition
\ref{def:state} broader than the one in Jimuva (cf. Definition 2
in~\cite{haack}). We include all objects which are owned by the
object $w$, even if these objects are not within $w$'s reach. The
above definition includes all objects whose type in Jimuva would be
equivalent to \texttt{C<ar, w>} for some access rights specifier
\texttt{ar}.

Even for immutable objects, the object state is subject to change
between program states. When a new object annotated with
\texttt{@OwnedBy($w$)} is created, the set of objects contributing
to $w$'s state expands. This addition should not be considered as
modification of the object, because $w$ itself remains observationally
unchanged. We have to introduce an equivalence relation between
program states with regards to object state:
\begin{defi}[Object state equivalence]
  For an object $w$, we say that two program states $q_1, q_2$ are
  \emph{equivalent with regards to $w$}, denoted $q_1
  \stackrel{w}{\equiv}$, iff for each object $v$ in $S_1 \cap S_2$ and
  each field $f$ of $v$,
  $$val_{q_1}^{v}(f) = val_{q_2}^{v}(f).$$
\end{defi}
With this definition, we may ignore changes made in $w$'s state by
creating a new object $v$ owned by $w$. However, if $v$ exists in two
program states, they are only equivalent if the state of $v$ is the
same in both of them.

It would be tempting to hasten now and say that an object is immutable
if any two program states are equivalent with regards to the
object. However, one has to remember that even immutable objects
mutate while they are still in their construction phase and their
state cannot be observed from the outside. When analyzing mutations of
objects, we must thus limit the scope of states we consider to those
states in which no object is still under construction:

\begin{defi}[Visible states]
  A program state $q$ is \emph{visible} for an object $w$, denoted $q
  \in V_w$, iff $q$ is reachable and no object in $S_q(w)$ is being
  constructed in $q$.
\end{defi}
On a lower level, a program state would be visible for an object $w$
if there is no constructor stack frame of an object in $w$'s state in
any execution thread.

We are now ready to complete the preparations by stating what it means
for an object to mutate:
\begin{defi}[Object mutation]
  We say object $w$ \emph{mutates} iff there are two program states
  $q_1, q_2 \in V_w$ such that
  $$q_1 \not\stackrel{w}{\equiv} q_2$$
\end{defi}

\subsection{Immutability invariants}

We will now define the immutability invariants which are proved by
JimuvaChecker. Here, we have to distinguish between \emph{checked}
code, which is analyzed by the checker, and general \emph{unchecked}
code, which may interact with checked object in any manner enabled by
the Java language.

The first property relates to checked fragments of code:
\begin{invariant}[Immutability] \label{inv:closed}
  If an object $x$ is created \texttt{@Immutable}, e.g. by using one of
  the following instructions:
  \begin{center}
    \texttt{x = new @Immutable A();}
  \end{center}
  \begin{center}
    \texttt{x = new @Immutable A [5];}
  \end{center}
  $x$ does not mutate, provided it is only used by checked code.
\end{invariant}

Property \ref{inv:closed} is only useful if all code acting upon the
immutable objects is checked. We may want to be able to construct
objects which are provably immutable even when the code using them is
unchecked. The property of \emph{immutability in an open world} is also
pursued in JimuvaChecker:
\begin{invariant}[Immutability in an open world]
  If a class $C$ is annotated with \texttt{@ImmutableClass}, each
  object of class $C$ does not mutate, provided that $C$ is not
  illegally subclassed.
\end{invariant}


\section{JimuvaChecker}

JimuvaChecker is a pluggable type checker for Java 7, built upon the
Checker Framework. The framework has been described in Section
\ref{sec:framework}.  In this section, we will outline the structure
of the checker and list the rules it verifies.

\subsection{Structure of the checker}

Basically, JimuvaChecker is an annotation processor for Java 7 which
aims to verify that the given programs contain no immutability
violations. The process of verification can be divided into two steps:
\begin{itemize}
\item Firstly, the types of objects, methods and classes in the
  verified program are marked with relevant properties to form
  \emph{annotated types}. As mentioned in Section \ref{sec:framework},
  an annotated type consists in the ordinary Java type and one or more
  \emph{type qualifiers}.

  Type qualifiers form a hierarchy which extends the Java subtyping
  hierarchy (cf. Figure \ref{fig:example-checker-hierarchy} on page
  \pageref{fig:example-checker-hierarchy}). Type qualifiers can be
  introduced directly by the user by placing Java annotations on the
  chosen types or references, or derived implicitly by the
  checker. All annotations which are understood by JimuvaChecker have
  been listed and described in Section~\ref{sec:modelling}.
\item Secondly, the checker traverses the Abstract Syntax Tree,
  inspecting the constructs which can potentially contribute to a
  violation of the desired properties of the program. For
  JimuvaChecker and the immutability-related properties it verifies,
  the potentially dangerous constructs include, for example,
  assignments, method invocations and the creation of a new object
  with the \texttt{new} operator. 

  The checker inspects the annotated types of objects which are
  referred to in the given place of code, and signals an error if the
  AST node violates a particular condition, indicating a possible
  immutability violation. Throughout the remainder of this chapter, we
  will refer to those conditions as \emph{rules}. In Section
  \ref{sec:rules} we proceed to list all rules which are enforced by
  JimuvaChecker.
\end{itemize}

The general structure of JimuvaCheckers matches that of all annotation
processors based on the Checker Framework. The two functionalities
mentioned above: providing syntactic elements with annotated types and
the actual verification, are delegated to two classes:
\texttt{JimuvaAnnotatedTypeFactory} and \texttt{JimuvaVisitor},
respectively. Figure \ref{fig:classes} contains the UML class diagram
for the project. 

\newcommand{\cln}[1]{\textbf{\small{#1}}}

\begin{figure}[p]
  \tikzstyle{cl}=[rectangle, rectangle split, rectangle split parts=2, 
  draw=black, rounded corners, fill=orange!20, drop shadow, anchor=north, text justified, text width=7cm]
  \tikzstyle{use}=[-latex, dashed]
  \begin{tikzpicture}[font=\tiny]
    \node (checker) [cl, fill=orange!30] at (5, 7) { \cln{JimuvaChecker} extends BaseTypeChecker
      \nodepart{second}
      AnnotatedTypeFactory createFactory(CompilationUnitTree) \newline 
      BaseTypeVisitor createSourceVisitor(CompilationUnitTree)
    };
    \node (factory) [cl, text width=9cm] at (9, 4) { \cln{JimuvaAnnotatedTypeFactory} 
      extends AnnotatedTypeFactory
      \nodepart{second} 
      AnnotatedTypeMirror getAnnotatedType(Tree t) \newline
      AnnotatedTypeMirror getAnnotatedType(Element e) \newline
      void annotateImplicit(Tree tr, AnnotatedTypeMirror ty)
    };
    \node (visitor) [cl, text width=6.5cm] at (0, 4) { \cln{JimuvaVisitor} extends BaseTypeVisitor
      \nodepart{second}
      Void visitAssignment(AssignmentNode t) \newline
      Void visitMethodInvocation(MethodInvocationTree t)
    };
    \node (state) [cl, text width=6cm, fill=orange!10] at (9, 0) { \cln{JimuvaVisitorState}
      \nodepart{second} 
      void enterMethod(MethodTree t) \newline
      Boolean isCurrentMethod(AnnotatedTypeMirror m) \newline
      void leaveMethod()
    };
    \node (flow) [cl, text width=6cm] at (0, 9.5) { \cln{JimuvaFlow} extends Flow
      \nodepart{second}
      void scan(Tree t) \newline
      void merge(GenKillBits bits, GenKillBits other)
    };
    \node (owner) [cl, text width=4cm, fill=orange!10] at (0, 0) { \cln{Owner}
      \nodepart{second}
      Owner(Element el) \newline
      Boolean isImmutable() \newline
      void append(Owner owner)
    };
    \node (hierarchy) [cl, text width=10.5cm] at (7, 11) {\cln{JimuvaQualifierHierarchy} extends GraphQualifierHierarchy
      \nodepart{second}
      boolean isSubtype(Collection<AnnotationMirror> rhs, Collection<AnnotationMirror> lhs)
    };

    \foreach \f/\t/\a in {checker/flow/east, checker/hierarchy/east, visitor/owner/east, 
      visitor/state/east, factory/owner/east, factory/state/east, state/owner/north} {
      \draw [use] (\f) [near end, anchor=\a] edge node {<<use>>} (\t);
    }

    \foreach \f/\t in {checker/visitor, checker/factory}  {
      \draw [use] (\f) [near end, anchor=east] edge node {<<create>>} (\t);
    }
    
  \end{tikzpicture}
  \caption{Simplified class diagram of the checker.}
  \label{fig:classes}
\end{figure}

The responsibilities of the classes listed in Figure \ref{fig:classes}
are as follows:
\begin{itemize}
\item \textbf{JimuvaChecker}: wrapper class responsible for creating
  the working instances of other classes in the checker, handles the
  reporting of error messages.
\item \textbf{JimuvaAnnotatedTypeFactory}: creates annotated types for
  objects in the analysed program. 
\item \textbf{JimuvaVisitor}: using the Visitor pattern, inspects the
  abstract syntax tree of the program, checking that they conform to
  the rules described in the following section. 
\item \textbf{JimuvaVisitorState}: during the AST traversal, the
  visitor needs additional information such as the annotated type for
  the current method or class. This information is stored in an
  instance of JimuvaVisitorState. 
\item \textbf{JimuvaFlow}: performs \emph{dataflow analysis} on the
  given code in order to infer some annotations which are not
  explicitly included by the user. The annotations are particularly
  important in method anonymity checking (further described in Section
  \ref{sec:ch:anon}) and parameter safety checking (Section
  \ref{sec:ch:safe}). \todo{More on dataflow analysis}
\item \textbf{Owner}: the class is responsible for analysing the
  textual descriptions of object owners. Each object annotated with
  \texttt{@OwnedBy} has a matching instance of Owner which defines its
  owner object.
\item \textbf{JimuvaQualifierHierarchy}: responsible for resolving
  subtyping between annotated types. This class overrides the standard
  subtyping from JimuvaChecker; more information on that is provided
  in Section \ref{sec:ch:hier}. 
\end{itemize}

\section{Annotated type inference and verified rules}
\label{sec:rules}

\begin{figure}[tp]
  \centering
  \subfigure[Access rights specifiers] {
    \begin{tikzpicture}[auto, >=latex]
      \tikzstyle{acc} = [draw, rectangle, fill=yellow!10, rounded corners, thick, inner sep=4pt]  
      \node [acc, very thick] (bot) at (0, 0) {\texttt{@Bottom}};
      \node [acc] (mut) at (-2.5, 2) {\texttt{@Mutable}};
      \node [acc] (mya) at (0, 2) {\texttt{@Myaccess}};
      \node [acc] (imm) at (2.5, 2) {\texttt{@Immutable}};
      
      \foreach \n in {mut,mya,imm} {
        \draw [->] (bot) -- (\n);
      }   
    \end{tikzpicture}
  }
  \tikzstyle{own} = [draw, rectangle, fill=green!10, rounded corners, thick, inner sep=4pt]    
  \subfigure[Ownership specifiers] {
    \begin{tikzpicture}
      \node [own] (safe) at (0, 0) {\texttt{@Safe}};
      \node [own] (anyo) at (-2, 2) {\texttt{@AnyOwner}}; 
      \node [own] (rep) at (0, 2) {\texttt{@Rep}};
      \node [own] (peer) at (2, 2) {\texttt{@Peer}};
      \node [own] (ondb) at (-3, 4) {\texttt{@OwnedBy}};
      \node [own] (world) at (-1, 4) {\texttt{@World}};
      
      \foreach \f/\t in {safe/anyo, safe/rep, safe/peer, anyo/ondb, anyo/world} {
        \draw [->] (\f) -- (\t);
      }
    \end{tikzpicture}  
  }
  \caption{Full hierarchy of type annotations defined in JimuvaChecker}
  \label{fig:hierarchy}
\end{figure}

This section will present the rules which programs are checked against
by the JimuvaChecker in order to prevent immutability violations. In
the following discussion, annotated types will be written in the form:

$$\underbrace{\mathtt{@A\quad @B}}_{\mathclap{\textrm{\small{type qualifiers}}}}\quad \overbrace{\mathtt{T}}^{\mathclap{\textrm{\small{Java type}}}}$$

\subsection{Subtyping}
\label{sec:ch:hierarchy}

JimuvaChecker extends the functionality of the BaseTypeChecker
provided in the Checker Framework. BaseTypeChecker checks that if a
value of type $S$ is assigned to a reference of type $T$, then $S$ is
a subtype of $T$. JimuvaChecker makes use of this functionality, which
implies the following rule:

\setcounter{verrule}{-1}
\begin{verrule}[Subtyping]
  If a value of (annotated) type $S$ is assigned to a reference of type $T$, 
  then $S$ must be a subtype of $T$.
\end{verrule}
Figure \ref{fig:hierarchy} shows the hierarchy of type qualifiers used
in the checker. 

The \texttt{@Bottom} annotation exists for purely technical
reasons. In Checker Framework, each type must be annotated and
\texttt{@Bottom} serves the purpose of a default annotation where the
\texttt{@Mutable} annotation is unsuitable. It is implicitly given to
constructs such as methods and classes, on which the concept of
(im)mutability makes no sense. The \texttt{@Bottom} annotation does
not need, and in fact should not, appear in user code. 

There is a problem with the default subtyping mechanism in the Checker
Framework which has to be addressed here. BaseTypeChecker provides a
subtyping mechanism which would be wrong for our
applications. Specifically, if $T$ had more than one type annotation
(e.g. \texttt{@A @B C}), it would be enough for $S$ to have an
annotation which subtypes \emph{one} of the annotations on the type
$T$ to be considered a subtype of $T$. This would lead to unwanted
results as, for example, \texttt{@Immutable @Peer String} would
subtype \texttt{@Mutable @Safe String}, leading to an obvious
violation in immutability when an \texttt{@Immutable} object gets
assigned to a \texttt{@Mutable} reference. 

The class JimuvaQualifierHierarchy is responsible for introducing
another mechanism of subtyping. For each annotation $a$ on $T$ there
must be an annotation on $S$ which subtypes $a$. In other words, each
annotation on the potential supertype is treated as a requirement
which has to be satisfied by the candidate subtype. 

It has to be emphasised that this rule applies not only to explicit
assignments, but is checked whenever an object is implicitly assigned
to a reference. This includes passing parameters to methods:
\begin{lstlisting}
Object copy(@AnyOwner Object z) { ... } // Cannot pass a @Rep value due to subtyping rule.
\end{lstlisting}
and invoking a method on an object: 
\begin{lstlisting}
public class C {
  Object z;
  Object copy() @OwnedBy(''z'') { ... } // Cannot invoke on an object which is not owned by z
}
\end{lstlisting}

There are several exceptions to the subtyping rule which will be
highlighted in the next subsections. 

\subsection{Guarding immutability}

\paragraph{Softening Rule 0} \crlf

The consequence of Rule 0 is that \texttt{@Mutable} objects cannot be
assigned to \texttt{@Immutable} references. This is in line with
Jimuva, whose authors state that allowing such \emph{upcasting} would
lead to an unsoundness within their type system. However, this seems
to be too strict for some real-life uses. Consider an instance method
of the \texttt{PeerStack} class (introduced in
Listing~\ref{lst:stack-peer} on page \pageref{lst:stack-peer}), whose
aim is to copy the structure of the stack. The method would be
declared in the following way:
\begin{lstlisting}
PeerStack copy(@Immutable PeerStack s) { ... }
\end{lstlisting}
to ensure that the original stack \texttt{s} remains unmodified. Rule
0, however, makes it impossible to call \texttt{copy} on a
\texttt{@Mutable} object, even though it would pose no danger to the
immutability properties. This observation is more general: any object
can be \emph{upcast} to a reference with stricter access restrictions,
i.e. \texttt{@Mutable} to \texttt{@Myaccess} or \texttt{@Immutable}
and \texttt{@Myaccess} to \texttt{@Mutable}, without violating
immutability.

To address the above discussion, JimuvaChecker includes a mechanism
which allows the user to ease the restriction which Rule 0
carries. Whenever the \texttt{allow.upcast=true} option is passed to
the checker, upcasting on access rights specifications will be
permitted.

\paragraph{Enforcing \texttt{@ReadOnly} on methods} \crlf

\texttt{@ReadOnly} methods must prevent the modification of their
receiver. 

\begin{verrule}[\texttt{@ReadOnly} methods] \label{vrl:readonly}
  The receiver of a \texttt{@ReadOnly} method is implicitly marked
  with \texttt{@Immutable}. As an exception to Rule 0, access rights
  upcasting is allowed in this case, regardless of the
  \texttt{allow.upcast} option, so that \texttt{@ReadOnly} methods may
  be invoked on \texttt{@Mutable} objects.
\end{verrule}

\paragraph{Guarding shallow state immutability} \crlf

The following rule guards the shallow state immutability of immutable
objects:

\begin{verrule}[Shallow state immutability]
  If a value $w$ is \texttt{@Immutable}, its fields cannot be
  reassigned.
\end{verrule}

The following trivial code would therefore be illegal:
\begin{lstlisting}
public class IntHolder {
  public Integer n;
}

void test(@Immutable IntHolder h) {
  h.n = 0; /* Illegal */
}
\end{lstlisting}

\paragraph{Resolving \texttt{@Myaccess}}  \crlf

If an object containing \texttt{@Myaccess} elements is created and
used, the access rights variable is \emph{resolved}, depending on the
access rights on the object itself. This aims to protect the
immutability of \texttt{@Myaccess} elements of \texttt{@Immutable}
objects.

\begin{verrule}[Resolving \texttt{@Myaccess}]
  Elements annotated with \texttt{@Myaccess} are resolved in the
  following way:
  \begin{enumerate}[label=(\arabic*)]
  \item For a method call \texttt{x.m(\dots, @Myaccess z, \dots)}, the
    required access rights to \texttt{z} are the same as the access
    rights to \texttt{x}.
  \item For a method call \texttt{x.m(\dots)}, if \texttt{x} returns a
    value annotated with \texttt{@Myaccess}, the access rights to the
    result are the same as the access rights to \texttt{x}.
  \item For a member select expression \texttt{x.f}, if \texttt{f} is
    annotated \texttt{@Myaccess}, the access rights to the whole
    expression are the same as the access rights to \texttt{x}.
  \end{enumerate}
\end{verrule}

Because \texttt{@Myaccess} can be resolved to \texttt{@Immutable}
using the above rule, values annotated with \texttt{@Myaccess} must be
protected from being modified inside read-only methods. The protection
can confined to read-only methods, because no other method can be
called on an immutable object, and \texttt{@Myaccess} only resolves to
\texttt{@Immutable} for immutable objects.

\begin{verrule}[\texttt{@Myaccess} protection]
  Inside read-only methods, if $v$ is a value annotated with
  \texttt{@Myaccess}:
  \begin{enumerate}
  \item non-read-only methods cannot be called on $v$, 
  \item fields of $v$ cannot appear in the left-hand side of an
    assignment.
  \end{enumerate}
\end{verrule}

\subsection{Enforcing constructor anonymity}
\label{sec:ver:anon}

Constructors of immutable objects should be annotated with
\texttt{@Anonymous}. JimuvaChecker verifies that \texttt{@Anonymous}
constructors and methods do not leak references to \texttt{this},
which would allow foreign objects to observe the state of the object
being constructed, possibly before its state is fully
established. This would violate the property of immutability as stated
in Section \ref{sec:properties}. 

To begin with, the checker has to have knowledge on which references
may point to the object under construction. We do not want, however,
to force the user to provide this information in their code. Instead,
JimuvaChecker utilizes \emph{dataflow analysis} to infer information on
dangerous references to \texttt{this}.

\paragraph{Dataflow analysis in general} \crlf

Generally, dataflow analysis is a static analysis technique used to
gather information on the possible values computed at a given point of
a program. The method consists in:
\begin{itemize}
\item modifying the information available in the prestate of each
  statement according to the form of the statement, 
\item branching and merging the information on conditional statements,
  loops etc.
\end{itemize}
Dataflow analysis may be used, for example, to compute the reach of
particular variable definitions in a program, the set of \emph{live}
variables which contribute to the overall result, and many more
program properties. A comprehensive introduction to dataflow analysis
can be found in~\cite{dataflow}. 

\paragraph{Inferring information on references to \texttt{this}} \crlf

In JimuvaChecker, a simple interprocedural dataflow analysis is
performed prior to verification using an implementation supplied in
the Checker Framework, with the class texttt{JimuvaFlow} responsible
for the analysis. It aims to annotate expressions with one of three
possible annotations: \texttt{@This}, \texttt{@MaybeThis} and
\texttt{@NotThis}. The annotations are internal for JimuvaChecker:
they should not appear in user code, but may show up in error messages
printed by the checker. 

The analyser stores a map from element (variable, parameter etc.)
identifiers into the relevant annotation for each place in code.
Below, we present a simplified set of typing rules for expressions
which are applied by the flow analysis. As usual in type systems, $x :
\tau$ will denote that the value $x$ is of type $\tau$. Moreover, $x :
\lbrace\tau_1, \tau_2\rbrace$ will be used as an abbreviation for the
alternative $x : \tau_1 \lor x : \tau_2$.

The type inference rules for expressions are as follows:
\def\proofSkipAmount{\vskip 0.4cm}
\begin{prooftree}
  \AxiomC{}
  \RightLabel{(this)}
  \UnaryInfC{$\mathtt{this} : \texttt{@This}$}
\end{prooftree}

\begin{prooftree}
  \AxiomC{}
  \RightLabel{(new)}
  \UnaryInfC{\texttt{new} C($\vec{p}$) : \texttt{@NotThis}}
\end{prooftree}

\begin{prooftree}
  \AxiomC{x : $\lbrace \mathtt{@This}, \mathtt(@MaybeThis)\rbrace$}
  \RightLabel{(this-member)}
  \UnaryInfC{x.f : \texttt{@MaybeThis}}
\end{prooftree}

\begin{prooftree}
  \AxiomC{x : \texttt{@NotThis}}
  \RightLabel{(nthis-member)}
  \UnaryInfC{x.f : \texttt{@NotThis}}
\end{prooftree}

\begin{prooftree}
  \AxiomC{m : \texttt{@Anonymous}}
  \AxiomC{x : $\lbrace \mathtt{@This}, \mathtt{@MaybeThis}\rbrace$}
  \RightLabel{(anon-this-inv)}
  \BinaryInfC{x.m($\vec{p}$) : \texttt{@NotThis}}
\end{prooftree}

\begin{prooftree}
  \AxiomC{$\neg$ (m : \texttt{@Anonymous})}
  \AxiomC{x : $\lbrace \mathtt{@This}, \mathtt{@MaybeThis}\rbrace$}
  \RightLabel{(nanon-this-inv)}
  \BinaryInfC{x.m($\vec{p}$) : \texttt{@MaybeThis}}
\end{prooftree}

\begin{prooftree}
  \AxiomC{x : \texttt{@NotThis}}
  \RightLabel{(nthis-inv)}
  \UnaryInfC{x.m($\vec{p}$) : \texttt{@NotThis}}
\end{prooftree}

\begin{prooftree}
  \AxiomC{$p$ is a parameter of a constructor}
  \RightLabel{(param-ctor)}
  \UnaryInfC{p : \texttt{@NotThis}}
\end{prooftree}

\begin{prooftree}
  \AxiomC{$p$ is a parameter of a method}
  \RightLabel{(param-meth)}
  \UnaryInfC{p : \texttt{@MaybeThis}}
\end{prooftree}

Most of the above rules are straightforward, but several need further
explanation: 
\begin{itemize}
\item In (nthis-member) and in (nthis-inv), we assume that a reference
  to \texttt{this} has not been leaked to another object. This means
  that the enforcing of the \texttt{@Anonymous} annotation is not
  absolute. A call to an anonymous method might in fact unwittingly
  leak \texttt{this} references if the object has already leaked such
  a reference and passed it back to the anonymous method or assigned
  to a field. Notice, however, that this does no harm to the
  immutability properties, because anonymity is only crucial during
  construction.
\item A most conservative approach has been taken in (param-meth),
  which takes into consideration situations when the user might pass a
  reference to this as an argument to its own instance method. 
\item The (anon-this-inv) is closely related to Rule
  \ref{vrl:anon-ret} stated in the following subsection. 
\end{itemize}

The types inferred using the above rules are subsequently propagated
along with the values. JimuvaChecker takes a conservative approach,
possibly coming up with spurious errors, but ensuring that the
immutability property holds. The propagation rules which handle
conditional expressions utilize a relation $\cup$ which is defined as
follows:
\begin{table}[h]
  \centering
  \begin{tabular}{c|c|c|c|}
    $\cup$ & \texttt{@This} & \texttt{@MaybeThis} & \texttt{@NotThis} \\ \hline
    \texttt{@This} & \texttt{@This} & \texttt{@MaybeThis} & \texttt{@MaybeThis} \\ \hline
    \texttt{@MaybeThis} & \texttt{@MaybeThis} & \texttt{@MaybeThis} & \texttt{@MaybeThis} \\ \hline
    \texttt{@NotThis} & \texttt{@MaybeThis} & \texttt{@MaybeThis} & \texttt{@NotThis} \\ \hline
  \end{tabular}
\end{table}

Several example propagation rules are shown below in Hoare logic~\cite{hoare}.
\begin{prooftree}
  \AxiomC{v : $\tau$}
  \RightLabel{(assign)}
  \UnaryInfC{\htr{true}{x = val}{x : $\tau$}}
\end{prooftree}

\begin{prooftree}
  \AxiomC{}
  \RightLabel{(alias)}
  \UnaryInfC{\htr{var : $\tau$}{x = var}{x : $\tau$}}
\end{prooftree}

\begin{prooftree}
  \AxiomC{\htr{$\phi$}{$P_1$}{x : $\tau_1$}}
  \AxiomC{\htr{$\phi$}{$P_2$}{x : $\tau_2$}}
  \RightLabel{(if)}
  \BinaryInfC{\htr{$\phi$}{\texttt{if (}$C$\texttt{)} $P_1$ \texttt{else} $P_2$}{x : $\tau_1 \cup \tau_2$}}
\end{prooftree}

\begin{prooftree}
  \AxiomC{\htr{$\phi$}{$P$}{x : $\tau_2$}}
  \RightLabel{(while)}
  \UnaryInfC{\htr{$\phi \land x : \tau_1$}{\texttt{while (}$C$\texttt{)} $P$}{x : $\tau_1 \cup \tau_2$}}
\end{prooftree}

\begin{prooftree}
  \AxiomC{\htr{$\phi$}{$P_1$}{x : $\tau_1$}}
  \AxiomC{\htr{$\phi$}{$P_2$}{x : $\tau_2$}}
  \AxiomC{\htr{$\phi$}{$P_3$}{x : $\tau_3$}}
  \RightLabel{(try-catch-finally)}
  \TrinaryInfC{\htr{$\phi$}{try $C$ catch(e) $P_1$ finally $P_2$}{x : $\tau_1 \cup \tau_2 \cup \tau_3$}}
\end{prooftree}

\paragraph{Rules for anonymity} \crlf

Having introduced the concept and mechanism of tracing references to
\texttt{this} inside constructors, we can finally state the rules
related to anonymity which are verified by JimuvaChecker.

\begin{verrule}[Anonymity]
  Whenever a method \texttt{m} is annotated \texttt{@Anonymous}, if
  $x$ is a value of type \texttt{@This} or \texttt{@MaybeThis}:
  \begin{enumerate}[label=(\arabic*)]
  \item \texttt{m} cannot return $x$, 
  \item \texttt{m} cannot call non-anonymous methods on $x$, 
  \item inside \texttt{m}, $x$ cannot be passed as an argument to a constructor, 
  \item inside \texttt{m}, $x$ cannot be passed as an argument to a
    method of a foreign object (of type \texttt{@NotThis} or
    \texttt{@MaybeThis}),
  \item inside \texttt{m}, $x$ cannot be assigned to an object field
    or an array field.
  \end{enumerate}
\end{verrule}

The above rule makes it impossible for a checked \texttt{@Anonymous}
method to leak references to \texttt{this}, provided that such a
reference has not already been leaked.

In order to protect the first immutability property, we have to ensure
that a reference to \texttt{this} does not leak while an immutable
object is constructed. Therefore, JimuvaChecker issues a warning
whenever the following rule is violated:
\begin{verrule}[Anonymous construction of immutable objects]
  Every immutable object must be constructed using an anonymous
  constructor.
\end{verrule}


\subsection{Encapsulation of representation}

Possibly the most complicated area among the rules verified by
JimuvaChecker, enforcing encapsulation of representation aims to guard
the deep internal state of immutable objects from being modified. As
discussed in Section~\ref{sec:mod:ownership}, the internal state of
object $w$ consists of all objects which are owned by $w$, whether
directly -- by assigning them to a @Rep-annotated reference or by
using the \textrm{@OwnedBy} annotation -- or indirectly -- through the
\texttt{@Peer} annotation on a member of an object already owned by
$w$.

\paragraph{Encapsulation property} \crlf

Encapsulation of representation not only protects the deep state of
immutable objects from modifications, but also prohibits access to
internal objects from the outside. This results in a situation when
the internal state of $w$ is only accessible through $w$'s interface,
except from when $w$ decides to entrust another object with a
reference to an object it owns by passing it as a (\texttt{@Safe})
parameter to a method. Even considering this exception, JimuvaChecker
ensures that, in addition to the invariants defined in
Section~\ref{sec:invariants}, the following property is satisfied in
all checked code:

\begin{invariant}[Encapsulation of representation]
  If $v$ is a part of the state of an object $w$, then no static
  aliases are created to $v$ or any part of $v$'s state, other than
  the references by member fields of $w$ and other objects in $w$'s
  state, provided that such static references did not exist prior to
  assigning the objects to the fields. 
\end{invariant}

The rest of this section will detail on how this invariant, and the
immutability invariant with regards to deep state of objects, are
enforced. 

\paragraph{Guarding encapsulation and deep state immutability} \crlf

The following rules are enforced by JimuvaChecker in order to guard
internal state encapsulation and the immutability property with
regards to the deep state of objects.

\begin{verrule}[Encapsulation of representation]
  If $v$ is a value annotated with \texttt{@Rep}:
  \begin{enumerate}[label=(\arabic*)]
  \item $v$ cannot be returned from methods. 
  \item $v$ cannot be passed as a non-safe parameter to methods of
    foreign objects which are not annotated with
    \texttt{@Rep}. Foreign objects are objects which are not marked
    with the \texttt{@MaybeThis} or \texttt{@NotThis} annotation by
    the data-flow analysis described in Section~\ref{sec:ver:anon}
  \item $v$ cannot be declared \texttt{public}. 
  \end{enumerate}
  Moreover, if $w$ is an object with a \texttt{@Rep}-annotated member
  $v$,
  \begin{enumerate}[label=(\arabic*), resume]
  \item $v$ cannot be directly accessed by other objects, i.e. the
    expression \texttt{w.v} is erroneous, even if Java visibility
    mechanism would permit such access.
  \end{enumerate}
  If $v$ is annotated with \texttt{@Peer}, 
  \begin{enumerate}[label=(\arabic*), resume]
  \item $v$ cannot be passed as a non-safe parameter to methods of
    foreign objects which are not annotated with \texttt{@Rep} or
    \texttt{@Peer}.
  \end{enumerate}
\end{verrule}

\begin{verrule}[Deep state immutability] \label{vrl:deepimm}
  If $w$ is an immutable object holding a \texttt{@Rep}-annotated
  reference to $v$, then:
  \begin{enumerate}[label=(\arabic*)]
  \item no non-read-only method can be called on $v$, 
  \item no field of $v$ can be reassigned, i.e. any assignment of the
    form
    \begin{center}
      \texttt{v.f = x;}
    \end{center}
    is illegal.
  \item \label{pnt:deep-array} if $v$ is an array, no field of $v$ can
    be reassigned, i.e. any assignment of the form
    \begin{center}
      \texttt{v[i] = x;}
    \end{center}
    is invalid
  \end{enumerate}
\end{verrule}
Note that Rule \ref{vrl:deepimm} also applies to the receivers of
read-only methods, which are implicitly immutable by
Rule~\ref{vrl:readonly}. 

In point (\ref{pnt:deep-array}) of the rule, if the fields of the
array $v$ are arrays declared as members of $w$'s state with the
syntax like
\begin{center}
  \texttt{protected Object @Rep [] @Rep [];}
\end{center}
then the fields of the arrays cannot be reassigned. This also applies
to deeper levels of array nesting.

\paragraph{Checking \texttt{@OwnedBy} validity} \crlf

Whenever a variable, field or parameter is annotated with
\texttt{@OwnedBy}, JimuvaChecker verifies that the annotation's
argument matches a reference which exists in the annotated object's
scope. The argument is expected to be a Java string containing a
single identifier or a non-empty chain of identifiers (of the form
$x_1.x_2.\cdots.x_n$). The first identifier in the chain refers to the
\emph{base} object or class, which must be in the annotated object's
scope, whilst the other identifiers identify a member reachable
through the base's public fields. Objects of the class
\texttt{JimuvaVisitor.Owner} represent the owners. The constructors of
the class parse the arguments of \texttt{@OwnedBy} annotations and
signal any errors found therein.

An important feature here is that \texttt{Owner} objects store the
annotated types of the owner objects. This enables the checker to
identify objects whose owners are immutable or annotated with
\texttt{@Myaccess}, which is crucial for the rules described in the
next paragraph.

\paragraph{Inferring access rights on \texttt{@OwnedBy} references} \crlf

According to the definition of object state on page
\pageref{def:state}, objects annotated with \texttt{@OwnedBy(''z'')}
are part of the state of \texttt{z}. Therefore, in order to satisfy
the immutability properties, we must ensure that objects which are
owned by immutable objects are also immutable. This is done by
inferring access rights on owned objects which are the same or
stricter as the access rights of the owner object:

\begin{verrule}[Access rights of \texttt{@OwnedBy} objects]
  If an object $x$ is annotated with \texttt{@OwnedBy(''z'')} and
  \texttt{z} refers to an immutable object, the access rights of $x$
  are changed to \texttt{@Immutable}. Analogously, if \texttt{z}
  refers to an object annotated with \texttt{@Myaccess}, the access
  rights of $x$ are changed to \texttt{@Myaccess} provided that $x$ is
  not already annotated with \texttt{@Immutable}.
\end{verrule}


\paragraph{Resolving ownership} \crlf

One of the main inherent differences between Jimuva and our checker is
that Java annotations specifying ownership are \emph{relative}. That
is, the annotation does not refer to a fixed object, and to understand
which object is actually the owner, one must know the annotation and
the place of code where the annotated reference is declared. 

Let us consider an example. The class \texttt{IntList} is meant to
implement a simple singly-linked list of integers, with the integer
belonging to the internal representation of a relevant cell. 
\begin{lstlisting}
public class IntList {
  private @Rep Integer n;
  private IntList l;

  public IntList(Integer n, IntList l) {
    this.n = new @Rep Integer(n);
    this.l = l;
  }

  public changeHead(@Rep Integer newN) {
    this.n = newN;
  }
}

public class Test {
  public static void test() {
    IntList l = new IntList(1, null);
    @Rep nh = new @Rep Integer(0);
    l.changeHead(nh); /* Wrong! */
  }
}
\end{lstlisting}
In the \texttt{test()} method, allowing the invocation of
\texttt{l.changeHead} would be wrong, even though the \texttt{@Rep}
annotation matches on both the actual argument \texttt{nh} and the
formal parameter of the method. The owners of the two objects are
different: \texttt{nh} is owned by the instance of \texttt{Test} while
the parameter \texttt{n} is supposed to be owned by the list head
\texttt{l}. The correct way to invoke the method would be:
\begin{lstlisting}
@OwnedBy(''l'') nh = new @OwnedBy(''nh'') Integer(0);
l.changeHead(nh); /* Correct! */
\end{lstlisting}

The above discussion leads to the concept of \emph{ownership
  resolving}. This is a process of changing the relative ownership
specifications on elements so that they reflect the true ownership
relations. Ownership resolving must take place whenever two objects
interact, namely on:
\begin{itemize}
\item member select expressions such as \texttt{x.y}, 
\item returning a value from a method, 
\item passing parameters to a method. 
\end{itemize}
Of course, the subtyping rule (Rule 0) acts upon the modified
(resolved) ownership specifications.

In the first two cases, we have two non-trivial possibilities to
handle: if the returned value or the field are annotated with
\texttt{@Peer} and \texttt{@OwnedBy}. The \texttt{@World} annotation
remains unchanged and \texttt{@Rep} values cannot be returned from
methods or directly accessed at all.

\begin{verrule}[Resolving ownership: member access and return values]
  If the expression $x$ evaluates to a reference annotated with
  the ownership specification $T$, then:
  \begin{enumerate}[label=(\arabic*)]
  \item if $v$ is a field of $x$ annotated with \texttt{@Peer}, then
    the ownership of the expression \texttt{x.v} is resolved to $T$;
  \item if the method \texttt{m} has a return value which is annotated
    with \texttt{@Peer}, then the ownership of the expression
    \texttt{x.m($\vec{p}$)} is resolved to $T$.
  \end{enumerate}
  If $x$ is a reference, or a chain of identifiers (such as
  \texttt{l.next.next}) which evaluates to an object reference, then
  \begin{enumerate}[label=(\arabic*), resume]
  \item if $v$ is a field of $x$ annotated with
    \texttt{@OwnedBy(''z'')}, then the ownership of the expression
    \texttt{x.v} is resolved to @OwnedBy(''x.z'');
  \item if the method \texttt{m} has a return value which is
    annotated with \texttt{@OwnedBy(''z'')}, then the ownership of
    the expression \texttt{x.m($\vec{p}$)} is resolved to
    \texttt{@OwnedBy(''x.z'')}
  \end{enumerate}
\end{verrule}

Argument passing is slightly more sophisticated as a method may have a
formal argument annotated with \texttt{@Rep}, and this additional case
must be handled as well. The rule below is enacted by changing the
expected annotated type of an actual argument of a method whenever the
method is invoked. The expected argument type is changed depending on
the ownership specifications of the formal parameter of the method,
and of the object on which the method is invoked.

\begin{verrule}[Resolving ownership: argument passing]
  If $x$ is a reference, or a chain of identifiers evaluating to a
  reference, with an ownership specification $T$, and $x$ has an
  instance method \texttt{m}, then for each formal parameter $p$ of
  $m$, the actual parameter passed into the method via the invocation
  \texttt{x.m($\vec{p}$)} is expected to have an ownership
  specification $T_p$ as follows:
  \begin{enumerate}[label=(\arabic*)]
  \item if $p$ is annotated with \texttt{@Rep}, $T_p$ is \texttt{@OwnedBy(''x'')};
  \item if $p$ is annotated with \texttt{@Peer}, $T_p = T$;
  \item if $p$ is annotated with \texttt{@OwnedBy(''z'')}, $T_p$ is
    \texttt{@OwnedBy(''x.z'')}.
  \end{enumerate}
\end{verrule}

\subsection{Enforcing the safety of \texttt{@Safe} values}

\subsection{Handling immutable classes}

\addcontentsline{toc}{chapter}{References}
\bibliography{biblio.bib}{}
\bibliographystyle{plain}

\end{document}
