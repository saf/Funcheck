\documentclass{pracamgr}

% Encoding and charsets
\usepackage[utf8]{inputenc}
\usepackage{t1enc}

% Utility packages
\usepackage{url}
\usepackage{subfigure}
\usepackage{color}

% Tikz
\usepackage{tikz}
\usetikzlibrary{shapes,arrows}

% Listings configuration 
\usepackage{listings}
\lstset{language=Java,columns=fullflexible, xleftmargin=1cm,}
% \renewcommand{\texttt}{\textsf}


\author{Sławomir Rudnicki}
\nralbumu{248277}

\title{Weryfikacja niemutowalności obiektów w Javie}
\tytulang{Verifying immutability of Java objects}
\kierunek{Informatyka}

\opiekun{dr. Aleksego Schuberta\\
  Instytut Informatyki\\
  }
\date{Maj 2011}
\dziedzina{11.3 Informatyka}
\klasyfikacja{D. Software\\
  D.2 SOFTWARE ENGINEERING\\
  D.2.4. Software/Program Verification
}

\keywords{Java, immutability, ownership, verification, Jimuva}

\newtheorem{defi}{Definition}[section]

\newcommand{\todo}[1]{{\color{red} [#1] }}

\newenvironment{code}{\begin{center}\begin{alltt}}{\end{alltt}\end{center}}

\begin{document}
\maketitle

\begin{abstract}
  \todo{Abstract}
\end{abstract}

\tableofcontents
%\listoffigures
%\listoftables

\chapter{Introduction}
\label{chap:intro}

\section{Jimuva}
\label{sec:jimuva}

In their work, Haack, Poll, Schäfer and Schubert \cite{haack} aim to
extend a Java-like language with specifications for object
immutability and ownership. They also provide a type inference system
for statically enforcing properties related to immutability.

This section aims to present the features of Jimuva which are
important to this work. Please refer to \cite{haack} for a
comprehensive specification of the syntax and semantics of the
language. 

Throughout Section \ref{sec:modelling}, we will refer to how the
notions introduced below are reflected in the JimuvaChecker type
system, and Section \ref{sec:checking} will deal with how the related
desired properties are verified in practice.

\subsection{Immutability and ownership specifications}
\label{subsec:imm-spec}

Haack et al. extended the object types of their language with
immutability and ownership specifications. Each object type in Jimuva
is therefore of the form
\begin{center}
  \texttt{C<ar, v>},
\end{center}
where \texttt{C} is a class name, \texttt{ar} determines the
\emph{access rights} to the object and \texttt{v} specifies the
\emph{owner} of the object.

Access rights may be used to restrict the operations that may be
performed on a given object. The access rights specification may be
one of three kinds:
\begin{itemize}
\item \texttt{C<rdwr, v> x} -- access to \texttt{x} is unrestricted, 
\item \texttt{C<rd, v> x} -- \texttt{x} is \emph{read-only}: its state
  cannot change throughout the lifespan of the object.
\item \texttt{C<myaccess, v> x} -- \texttt{x} has the same access
  rights as the object that references it.
\end{itemize}

Owner specifications may include an object identifier, or one of the
special identifiers and variables:
\begin{itemize}
\item \texttt{C<ar, world> x} -- no other object owns the given object
  \texttt{x}, making it freely accessible from the outside world. This
  is the default ownership specification in Jimuva.
\item \texttt{C<ar, myowner> x} -- the owner of the given object
  \texttt{x} is the same as the owner of the object which references
  \texttt{x} as a field, parameter or local variable.
\item \texttt{C<ar, this> x} -- the object \texttt{x} is a part of the 
  object which references \texttt{x}. 
\end{itemize}

\subsection{Auxiliary specifications}
\label{sub:jimuva-aux}

In addition to the immutability and ownership specifications for
objects, Jimuva introduces several other annotations that apply to
classes and methods.

\subsubsection{Immutable classes}

If a class is marked \texttt{immutable}, all its instances must be
immutable, i.e. access to them must be read-restricted.

\subsubsection{Read-only methods}

The \texttt{rdonly} attribute of a method indicates that the receiver
(the object referenced by \texttt{this}) must not be modified within
the method's body.

\subsubsection{Anonymous constructors}

An \emph{anonymous} constructor does not leak references to
\texttt{this} to other objects \cite{vitek}. The body of a constructor
is the place where even immutable objects still mutate. Therefore, if
such a constructor would pass a reference to the constructed object to
the outside world, a foreign object could witness two different states
of the object, breaking the immutability property. All constructors of
an immutable class are verified for anonymity in
Jimuva.

\subsubsection{Write-local constructors}
\label{sub:jimuva-wrlocal}

Java visibility modifiers (\texttt{private}, \texttt{public} and
\texttt{protected}) constrain visibility with regards to classes
rather than objects. As a consequence, it would be possible for a
constructor to mutate an object of the same class different from the
constructed object. The \texttt{wrlocal} annotation was devised to
disallow such mutations: a \emph{write-local} constructor cannot
modify foreign objects nor call non-readonly methods on objects whose
ownership is not \texttt{world}. Such actions would break the
visibility modifiers, which are now to be understood as per-instance
constraints.

The concept of write-locality was deemed unneccessary in
JimuvaChecker, as explained in Section \ref{sub:mirroring-writelocal}.

\subsection{Ownership polymorphism}

Jimuva allows for \emph{owner-polymorphic} methods, which have
parameters whose owner objects may be established in the invocation. A
polymorphic method is declared in the following way:
\begin{center}
  \texttt{<x,y> void copy(C<x> from, C<y> to)}
\end{center}
and the object identifiers \texttt{x} and \texttt{y} may be
instantiated to any object.

The authors note that if one or more arguments is instantiated to
\texttt{this}, it is important to ensure that no static aliases to
such internal representation objects are created, lest they could be
used to modify the state of \texttt{this}. Section \ref{sec:safe}
deals with this problem in the context of JimuvaChecker.

\chapter{The JimuvaChecker tool}

This chapter will present JimuvaChecker, the checker tool created as
part of this thesis. We aimed to implement the concepts of the
language Jimuva, as presented in section \ref{sec:jimuva}, and develop
a checker tool which would satisfy the following requirements:
\begin{itemize}
\item \textbf{Applicability to full Java.} The syntax of Jimuva
  differs from that of full Java. In some ways, it is reduced: there
  are no loops and even no conditional branches in the core
  language. In other ways, the syntax is modified -- for example, it
  utilizes let-binding of local variables rather than declarations --
  or extended, as it is the case with the ownership and access rights
  specifications and owner-polymorphism of methods.
\item \textbf{Efficient checking.} Checking the immutability
  properties of a system should come together with normal
  development. If there is no lag between compilation and immutability
  verification, the developers can fix the surfacing errors
  immediately, ensuring that the software is free of immutability
  violations. 

  To be incorporated into normal development, however, a checker must
  be efficient, i.e. the verification must come with no significant
  time overhead. A way to ascertain this is to make the checking
  \emph{modular} -- to verify a compilation unit, a modular checker
  only requires the source code for the unit and the declarations for
  the methods and classes used therein.
\end{itemize}

In order to mirror the notions introduced in Jimuva, Java annotations
are used in JimuvaChecker to describe properties of objects, methods
and classes within the syntax of Java. However, the syntax of Java
annotations, as introduced in Java 5 \cite{jls3}, is insufficient to
express all immutability-related properties. Therefore, we needed to
use the extended annotation syntax proposed in the Java Specification
Request 308 \cite{jsr308}. As a proof of concept, the authors of the
JSR 308 specification created a Checker Framework \cite{checkers},
which can be used to build compiler plugins acting as annotation
processors for the extended syntax.

JimuvaChecker, the checker tool created as part of our work, was
implemented using the Checker Framework.

The following section lists some of the syntax extensions introduced
by JSR 308 which are crucial to the functioning of our checker.
Section \ref{sec:framework} proceeds to describe the main concepts of
the Checker Framework. Section \ref{sec:checking} details on the type
system and verification implemented in JimuvaChecker.

\section{JSR 308}
\label{sec:jsr308}

JSR 308 is a specification request which regards an extension to the
syntax of Java annotations. First proposed in 2006, it was meant to
become a part of the Java 7 standard. Although it was not incorporated
into Java 7, the extension proves to be especially useful in the field
of program verification. This work relies on the enhancements proposed
in JSR 308.

The JSR allows annotations to appear on any occurrence of a
type. Below, we list the syntactic constructs originating from this
extension which are the most useful for the analysis of JimuvaChecker,
along with examples of their use. Please refer to \ref{jsr308} for a
complete discussion of the syntax changes. 

\begin{itemize}
\item \textbf{Object creation.} The type of objects created using the
  \texttt{new} operator may be annotated:
  \begin{center} 
    \texttt{x = new @Important Document()}
  \end{center}
\item \textbf{Method receivers.} The type of a method's receiver
  object may be annotated by putting the annotations after the list of
  arguments:
  \begin{center} 
    \texttt{void process(Document x) @ReadOnly \{ ... \}}
  \end{center}
\item \textbf{Array levels.} The user may annotate chosen levels of a
  multidimensional array. The semantics of such annotations are best
  shown on the following examples:
  \begin{itemize}
  \item Two-dimensional array of read-only documents: 
    \begin{center}
      \texttt{@Readonly Document [][]}
    \end{center}
  \item A read-only array of Document arrays:
    \begin{center}
      \texttt{Document @ReadOnly [][]}
    \end{center}
  \item An array of read-only arrays of Documents:
    \begin{center}
      \texttt{Document [] @ReadOnly []}
    \end{center}
  \end{itemize}
\item \textbf{Arguments of generic types and polymorphic methods.} The
  formal parameters of generic types and polymorphic methods may be
  annotated, as well as the actual parameters passed to a generic type
  when it is instantiated:
  \begin{center}
    \texttt{x = new LinkedList<@NonNull @ReadOnly String>()}
  \end{center}
\end{itemize}


\section{The Checker Framework}
\label{sec:framework}

\begin{figure}
  \centering
  
  \subfigure[Example hierarchy of type annotations]{
    \tikzstyle{block} = [draw, rectangle, fill=blue!10]  
    \begin{tikzpicture}[auto, node distance=3cm, >=latex]
      \node [minimum width=6cm] at (2, 1.5) (dummy) {};
      \node [block] (top) at (2, 1.5) {@Nullable}; 
      \node [block, below of=top] (bot) at (2, 1.2) {@NonNull}; 
      \draw [->] (bot) -- (top); 
    \end{tikzpicture}
  }
  \subfigure[The resulting type hierarchy]{
    \tikzstyle{block} = [draw, rectangle, fill=orange!10]  
    \begin{tikzpicture}[auto, node distance=3cm, >=latex]
      \node [block] (top) {@Nullable Object}; 
      \node [block, below left of=top] (left) {@NonNull Object}; 
      \node [block, below right of=top] (right) {@Nullable Date}; 
      \node [block, below right of=left] (bot) {@NonNull Date}; 
      
      \draw [->] (bot) -- (left); 
      \draw [->] (bot) -- (right); 
      \draw [->] (right) -- (top); 
      \draw [->] (left) -- (top); 
      
    \end{tikzpicture}
  }
  \caption{Relations between annotated types in a checker. An arrow from
    A to B indicates that A is a subtype of B.}
  \label{fig:example-checker-hierarchy}
\end{figure}


The Checker Framework is a tool which can be used to create new
annotation processors for Java. Basically, the checkers extend the
type-checking functionality of the Java compiler itself by introducing
a hierarchy of \emph{type annotations} on top of the hierarchy
stemming from simple subclassing and interfacing. Type annotations are
Java annotations which can be used on any type occurrence, as enabled
by the syntax extensions of JSR 308. They can be organised in a
supertype-subtype hierarchy which enhances the existing Java type
hierarchy.

Figure \ref{fig:example-checker-hierarchy} shows how such an enhanced
type hierarchy works. Here, the type annotation @NonNull is defined to
be a subtype of the default annotation @Nullable. Subtyping in the
resulting type hierarchy may come from two sources: normal Java
subclassing and the subtyping between type annotations.

Normally, a pluggable type checker works by extending the
functionality of the simple \texttt{BaseTypeChecker} shipped with the
framework. The \texttt{BaseTypeChecker} verifies that all assignments,
including implicit ones such as the assignment of parameters to formal
arguments of methods during method invocation, follow the subtyping
rules. Specifically, if a value of type $B$ is assigned to a reference
of type $B$, the checker verifies that $B$ is a subtype of $A$ as per
the enhanced type hierarchy.

A checker based on the Checker Framework usually consists of two main
modules:
\begin{itemize}
\item the \textbf{annotated type factory}, which provides syntactical
  constructs of the Java language with type annotations according to a
  given set of rules,
\item the \textbf{visitor} which traverses the nodes of the abstract
  syntax tree (AST) of the given compilation unit and verifies
  properties based on their annotated types inferred by the annotated
  type factory. This module acts upon the AST by making use of the
  Visitor design pattern \cite{visitor}. Of course, the properties to
  be checked are not limited to simple subtyping checking; one may
  implement any rule which the code being compiled will be checked
  against.
\end{itemize}
Figure \ref{fig:simple-checker} contains the schema of how the modules
of a checker work to verify the properties of a given source code
file.

\begin{figure}
  \centering

  \tikzstyle{block} = [draw, rectangle, fill=orange!10, minimum width=3cm, minimum height=0.6cm]
  \begin{tikzpicture}[auto, node distance=3cm, >=latex]
    \node [block, fill=blue!10] (compiler) at (5, 5) {\texttt{javac -processor checkers.x.XChecker code.java}};
    \node [block, fill=orange!10] (checker) at (5, 4) {XChecker}; 
    \node [block, fill=yellow!20, node distance=5cm, pin={[pin edge={to-, thin, black}] above:{source code}}] 
    (code) at (0, 3) {\texttt{code.java}};
    \node [block] (visitor) at (3, 1) {XVisitor};
    \node [block] (factory) at (9, 1) {XAnnotatedTypeFactory};

    \draw [->, dashed] (compiler) -- (checker);
    \draw [->, dashed] (checker) -- (factory);
    \draw [->, dashed] (checker) -- (visitor);
    \draw [<->] (visitor) -- node {\parbox[c]{1cm}{\small{assign types}}} (factory) ;
    \draw [->] (visitor) -- node {\parbox[c]{1.2cm}{\small{check} \tiny{(Visitor pattern)}}} (code);
  \end{tikzpicture}

  \caption{A simplified schema of source code file analysis by a
    Checker Framework-based checker.}
  \label{fig:simple-checker}
\end{figure}


\section{Modelling Jimuva in Java}
\label{sec:modelling}

This section contains details on the translation of Jimuva access
rights and~ownership specifications into Java annotations. For
information on how the desired properties are verified, please refer
to Section \ref{sec:checking}.

\subsection{Introduction}

There are two basic concepts of Jimuva which extend the Java language
syntax and therefore need to be translated into Java annotations: the
access rights and ownership specifications. The other differences
between the syntax of Jimuva and Java are virtually insignificant for
this work. For example, the \texttt{let}-bindings, which Jimuva uses
in place of local variables, are easily mirrored into simple local
variable declarations. Taking care of the syntactical construct of
Java which do not exist in Jimuva, such as loops, will also prove to
be easy for the purpose of verifying immutability properties.

As mentioned in the previous section, \todo{check if it is previous}
the checkers which make use of the Checker Framework should build a
hierarchy of type annotations. Such a hierarchy has been created in
JimuvaChecker, along with rules which need to be enforced in order to
ensure immutability and ownership-related correctness. The following
sections elaborate upon the mapping from Jimuva to this hierarchy and
may be considered as a discussion of the syntax of the language
JimuvaChecker works upon.

\subsection{Modelling immutability specifications}

The immutability specifications of Jimuva are mapped into three type
annotations as shown in Table \ref{tab:mapping-immut}. 

\begin{table}[htb]
  \centering
  \begin{tabular}{|l|l|l|}
    \hline
    \textbf{Jimuva type} & \textbf{Description} & \textbf{Java annotated type} \\
    \hline \hline
    \texttt{C<rdwr>} & Unrestricted & \texttt{@Mutable C} \\
    \texttt{C<myaccess>} & Same as referencing object & \texttt{@Myaccess C} \\
    \texttt{C<rd>} & Read-restricted & \texttt{@Immutable C} \\
    \hline
  \end{tabular}
  \caption{Mapping of Jimuva type specifications into Java annotated types.}
  \label{tab:mapping-immut}
\end{table}

Note that \texttt{@Immutable} objects must be created as such, using
the syntax introduced by JSR 308, e.g.:
\begin{center}
  \texttt{@Immutable C x = new @Immutable C()}
\end{center}

If no access rights type annotation is specified for an object, the
type annotation will default to \texttt{@Mutable}. Therefore, there is
no need for an user to insert the \texttt{@Mutable} annotation in
their code, though they may want to emphasise the mutability of a
particular object.

There are several limitations on the use of access rights annotations
to be checked by JimuvaChecker:
\begin{itemize}
\item \textbf{Arrays must be \texttt{@Mutable}.} An object of array type
  \texttt{C []} has no constructor visible to the outside
  world. Therefore, there would be no way to initialize the contents
  of an \texttt{@Immutable} array other than by a static initializer,
  \begin{table}[htb]
    \centering

    \caption{Mapping of Jimuva ownership specifications into Java annotated types.}
    
  \end{table}
  which is too limited for most uses. 
\item \textbf{\texttt{@Myaccess} is invalid on static members.} As in
  Jimuva, the \texttt{@Myaccess} annotation is designed to be an
  access rights variable which is instantiated to the access rights of
  another object which references the given object. The notion of a
  \emph{referencing object} is invalid in the case of static members
  of classes, parameters of static methods and local variables
  declared inside static methods. JimuvaChecker does not permit
  \texttt{@Myaccess} annotations on those elements. 
\end{itemize}

Of course, the access rights annotations may be used on every
occurrence of a type. We might for example constrain the access rights
for a method parameter or the returned value, as shown in the
following listing:
\begin{lstlisting}
public class B {
  protected @Myaccess A a;

  void set(@Myaccess A a) {
    this.a = a;
  }

  @Myaccess A get() {
    return this.a;
  }
}
\end{lstlisting}
Note that the \texttt{@Myaccess} will be instantiated in a given
object of class $B$ to whatever access rights the object has. If the
object is \texttt{@Immutable}, JimuvaChecker will enforce that the
value returned from \texttt{get()} and the value passed to
\texttt{set()} as a parameter are also immutable.

\subsection{Modelling auxiliary specifications}

The auxiliary specifications for classes and methods described in
Section \ref{sub:jimuva-aux} are mirrored in the JimuvaChecker's type
system in the following way: 

\subsubsection{Immutable classes}

The \texttt{@ImmutableClass} annotation may precede any class
declaration, including local classes and member classes, e.g.:

\begin{lstlisting}
@ImmutableClass
public class C {
  ...
}
\end{lstlisting}

\subsubsection{Read-only methods}

The user may constrain a method not to modify the object it is called
on by preceding its declaration with the \texttt{@ReadOnly} annotation:

\begin{lstlisting}
@ReadOnly public A getX() { 
  return x; 
}
\end{lstlisting}
This annotation is equivalent (and internally translated by Jimuva) to 
annotating the receiver type of the method with \texttt{@Immutable}.

\subsubsection{Anonymous constructors}

Similarly to the \texttt{@ReadOnly} annotation on methods,
constructors may be annotated with \texttt{@Anonymous}, which
indicates that the constructor should be checked for not leaking
references to \texttt{this} to the outside world.

\subsubsection{Write-local constructors}
\label{sub:mirroring-writelocal}

In JimuvaChecker, the notion of write-local constructors, as described
in Section \ref{sub:jimuva-wrlocal}, is unneccessary and, as a
consequence, absent. The fact that visibility modifiers are understood
\emph{per class}, as it is done in Java, and not \emph{per object},
does pose a problem, but not one that is related solely to
constructors. Let us consider the relevant example brought up by Haack
et al.:
\begin{lstlisting}[morekeywords={immutable, anon, wrlocal, rdonly}]
immutable class Wrong {
  Mutable<this> m; 
  rdonly int get() { m.get() }
  anon wrlocal Wrong.k(Wrong o) {
    this.m = new Mutable<this>.k(o.get()); 
    o.m.set(23); /* side-effect on other object */
  }
}
\end{lstlisting}
The authors argue that constructors must be prohibited from calling
non-\texttt{rdonly} methods on members owned by other
objects. However, the same example could be contrived if
\texttt{Wrong.k} were a method rather than a constructor. Apparently,
the actual problem lies in the fact that the constructor may access
the field \texttt{m} which is a part of the internal representation of
the object \texttt{o}. In JimuvaChecker, we prohibit all objects from
accessing the internal representation of another object, even if such
access would be enabled by Java's member visibility mechanism. As a
result, the \texttt{wrlocal} annotation is unneccessary, because all
methods and constructors are write-local in the sense introduced in
Jimuva.

Section \ref{sec:checking-rep} offers more insight on how internal
representation of objects is protected in JimuvaChecker. 


\subsection{Modelling ownership specifications}

The ownership specifications introduced in Jimuva are very liberal: an
object may be owned by any other object within its scope. \todo{true?}
There are several ownership variables which can be used in place of
object identifiers in the ownership specification of an object. 

Table \ref{tab:mapping-owner} shows how the different possible
ownership specifications are reflected into Java type annotations.
\begin{table}[htb]
  \centering
  \begin{tabular}{|l|l|l|}
    \hline
    \textbf{Jimuva type} & \textbf{Description} & \textbf{Java annotated type} \\
    \hline \hline 
    \texttt{C<this>} & owned by the referencing object & \texttt{@Rep C} \\
    \texttt{C<myowner>} & same owner as the referencing object & \texttt{@Peer C} \\
    \texttt{C<world>} & no owner & \texttt{@World C} (default) \\
    \texttt{C<v>} (general case) & owned by \texttt{v} & \texttt{@OwnedBy(''v'') C} \\
    \hline
  \end{tabular}
  \caption{Mapping Jimuva ownership specifications into Java annotated types}
  \label{tab:mapping-owner}
\end{table}
If no ownership specification is given for an object, the type
annotation defaults to \texttt{@World}. The user does not need to use
the \texttt{@World} annotation in their code.

\subsubsection{Encapsulation of representation}

JimuvaChecker implements the concept of \emph{encapsulation of
  representation}. The objects which are pointed to by references
marked with the \texttt{@Rep} annotation are considered a part of the
internal representation of the enclosing object. As such, they are
protected from being accessed from outside the enclosing
object. Section \ref{sec:checking-owner} provides more details on the
mechanism used to enforce encapsulation of representation in
JimuvaChecker. 

It should be noticed that encapsulation of representation proves a
hindrance to the language using it. Some real-life constructs which
would make use of internal representation cannot be expressed by means
of \texttt{@Rep} only. The most prominent class of examples of such
limitations are collections (understood as pointer structures such as
lists) of elements which would be protected from outside access using
the \texttt{@Rep} ownership specification. 

\lstinputlisting[float, label={lst:stack-rep}, caption={An erroneous
  implementation of a stack whose element are protected from outside
  access, built using the \texttt{@Rep} annotation
  only.}]{code/coll-rep.java}

Listing \ref{lst:stack-rep} indicates the main problems with this
approach by showing an implementation of a simple stack. If the
stack's elements are to be protected inside the \texttt{Cell} class by
the \texttt{@Rep} annotation, the representation protection mechanism
will allow the method \texttt{Cell::getData} neither to return
\texttt{data} directly nor to pass it to the copying constructor, as
both actions may potentially expose internal representation of the
cell to a foreign object. What is more, the implementation would
require that the collection's elements are copied while they are
retrieved, which makes it impossible for the whole collection
impossible to be generic.

\lstinputlisting[float, label={lst:stack-peer},
caption={Implementation of a stack whose elements belong to the owner
  of the stack. }]{code/coll-peer.java}

The \texttt{@Peer} annotation comes to rescue by offering a way to
protect objects from external access, while being more lenient when it
comes to the operations permitted on the objects. Actually, protection
of internal representation is still active, but it is taken to another
level. By annotating them with \texttt{@Peer}, objects are
arranged into groups sharing the same owner, and they may still only
be accessed through the owner's interface. 

This grouping lays at the base of the Universes type system introduced
by Dietl and Müller \cite{universes}, where objects are considered to
be in the same \emph{context} if they share owners. In their work, the
reference types equivalent to both \texttt{@Rep} and \texttt{@Peer}
are supertyped by \emph{read-only} references in order to allow
non-modifying access to an object's context. In Jimuva, as well as in
our checker, the concepts of ownership and immutability are
orthogonal. \todo{Allow representation sharing with immutable
  references?}

Listing \ref{lst:stack-peer} shows an implementation of a stack using
both variable ownership specifications \texttt{@Rep} and
\texttt{@Peer}. As opposed to the previously considered
\texttt{RepStack}, this implementation can be correctly type-checked
in our type system. 

\subsubsection{Ownership by any object}

While mirroring the ownership variables does not pose a problem,
creating a mechanism which would allow an object to be owned by any
other object in its scope is more complicated. Since Java annotations
only allow simple types as their parameters, the ownership
specification has to consist in a textual description of the owner
rather than reference the owner itself. This leads to two major
limitations relating to the syntax as well as the semantics of the
construct in JimuvaChecker.

Firstly, due to the fact that a textual description of the owner
object must be analysed, the range of objects which can be specified
as owners of a given object is bound to be limited. In JimuvaChecker,
the following objects are allowed as owners:
\begin{itemize}
\item \textbf{Formal parameters of enclosing methods:}
  \begin{lstlisting}
void changeHead(IntList list, Integer n) {
  @OwnedBy(''list'') Integer nc = new @OwnedBy(''list'') Integer(n);
  list.setHead(nc);
}
  \end{lstlisting}
\item \textbf{Static and instance fields of enclosing classes:}
  \begin{lstlisting}
public class A {
  IntList list;

  void addZero() {
    @OwnedBy(''list'') Integer zero = new @OwnedBy(''list'') Integer(0);
    list.add(zero);
  }
}
\end{lstlisting}
\item \textbf{Static fields of member classes in the object's scope:}
  \begin{lstlisting}
public class A {
  public static class B {
    static IntList list;
  }

  @OwnedBy(''B.list'') Integer n;
}
\end{lstlisting}
Note that only the fields of member classes of the classes that
enclose the annotated reference may be used. Introducing support for
static fields of any class visible in the scope of the reference would
be possible with the Java reflection mechanism
\cite{reflection}. However, this might lead to circular dependencies
and other problems when compiling a large project. Adding
reflection-based support for the ownership by static fields of any
class is a possible future enhancement for the checker.
\item \textbf{Local variables present in the object's scope:}
\begin{lstlisting}
IntList initList() {
  IntList list = new IntList();
  list.add(new @OwnedBy(''list'') Integer(0)); 
  return list;
}
\end{lstlisting}
\item \textbf{Public fields in the transitive reach of all of the
    above objects.} For each object listed above, the user may specify
  as owners their public fields and the public fields of the objects
  in those public fields etc. What is more, if a member of the
  transitive reach has an instance class, its static members and the
  transitive reach thereof may be referenced. The string descriptions
  of the reachable objects is constructed with the normal (dot)
  notation for member access. All of the following annotations are
  valid:
  \begin{lstlisting}
public class A {
  public static class B {
    public IntList list;
  }
  public static class C {
    static B b;
    public B d;
  }
  public class E {  /* Instance class */
    static IntList list
  }
  
  @OwnedBy(''C.b.list'') Integer n;
  @OwnedBy(''E.list'') Integer m;
  void process() {
    C x = new C();
    @OwnedBy(''x.d.list'') Integer p;
    x.d.list.add(p);
  }  
}
  \end{lstlisting}
\end{itemize}

The second limitation regarding this general case of ownership is
connected to the semantics. Because ownership is represented by a
string rather than a true reference to an object, we do not have a way
of verifying that the reference described in the annotation's
parameter does not change. Consider the following example:
\begin{lstlisting}
void process() {
  IntList list = new IntList();
  @OwnedBy(''list'') Integer n = new @OwnedBy(''list'') Integer(0);
  list = new IntList();
}
\end{lstlisting}
The reference \texttt{list} changes, but the description in the
ownership specification for \texttt{n} does not. The \texttt{@OwnedBy}
annotation introduces references, rather than particular objects, as
owners. 

Another related problem with the general ownership lies in the fact
that the owner descriptions are relative to the annotated object. The
issue here is that the same object can be referenced as the owner in
some places in the code, while being out of scope in other places. The
most prominent example here is the case of formal method parameters
which are constrained to be owned by a private field of the class.
Because JimuvaChecker follows the visibility mechanism of Java in not
allowing owner specifications to access non-public fields, no other
object may call such a method because it cannot build an appropriate
argument as the requested owner is out of its scope.


\paragraph{Encapsulation of representation} $\quad$ \\

It would seem that, by introducing the general case of ownership into
their code using the \texttt{@OwnedBy} annotation, the user forfeits
the protection of the internal representation of objects. Indeed, the
property that no object may witness the internal state of another
object is violated in that case. The more important property of
encapsulation is enforced in JimuvaChecker: the internal
representation of an immutable object may not be
modified. JimuvaChecker disallows a situation where the access rights
to an object \texttt{@OwnedBy(''x'')} are less restrictive than those
of \texttt{x} itself. More information on how this is achieved is
available in Section \todo{Reference}.

\subsection{Modelling polymorphic methods}




\addcontentsline{toc}{chapter}{References}
\bibliography{biblio.bib}{}
\bibliographystyle{plain}

\end{document}
